{"content": "Tác_giả : Nguyễn_RR Thành_Trung_Table of_Contents 1 .\nMở_đầu 2 .\nPersistent_IT Tư_tưởng Cài_đặt : Phân_tích 3 .\nPersistent_BIT Tư_tưởng : Cài_đặt : Phân_tích : 4 .\nRetroactive_Data_Structures Bài_tập áp_dụng 1 .\nMở_đầu Persistent_Data_Structures là những cấu_trúc dữ_liệu được dùng khi chúng_ta cần có toàn_bộ lịch_sử của các thay_đổi trên 1 cấu_trúc dữ_liệu (CTDL) .\n(Chú ý rằng từ persistent còn được dùng trong persistent storage với một nghĩa hoàn_toàn khác) .\nXét bài_toán ví_dụ : Cho một dãy A gồm N phần_tử .\nCó 2 loại truy_vấn : Update : Gán A_i = v Query : Tìm max(A_i , . . . , A_j) tại thời_điểm sau phép gán thứ K .\nNếu_không có đoạn tại thời_điểm sau phép gán thứ K , bài_toán là 1 bài cơ_bản trên Interval_Tree .\nĐoạn tại thời_điểm sau phép gán thứ K buộc chúng_ta phải lưu lại các thông_tin về lịch_sử cập_nhật_CTDL - việc này được giải_quyết bằng các Persistent_Data_Structures .\nGọi trạng_thái của CTDL tại một_thời điểm là 1 version của CTDL đó .\nMột_cách cụ_thể hơn , persistent data structures cho_phép chúng_ta : Truy_vấn trên một version cũ của CTDL Cập_nhật dữ_liệu trong version mới nhất của CTDL , bằng cách tạo thêm 1 version mới của CTDL .\nTrong một_số cách cài_đặt , Persistent_Data_Structures còn có_thể cho_phép thay version hiện_tại của CTDL thành một version trong quá_khứ (phần 2 mô_tả phương_pháp cài_đặt có_thể thực_hiện được thao_tác này) .\nCần hiểu rằng Persistent_Data_Structures không_phải là một loại CTDL mới .\nNó là một_số kĩ_năng tổng_quát giúp thêm thông_tin về lịch_sử thay_đổi vào CTDL thông_thường một_cách hiệu_quả .\nVí_dụ : IT + Persistent --gt; Persistent_IT_BIT + Persistent --gt; Persistent_BIT Tại_sao lại là một_cách hiệu_quả ?\nBởi_vì ta hoàn_toàn có_thể có_một Persistent_Data_Structures bằng cách trâu_bò : khi cập_nhật , ta tạo một bản_sao hoàn_toàn mới của CTDL , thay_đổi một_số dữ_liệu trên nó và lưu lại .\nNhư_vậy ta luôn có được một thuật_toán với độ phức_tạp O(Q_N_T) và bộ_nhớ O(Q_N) , với Q là số thao_tác cần thực_hiện , và N là độ lớn của CTDL , và T là thời_gian để thực_hiện thao_tác trên CTDL .\nTrong các phần dưới_đây , mình sẽ trình_bày về 2 kĩ_thuật thông_thường của Persistent_Data_Structures .\n2 .\nPersistent_IT Tư_tưởng Quay trở_lại bài_toán .\nChúng_ta biết rằng mỗi thao_tác update trên IT chỉ mất O(logN) .\nĐiều này tương_đương với việc mỗi thao_tác update chỉ làm thay_đổi O(logN) nút trên cây .\nNhư_vậy ta hoàn_toàn có_thể lưu lại tất_cả các thay_đổi trên tất_cả các nút trong O(QlogN) .\nTừ_đó , ta rút ra được một tư_tưởng cài_đặt thuật_toán : Với mỗi thao_tác Update , ta tạo thêm một_số nút mới trên IT .\nĐể_không phải sinh thêm các nút không bị thay_đổi , một nút ở version mới có_thể có_con là một nút ở vesion cũ .\nChú_ý : Mỗi thao_tác Update luôn thay_đổi một đường_đi từ gốc đến một nút lá , nên không có trường_hợp một nút ở version cũ có_con là một nút ở version mới hơn .\n(Nếu thao_tác Update là Update 1 đoạn , các nút bị thay_đổi không còn là một đường_đi nữa , nhưng nhận_xét này vẫn đúng) .\nKhi thực_hiện thao_tác Query trên version t , ta chỉ_cần thực_hiện Query trên nút gốc ở version t .\nTư_tưởng này còn được gọi_là Path_Copy trong các tài_liệu tiếng Anh .\nCài_đặt : struct Node int left , right ; // ID of left child amp; right child long_long ln ; // Max value of node Node () Node ( long_long ln , int left , int right ) : ln ( ln ) , left ( left ) , right ( right ) it 11000111 ; // Each node has a position in this array , called ID int nNode ; int ver MN ; // ID of root in each version // Update max value of a node inline void refine ( int cur ) it cur .\nln = max ( it it cur .\nleft .\nln , it it cur .\nright .\nln ); // Update a range , and return new ID of node int update ( int l , int r , int u , int x , int oldId ) if ( l == r ) ++ nNode ; it nNode = Node ( x , 0 , 0 ); return nNode ; int mid = ( l + r ) gt;gt; 1 ; int cur = ++ nNode ; if ( u lt;= mid ) it cur .\nleft = update ( l , mid , u , x , it oldId .\nleft ); it cur .\nright = it oldId .\nright ; refine ( cur ); else it cur .\nleft = it oldId .\nleft ; it cur .\nright = update ( mid + 1 , r , u , x , it oldId .\nright ); refine ( cur ); return cur ; // Get max of range .\nSame as usual IT int get ( int nodeId , int l , int r , int u , int v ) if ( v lt; l r lt; u ) return - 1 ; if ( u lt;= l amp;amp; r lt;= v ) return it nodeId .\nln ; int mid = ( l + r ) gt;gt; 1 ; return max ( get ( it nodeId .\nleft , l , mid , u , v ) , get ( it nodeId .\nright , mid + 1 , r , u , v )); // When update : ++ nVer ; ver nVer = update ( 1 , n , u , x , ver nVer - 1 ); // When query : res = get ( ver t , 1 , n , u , v ); Giải_thích : Ban_đầu , ta có_một mảng it , lưu tất_cả các nút sẽ được sinh_ra của IT .\nMỗi nút gồm có Chỉ_số của con trái , index của con phải (2 biến left và right ) Giá_trị lớn nhất của các số trong_khoảng mà nút quản_lý (ở version khi nút đó được tạo ra) : biến ln Ta lưu thêm chỉ_số của các nút gốc ở các version khác_nhau vào một mảng ver Hàm update : Tạo ra các nút mới , và trỏ đến các con_ở version cũ hoặc version mới , tùy_theo các con có bị thay_đổi hay_không Trả_lại index của nút mới được tạo Hàm_get : Trả_lại max của một đoạn được quản_lý bởi nút nodeId Phân_tích Cách cài_đặt Persistent_Data_Structures trong mục này rất hiệu_quả .\nNó hoàn_toàn không làm tăng thêm độ phức_tạp (persistent IT có độ phức_tạp mỗi thao_tác là O(logN)) , và bộ_nhớ cần thêm là tối_ưu : O(Q logN) .\nTuy_nhiên , cách cài_đặt này không dễ áp_dụng với những CTDL khác .\nChẳng_hạn sẽ rất khó để cài đúng BIT với phương_pháp này .\nỞ mục tiếp_theo , mình sẽ trình_bày một phương_pháp cài_đặt khác có_thể dùng cho BIT , tuy_nhiên có độ phức_tạp lớn hơn .\n3 .\nPersistent_BIT Tư_tưởng : Tại mỗi nút của BIT , thay_vì lưu một giá_trị , ta lưu lại tất_cả các cặp (version , giá trị) ở nút đó .\nThao_tác update rất đơn_giản : chỉ_cần thêm một cặp (version , giá trị) vào các nút tương_ứng .\nVới thao_tác query tại version t , trên một nút , ta cần tìm cặp (version , giá trị) mới nhất vào trước thời_điểm t - việc tìm_kiếm này có_thể được thực_hiện bằng tìm_kiếm nhị_phân .\nCách cài_đặt này được gọi_là Fat_Node trong các tài_liệu tiếng Anh .\nCài_đặt : Code_BIT trích từ bài IPSC 2011 - Grid_Surveillance : define _(x) (x amp; (-(x))) // Persistent_BIT vector lt; pair lt; int , int gt; gt; bit 4100 4100 ; // Add val to cell (x , y) at time = time void update ( int x , int y , int val , int time ) for ( int u = x ; u lt;= 4096 ; u += _ ( u )) for ( int v = y ; v lt;= 4096 ; v += _ ( v )) if ( bit u v .\nempty ()) bit u v .\npush_back ( make_pair ( time , val )); else int cur = bit u v bit u v .\nsize () - 1 .\nsecond ; bit u v .\npush_back ( make_pair ( time , cur + val )); // Get the sum of_square (1 , 1) --gt; (x , y) at time = time int get ( int time , int x , int y ) int res = 0 ; for ( int u = x ; u gt; 0 ; u -= _ ( u )) for ( int v = y ; v gt; 0 ; v -= _ ( v )) if ( bit u v .\nempty ()) else if ( bit u v bit u v .\nsize () - 1 .\nfirst lt;= time ) res += bit u v bit u v .\nsize () - 1 .\nsecond ; else int pos = upper_bound ( bit u v .\nbegin () , bit u v .\nend () , make_pair ( time , 2000111000 )) - bit u v .\nbegin () - 1 ; if ( pos gt;= 0 ) res += bit u v pos .\nsecond ; return res ; Phân_tích : Độ phức_tạp cho mỗi thao_tác update không thay_đổi (ví dụ với BIT , vẫn là O(logN)) .\nNhưng độ phức_tạp cho mỗi thao_tác query bị tăng lên logN (ví dụ với BIT , độ phức_tạp cho mỗi thao_tác là O(log2(N)) thay_vì O(logN) .\nTuy_nhiên , cách cài_đặt này tổng_quát hơn , dễ_dàng được áp_dụng cho nhiều CTDL khác_nhau , ví_dụ cả BIT và IT .\n4 .\nRetroactive_Data_Structures_Một lớp CTDL khác tương_đối giống với Persistent_Data_Structures , nhưng có tính ứng_dụng thực_tế cao hơn_là Retroactive_Data_Structures : \"Retroactive Data_Structures là loại CTDL cho_phép thực_hiện thay_đổi với một dãy các thao_tác đã được thực_hiện trên dữ_liệu .\nVí_dụ : Thay_đổi một thao_tác đã được thực_hiện trong quá khứ\" .\nCả_Retroactive_Data_Structures amp; Persistent_Data_Structures đều quan_tâm đến trục thời_gian , tuy_nhiên điểm khác_nhau nằm ở chỗ cách xử_lý trục thời_gian của 2 CTDL này như_thế nào : Với_Persistent_Data_Structures , tất_cả các version được lưu lại , và bạn không_thể_nào thay_đổi một version trong quá_khứ (điều duy_nhất bạn có_thể làm là tạo ra một version mới từ 1 version cũ và thực_hiện thay_đổi trên version mới này) .\nVới_Retroactive_Data_Structures , bạn có_thể thực_hiện thay_đổi trên một version cũ .\nThay_đổi trên một version cũ này ảnh_hưởng đến tất_cả các version sau nó .\nSự khác_biệt về cách xử_lý trục thời_gian khiến cho Retroactive_Data_Structures có rất nhiều ứng_dụng trên thực_tế - trái_ngược hẳn với Persistent_Data_Structures chỉ thường được thấy ở trong các kỳ thi .\nMột_vài ứng_dụng quan_trọng của Retroactive_Data_Structures gồm có : Error_Correction : Giả_sử một dữ_liệu bị nhập sai , làm ảnh_hưởng đến tất_cả các thao_tác sau đấy .\nRetroactive_DS cho_phép sửa dữ_liệu nhập sai và ảnh_hưởng (tích cực) đến tất_cả các thao_tác sau_đó .\nBad data : Gần giống với Error_Correction , nhưng dữ_liệu sai bị xóa đi thay_vì được sửa_lại .\nRecovery : Giả_sử một lỗi của phần_cứng làm một_số dữ_liệu không được đọc .\nRetroactive_DS cho_phép đọc lại những dữ_liệu này và thay_đổi tất_cả các thao_tác được thực_hiện sau_đó .\nTrên thực_tế , Retroactive_Data_Structures còn đang dừng lại ở việc là một khái_niệm , chứ chưa có_một phương_pháp cài_đặt nào hiệu_quả .\nCác bạn nếu muốn tìm_hiểu có_thể nghiên_cứu thêm về cơ_chế rollback trong database hoặc tìm_kiếm thêm về Retroactive_Data_Structures .\nBài_tập áp_dụng SPOJ - COT_SPOJ - MKTHNUM_Codechef - QUERY_Codechef - SORTING_Codeforces - Round 140 Div 1 - E_Codeforces - Round 265 Div 1 - E_IPSC 2011 - Grid_Surveillance\n", "tagged": "Tác_giả/N :/CH Nguyễn_RR/Np Thành_Trung_Table/Np of_Contents/Np 1/M ./CH\nMở_đầu/V 2/M ./CH\nPersistent_IT/Np Tư_tưởng/N Cài_đặt/V :/CH Phân_tích/V 3/M ./CH\nPersistent_BIT/Np Tư_tưởng/N :/CH Cài_đặt/V :/CH Phân_tích/V :/CH 4/M ./CH\nRetroactive_Data_Structures/Np Bài_tập/Np áp_dụng/V 1/M ./CH\nMở_đầu/V Persistent_Data_Structures/Np là/V những/L cấu_trúc/N dữ_liệu/N được/V dùng/V khi/N chúng_ta/P cần/V có/V toàn_bộ/L lịch_sử/N của/E các/L thay_đổi/V trên/E 1/M cấu_trúc/N dữ_liệu/N (CTDL)/Np ./CH\n(Chú/Np ý/N rằng/C từ/E persistent/Np còn/R được/V dùng/V trong/E persistent/Np storage/Np với/E một/M nghĩa/N hoàn_toàn/A khác)/Np ./CH\nXét/V bài_toán/N ví_dụ/C :/CH Cho/E một/M dãy/Nc A/Ni gồm/V N/Ny phần_tử/N ./CH\nCó/V 2/M loại/N truy_vấn/Np :/CH Update/Np :/CH Gán/V A_i/Np =/CH v/Nu Query/Np :/CH Tìm/V max(A_i/Np ,/CH ./CH ./CH ./CH ,/CH A_j)/Np tại/E thời_điểm/N sau/E phép/N gán/V thứ/N K/N ./CH\nNếu_không/Np có/V đoạn/Nc tại/E thời_điểm/N sau/E phép/N gán/V thứ/N K/N ,/CH bài_toán/N là/V 1/M bài/N cơ_bản/A trên/E Interval_Tree/Np ./CH\nĐoạn/Nc tại/E thời_điểm/N sau/E phép/N gán/V thứ/N K/N buộc/V chúng_ta/P phải/V lưu/V lại/R các/L thông_tin/N về/E lịch_sử/N cập_nhật_CTDL/Np -/CH việc/N này/P được/V giải_quyết/V bằng/E các/L Persistent_Data_Structures/Np ./CH\nGọi/V trạng_thái/N của/E CTDL/Np tại/E một_thời/Np điểm/N là/V 1/M version/Np của/E CTDL/Np đó/P ./CH\nMột_cách/N cụ_thể/A hơn/A ,/CH persistent/Np data/Np structures/Np cho_phép/V chúng_ta/P :/CH Truy_vấn/Np trên/E một/M version/Np cũ/A của/E CTDL/Np Cập_nhật/V dữ_liệu/N trong/E version/Np mới/R nhất/A của/E CTDL/Np ,/CH bằng/E cách/N tạo/V thêm/V 1/M version/Np mới/R của/E CTDL/Np ./CH\nTrong/E một_số/L cách/N cài_đặt/V ,/CH Persistent_Data_Structures/Np còn/R có_thể/R cho_phép/V thay/V version/Np hiện_tại/N của/E CTDL/Np thành/V một/M version/Np trong/E quá_khứ/N (phần/Np 2/M mô_tả/V phương_pháp/N cài_đặt/V có_thể/R thực_hiện/V được/V thao_tác/V này)/Np ./CH\nCần/V hiểu/V rằng/C Persistent_Data_Structures/Np không_phải/Np là/V một/M loại/N CTDL/Np mới/R ./CH\nNó/P là/V một_số/L kĩ_năng/N tổng_quát/Np giúp/V thêm/V thông_tin/N về/E lịch_sử/N thay_đổi/V vào/E CTDL/Np thông_thường/A một_cách/N hiệu_quả/N ./CH\nVí_dụ/C :/CH IT/Np +/CH Persistent/Np --gt;/Np Persistent_IT_BIT/Np +/CH Persistent/Np --gt;/Np Persistent_BIT/Np Tại_sao/X lại/R là/V một_cách/N hiệu_quả/N ?/CH\nBởi_vì/E ta/P hoàn_toàn/A có_thể/R có_một/Np Persistent_Data_Structures/Np bằng/E cách/N trâu_bò/N :/CH khi/N cập_nhật/V ,/CH ta/P tạo/V một/M bản_sao/N hoàn_toàn/A mới/R của/E CTDL/Np ,/CH thay_đổi/V một_số/L dữ_liệu/N trên/E nó/P và/Cc lưu/V lại/R ./CH\nNhư_vậy/X ta/P luôn/R có/V được/V một/M thuật_toán/N với/E độ/N phức_tạp/A O(Q_N_T)/Np và/Cc bộ_nhớ/Np O(Q_N)/Np ,/CH với/E Q/Ny là/V số/N thao_tác/V cần/V thực_hiện/V ,/CH và/Cc N/Ny là/V độ/N lớn/A của/E CTDL/Np ,/CH và/Cc T/Nu là/V thời_gian/N để/E thực_hiện/V thao_tác/V trên/E CTDL/Np ./CH\nTrong/E các/L phần/N dưới_đây/Np ,/CH mình/P sẽ/R trình_bày/V về/E 2/M kĩ_thuật/N thông_thường/A của/E Persistent_Data_Structures/Np ./CH\n2/M ./CH\nPersistent_IT/Np Tư_tưởng/N Quay/V trở_lại/V bài_toán/N ./CH\nChúng_ta/P biết/V rằng/C mỗi/L thao_tác/V update/Np trên/E IT/Np chỉ/R mất/V O(logN)/Np ./CH\nĐiều/N này/P tương_đương/A với/E việc/N mỗi/L thao_tác/V update/Np chỉ/R làm/V thay_đổi/V O(logN)/Np nút/N trên/E cây/N ./CH\nNhư_vậy/X ta/P hoàn_toàn/A có_thể/R lưu/V lại/R tất_cả/P các/L thay_đổi/V trên/E tất_cả/P các/L nút/N trong/E O(QlogN)/Np ./CH\nTừ_đó/Np ,/CH ta/P rút/V ra/V được/V một/M tư_tưởng/N cài_đặt/V thuật_toán/N :/CH Với/E mỗi/L thao_tác/V Update/Np ,/CH ta/P tạo/V thêm/V một_số/L nút/N mới/R trên/E IT/Np ./CH\nĐể_không/Np phải/V sinh/V thêm/V các/L nút/N không/R bị/V thay_đổi/V ,/CH một/M nút/N ở/E version/Np mới/R có_thể/R có_con/Np là/V một/M nút/N ở/E vesion/Np cũ/A ./CH\nChú_ý/V :/CH Mỗi/L thao_tác/V Update/Np luôn/R thay_đổi/V một/M đường_đi/Np từ/E gốc/N đến/E một/M nút/N lá/N ,/CH nên/C không/R có/V trường_hợp/N một/M nút/N ở/E version/Np cũ/A có_con/Np là/V một/M nút/N ở/E version/Np mới/R hơn/A ./CH\n(Nếu/Np thao_tác/V Update/Np là/V Update/Np 1/M đoạn/Nc ,/CH các/L nút/N bị/V thay_đổi/V không/R còn/R là/V một/M đường_đi/Np nữa/R ,/CH nhưng/C nhận_xét/N này/P vẫn/R đúng)/Np ./CH\nKhi/N thực_hiện/V thao_tác/V Query/Np trên/E version/Np t/Nu ,/CH ta/P chỉ_cần/Np thực_hiện/V Query/Np trên/E nút/N gốc/N ở/E version/Np t/Nu ./CH\nTư_tưởng/N này/P còn/R được/V gọi_là/V Path_Copy/Np trong/E các/L tài_liệu/N tiếng/N Anh/N ./CH\nCài_đặt/V :/CH struct/Np Node/Np int/Np left/Np ,/CH right/Np ;/CH //CH ID/Np of/E left/Np child/Np amp;/Np right/Np child/Np long_long/Np ln/Np ;/CH //CH Max/Np value/Np of/E node/Np Node/Np ()/Np Node/Np (/CH long_long/Np ln/Np ,/CH int/Np left/Np ,/CH int/Np right/Np )/CH :/CH ln/Np (/CH ln/Np )/CH ,/CH left/Np (/CH left/Np )/CH ,/CH right/Np (/CH right/Np )/CH it/Np 11000111/Np ;/CH //CH Each/Np node/Np has/Np a/Ni position/Np in/V this/Np array/Np ,/CH called/Np ID/Np int/Np nNode/Np ;/CH int/Np ver/Np MN/Np ;/CH //CH ID/Np of/E root/Np in/V each/Np version/Np //CH Update/Np max/Np value/Np of/E a/Ni node/Np inline/Np void/Np refine/Np (/CH int/Np cur/Np )/CH it/Np cur/Np ./CH\nln/Np =/CH max/Np (/CH it/Np it/Np cur/Np ./CH\nleft/Np ./CH\nln/Np ,/CH it/Np it/Np cur/Np ./CH\nright/Np ./CH\nln/Np );/CH //CH Update/Np a/Ni range/Np ,/CH and/Np return/Np new/Np ID/Np of/E node/Np int/Np update/Np (/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np x/CH ,/CH int/Np oldId/Np )/CH if/Np (/CH l/Ny ==/Np r/Np )/CH ++/Np nNode/Np ;/CH it/Np nNode/Np =/CH Node/Np (/CH x/CH ,/CH 0/M ,/CH 0/M );/CH return/Np nNode/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH gt;gt;/Np 1/M ;/CH int/Np cur/Np =/CH ++/Np nNode/Np ;/CH if/Np (/CH u/N lt;=/Np mid/Np )/CH it/Np cur/Np ./CH\nleft/Np =/CH update/Np (/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH x/CH ,/CH it/Np oldId/Np ./CH\nleft/Np );/CH it/Np cur/Np ./CH\nright/Np =/CH it/Np oldId/Np ./CH\nright/Np ;/CH refine/Np (/CH cur/Np );/CH else/Np it/Np cur/Np ./CH\nleft/Np =/CH it/Np oldId/Np ./CH\nleft/Np ;/CH it/Np cur/Np ./CH\nright/Np =/CH update/Np (/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH x/CH ,/CH it/Np oldId/Np ./CH\nright/Np );/CH refine/Np (/CH cur/Np );/CH return/Np cur/Np ;/CH //CH Get/Np max/Np of/E range/Np ./CH\nSame/Np as/Np usual/Np IT/Np int/Np get/Np (/CH int/Np nodeId/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH return/Np -/CH 1/M ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH return/Np it/Np nodeId/Np ./CH\nln/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH gt;gt;/Np 1/M ;/CH return/Np max/Np (/CH get/Np (/CH it/Np nodeId/Np ./CH\nleft/Np ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu )/CH ,/CH get/Np (/CH it/Np nodeId/Np ./CH\nright/Np ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu ));/Np //CH When/Np update/Np :/CH ++/Np nVer/Np ;/CH ver/Np nVer/Np =/CH update/Np (/CH 1/M ,/CH n/Ny ,/CH u/N ,/CH x/CH ,/CH ver/Np nVer/Np -/CH 1/M );/CH //CH When/Np query/Np :/CH res/Np =/CH get/Np (/CH ver/Np t/Nu ,/CH 1/M ,/CH n/Ny ,/CH u/N ,/CH v/Nu );/CH Giải_thích/V :/CH Ban_đầu/N ,/CH ta/P có_một/Np mảng/N it/Np ,/CH lưu/V tất_cả/P các/L nút/N sẽ/R được/V sinh_ra/V của/E IT/Np ./CH\nMỗi/L nút/N gồm/V có/V Chỉ_số/N của/E con/Nc trái/Nc ,/CH index/Np của/E con/Nc phải/V (2/Np biến/V left/Np và/Cc right/Np )/CH Giá_trị/N lớn/A nhất/A của/E các/L số/N trong_khoảng/Np mà/C nút/N quản_lý/V (ở/Np version/Np khi/N nút/N đó/P được/V tạo/V ra)/Np :/CH biến/V ln/Np Ta/P lưu/V thêm/V chỉ_số/N của/E các/L nút/N gốc/N ở/E các/L version/Np khác_nhau/Np vào/E một/M mảng/N ver/Np Hàm/Np update/Np :/CH Tạo/V ra/V các/L nút/N mới/R ,/CH và/Cc trỏ/Np đến/E các/L con_ở/Np version/Np cũ/A hoặc/Cc version/Np mới/R ,/CH tùy_theo/Np các/L con/Nc có/V bị/V thay_đổi/V hay_không/Np Trả_lại/Np index/Np của/E nút/N mới/R được/V tạo/V Hàm_get/Np :/CH Trả_lại/Np max/Np của/E một/M đoạn/Nc được/V quản_lý/V bởi/E nút/N nodeId/Np Phân_tích/V Cách/N cài_đặt/V Persistent_Data_Structures/Np trong/E mục/N này/P rất/R hiệu_quả/N ./CH\nNó/P hoàn_toàn/A không/R làm/V tăng/V thêm/V độ/N phức_tạp/A (persistent/Np IT/Np có/V độ/N phức_tạp/A mỗi/L thao_tác/V là/V O(logN))/Np ,/CH và/Cc bộ_nhớ/Np cần/V thêm/V là/V tối_ưu/A :/CH O(Q/Np logN)/Np ./CH\nTuy_nhiên/C ,/CH cách/N cài_đặt/V này/P không/R dễ/A áp_dụng/V với/E những/L CTDL/Np khác/A ./CH\nChẳng_hạn/X sẽ/R rất/R khó/A để/E cài/V đúng/A BIT/Np với/E phương_pháp/N này/P ./CH\nỞ/E mục/N tiếp_theo/V ,/CH mình/P sẽ/R trình_bày/V một/M phương_pháp/N cài_đặt/V khác/A có_thể/R dùng/V cho/E BIT/Np ,/CH tuy_nhiên/C có/V độ/N phức_tạp/A lớn/A hơn/A ./CH\n3/M ./CH\nPersistent_BIT/Np Tư_tưởng/N :/CH Tại/E mỗi/L nút/N của/E BIT/Np ,/CH thay_vì/X lưu/V một/M giá_trị/N ,/CH ta/P lưu/V lại/R tất_cả/P các/L cặp/N (version/Np ,/CH giá/N trị)/Np ở/E nút/N đó/P ./CH\nThao_tác/V update/Np rất/R đơn_giản/A :/CH chỉ_cần/Np thêm/V một/M cặp/N (version/Np ,/CH giá/N trị)/Np vào/E các/L nút/N tương_ứng/V ./CH\nVới/E thao_tác/V query/Np tại/E version/Np t/Nu ,/CH trên/E một/M nút/N ,/CH ta/P cần/V tìm/V cặp/N (version/Np ,/CH giá/N trị)/Np mới/R nhất/A vào/E trước/E thời_điểm/N t/Nu -/CH việc/N tìm_kiếm/V này/P có_thể/R được/V thực_hiện/V bằng/E tìm_kiếm/V nhị_phân/Np ./CH\nCách/N cài_đặt/V này/P được/V gọi_là/V Fat_Node/Np trong/E các/L tài_liệu/N tiếng/N Anh/N ./CH\nCài_đặt/V :/CH Code_BIT/Np trích/V từ/E bài/N IPSC/Np 2011/M -/CH Grid_Surveillance/Np :/CH define/Np _(x)/Np (x/Np amp;/Np (-(x)))/Np //CH Persistent_BIT/Np vector/Np lt;/Np pair/Np lt;/Np int/Np ,/CH int/Np gt;/Np gt;/Np bit/Np 4100/Np 4100/Np ;/CH //CH Add/Np val/Np to/A cell/Np (x/Np ,/CH y)/Np at/Np time/Np =/CH time/Np void/Np update/Np (/CH int/Np x/CH ,/CH int/Np y/N ,/CH int/Np val/Np ,/CH int/Np time/Np )/CH for/Np (/CH int/Np u/N =/CH x/CH ;/CH u/N lt;=/Np 4096/Np ;/CH u/N +=/Np _/Np (/CH u/N ))/Np for/Np (/CH int/Np v/Nu =/CH y/N ;/CH v/Nu lt;=/Np 4096/Np ;/CH v/Nu +=/Np _/Np (/CH v/Nu ))/Np if/Np (/CH bit/Np u/N v/Nu ./CH\nempty/Np ())/Np bit/Np u/N v/Nu ./CH\npush_back/Np (/CH make_pair/Np (/CH time/Np ,/CH val/Np ));/Np else/Np int/Np cur/Np =/CH bit/Np u/N v/Nu bit/Np u/N v/Nu ./CH\nsize/Nb ()/Np -/CH 1/M ./CH\nsecond/Np ;/CH bit/Np u/N v/Nu ./CH\npush_back/Np (/CH make_pair/Np (/CH time/Np ,/CH cur/Np +/CH val/Np ));/Np //CH Get/Np the/B sum/Np of_square/Np (1/Np ,/CH 1)/Np --gt;/Np (x/Np ,/CH y)/Np at/Np time/Np =/CH time/Np int/Np get/Np (/CH int/Np time/Np ,/CH int/Np x/CH ,/CH int/Np y/N )/CH int/Np res/Np =/CH 0/M ;/CH for/Np (/CH int/Np u/N =/CH x/CH ;/CH u/N gt;/Np 0/M ;/CH u/N -=/Np _/Np (/CH u/N ))/Np for/Np (/CH int/Np v/Nu =/CH y/N ;/CH v/Nu gt;/Np 0/M ;/CH v/Nu -=/Np _/Np (/CH v/Nu ))/Np if/Np (/CH bit/Np u/N v/Nu ./CH\nempty/Np ())/Np else/Np if/Np (/CH bit/Np u/N v/Nu bit/Np u/N v/Nu ./CH\nsize/Nb ()/Np -/CH 1/M ./CH\nfirst/Np lt;=/Np time/Np )/CH res/Np +=/Np bit/Np u/N v/Nu bit/Np u/N v/Nu ./CH\nsize/Nb ()/Np -/CH 1/M ./CH\nsecond/Np ;/CH else/Np int/Np pos/Np =/CH upper_bound/Np (/CH bit/Np u/N v/Nu ./CH\nbegin/Np ()/Np ,/CH bit/Np u/N v/Nu ./CH\nend/Np ()/Np ,/CH make_pair/Np (/CH time/Np ,/CH 2000111000/Np ))/Np -/CH bit/Np u/N v/Nu ./CH\nbegin/Np ()/Np -/CH 1/M ;/CH if/Np (/CH pos/Np gt;=/Np 0/M )/CH res/Np +=/Np bit/Np u/N v/Nu pos/Np ./CH\nsecond/Np ;/CH return/Np res/Np ;/CH Phân_tích/V :/CH Độ/N phức_tạp/A cho/E mỗi/L thao_tác/V update/Np không/R thay_đổi/V (ví/Np dụ/V với/E BIT/Np ,/CH vẫn/R là/V O(logN))/Np ./CH\nNhưng/C độ/N phức_tạp/A cho/E mỗi/L thao_tác/V query/Np bị/V tăng/V lên/V logN/Np (ví/Np dụ/V với/E BIT/Np ,/CH độ/N phức_tạp/A cho/E mỗi/L thao_tác/V là/V O(log2(N))/Np thay_vì/X O(logN)/Np ./CH\nTuy_nhiên/C ,/CH cách/N cài_đặt/V này/P tổng_quát/Np hơn/A ,/CH dễ_dàng/A được/V áp_dụng/V cho/E nhiều/A CTDL/Np khác_nhau/Np ,/CH ví_dụ/C cả/P BIT/Np và/Cc IT/Np ./CH\n4/M ./CH\nRetroactive_Data_Structures_Một/Np lớp/N CTDL/Np khác/A tương_đối/A giống/N với/E Persistent_Data_Structures/Np ,/CH nhưng/C có/V tính/V ứng_dụng/V thực_tế/N cao/A hơn_là/Np Retroactive_Data_Structures/Np :/CH \"Retroactive/Np Data_Structures/Np là/V loại/N CTDL/Np cho_phép/V thực_hiện/V thay_đổi/V với/E một/M dãy/Nc các/L thao_tác/V đã/R được/V thực_hiện/V trên/E dữ_liệu/N ./CH\nVí_dụ/C :/CH Thay_đổi/V một/M thao_tác/V đã/R được/V thực_hiện/V trong/E quá/R khứ\"/Np ./CH\nCả_Retroactive_Data_Structures/Np amp;/Np Persistent_Data_Structures/Np đều/R quan_tâm/V đến/E trục/N thời_gian/N ,/CH tuy_nhiên/C điểm/N khác_nhau/Np nằm/V ở/E chỗ/N cách/N xử_lý/V trục/N thời_gian/N của/E 2/M CTDL/Np này/P như_thế/X nào/P :/CH Với_Persistent_Data_Structures/Np ,/CH tất_cả/P các/L version/Np được/V lưu/V lại/R ,/CH và/Cc bạn/N không_thể_nào/R thay_đổi/V một/M version/Np trong/E quá_khứ/N (điều/Np duy_nhất/A bạn/N có_thể/R làm/V là/V tạo/V ra/V một/M version/Np mới/R từ/E 1/M version/Np cũ/A và/Cc thực_hiện/V thay_đổi/V trên/E version/Np mới/R này)/Np ./CH\nVới_Retroactive_Data_Structures/Np ,/CH bạn/N có_thể/R thực_hiện/V thay_đổi/V trên/E một/M version/Np cũ/A ./CH\nThay_đổi/V trên/E một/M version/Np cũ/A này/P ảnh_hưởng/V đến/E tất_cả/P các/L version/Np sau/E nó/P ./CH\nSự/N khác_biệt/A về/E cách/N xử_lý/V trục/N thời_gian/N khiến/V cho/E Retroactive_Data_Structures/Np có/V rất/R nhiều/A ứng_dụng/V trên/E thực_tế/N -/CH trái_ngược/Np hẳn/R với/E Persistent_Data_Structures/Np chỉ/R thường/R được/V thấy/V ở/E trong/E các/L kỳ/N thi/V ./CH\nMột_vài/L ứng_dụng/V quan_trọng/A của/E Retroactive_Data_Structures/Np gồm/V có/V :/CH Error_Correction/Np :/CH Giả_sử/Np một/M dữ_liệu/N bị/V nhập/V sai/A ,/CH làm/V ảnh_hưởng/V đến/E tất_cả/P các/L thao_tác/V sau/E đấy/P ./CH\nRetroactive_DS/Np cho_phép/V sửa/V dữ_liệu/N nhập/V sai/A và/Cc ảnh_hưởng/V (tích/Np cực)/Np đến/E tất_cả/P các/L thao_tác/V sau_đó/Np ./CH\nBad/Np data/Np :/CH Gần/A giống/N với/E Error_Correction/Np ,/CH nhưng/C dữ_liệu/N sai/A bị/V xóa/V đi/V thay_vì/X được/V sửa_lại/Np ./CH\nRecovery/Np :/CH Giả_sử/Np một/M lỗi/N của/E phần_cứng/Np làm/V một_số/L dữ_liệu/N không/R được/V đọc/V ./CH\nRetroactive_DS/Np cho_phép/V đọc/V lại/R những/L dữ_liệu/N này/P và/Cc thay_đổi/V tất_cả/P các/L thao_tác/V được/V thực_hiện/V sau_đó/Np ./CH\nTrên/E thực_tế/N ,/CH Retroactive_Data_Structures/Np còn/R đang/R dừng/V lại/R ở/E việc/N là/V một/M khái_niệm/N ,/CH chứ/C chưa/R có_một/Np phương_pháp/N cài_đặt/V nào/P hiệu_quả/N ./CH\nCác/L bạn/N nếu/C muốn/V tìm_hiểu/V có_thể/R nghiên_cứu/V thêm/V về/E cơ_chế/N rollback/Np trong/E database/Np hoặc/Cc tìm_kiếm/V thêm/V về/E Retroactive_Data_Structures/Np ./CH\nBài_tập/Np áp_dụng/V SPOJ/Np -/CH COT_SPOJ/Np -/CH MKTHNUM_Codechef/Np -/CH QUERY_Codechef/Np -/CH SORTING_Codeforces/Np -/CH Round/Np 140/M Div/Np 1/M -/CH E_Codeforces/Np -/CH Round/Np 265/Np Div/Np 1/M -/CH E_IPSC/Np 2011/M -/CH Grid_Surveillance/Np\n", "title": "Persistent Data Structures\n", "link": "http://vnoi.info/wiki/algo/data-structures/persistent-data-structures\n"}