{"content": "Table of_Contents 1 .\nCTDL Lưu_trữ 1 . 1 . Mảng (array) , danh_sách liên_kết (linked list) 1 . 2 . Stack , Queue , Deque 1 . 2 . 1 . Stack 1 . 2 . 2 . Queue 1 . 2 . 3 . Deque 1 . 3 . Priority_Queue - Heap 1 . 4 . Cây Tìm_Kiếm Nhị_Phân 1 . 5 . Bảng_băm (Hash Tables) 2 .\nCTDL Truy_vấn 2 . 1 . Mảng cộng_dồn (Prefix Sum) 2 . 1 . 1 . Mảng cộng_dồn - Tìm tổng một đoạn liên_tiếp 2 . 1 . 2 . Mảng cộng_dồn - Tăng_giá_trị các đoạn 2 . 1 . 3 . Mảng cộng_dồn trên bảng 2 chiều 2 . 2 . Disjoint_Sets 2 . 3 . Sparse_Table 2 . 4 . Segment_Tree 2 . 5 . Fenwick 2 . 6 . Heavy-light decomposition 2 . 7 . Persistent_Data_Structures 3 .\nCTDL xâu 3 . 1 . Cây Tiền_Tố (Trie) 3 . 2 . Aho_Corasick 3 . 3 . Mảng Hậu_Tố (Suffix Array) 3 . 4 . Suffix_Automaton 3 . 5 . Palindrome_Tree_Các tài_liệu tham_khảo : Mặc_dù máy_tính đã có_thể xử_lý hàng_triệu phép_tính mỗi giây , nhưng khi một bài_toán trở phức_tạp , cách tổ_chức dữ_liệu vẫn vô_cùng quan_trọng .\nĐể minh_họa điểm này , hãy tham_khảo ví_dụ sau : bạn đi đến thư_viện , thử tìm_kiếm một quyển sách với chủ_đề nào_đó .\nCác cuốn sách được xếp theo lĩnh_vực .\nTrong mỗi chủ_đề , sách lại được xếp theo tên tác_giả , nhờ vậy_mà việc lấy và cất sách từ giá trở_nên khá dễ_dàng và đơn_giản .\nBây_giờ , hãy thử tưởng_tượng thay_vì tổ_chức thành từng giá_sách cụ_thể , sách được chất thành từng đống ở khắp thư_viện .\nĐể tìm được quyển sách của mình , bạn sẽ phải mất hàng giờ , thậm_chí rất nhiều ngày .\nTương_tự , một phần_mềm không_thể vận_hành hiệu_quả khi dữ_liệu không được lưu_trữ một_cách phù_hợp với ứng_dụng .\nTrong bài viết này , chúng_ta sẽ cùng_nhau điểm qua các loại cấu_trúc dữ_liệu từ cơ_bản đến nâng_cao .\nĐể tìm_hiểu chi_tiết về một cấu_trúc dữ_liệu , các bạn có_thể đọc ở link tương_ứng .\nTrong bài viết này , mình tạm chia các CTDL được chia thành các loại sau : CTDL lưu_trữ : thường có các thao_tác như thêm 1 phần_tử , xóa 1 phần_tử .\nCó_thể có thêm các thao_tác như tìm_kiếm 1 phần_tử .\nCTDL truy_vấn : thường_dùng cho các bài_toán mà bạn phải duy_trì một_tập hợp các số và thực_hiện 1 số truy_vấn trên đó .\nCTDL xâu : dùng cho các bài_tập xử_lý xâu .\n1 .\nCTDL Lưu_trữ 1 . 1 . Mảng (array) , danh_sách liên_kết (linked list) Mảng và danh_sách liên_kết là 2 cấu_trúc dữ_liệu nền_tảng cho tất_cả các loại cấu_trúc dữ_liệu khác .\nMảng và danh_sách liên_kết đều được dùng khi bạn muốn lưu nhiều dữ_liệu (thường có cùng kiểu dữ liệu) .\nBảng dưới_đây so_sánh các thao_tác về mảng và danh_sách liên_kết : Mảng Danh_sách liên_kết Bộ_nhớ Cố_định (cần biết trước_số phần tử) Có_thể tăng_giảm tùy_ý Thêm/Xóa 1 phần_tử \\mathcalO(N) \\mathcalO(1) , giả_sử biết con_trỏ tới phần_tử đó Tìm_kiếm 1 phần_tử \\mathcalO(N) \\mathcalO(N) Truy_cập phần_tử \\mathcalO(1) \\mathcalO(N) Khác - Ít bộ_nhớ hơn - Cache locality : các phần_tử ở vị_trí gần nhau trên bộ_nhớ máy_tính , nên khi truy_cập các phần_tử liên_tiếp sẽ nhanh hơn Bạn có_thể đọc thêm về mảng và danh_sách liên_kết ở đây 1 . 2 . Stack , Queue , Deque 1 . 2 . 1 . Stack_Stack là CTDL cho_phép thực_hiện các thao_tác : Thêm 1 phần_tử vào cuối CTDL_Xóa 1 phần_tử khỏi cuối CTDL_Cả 2 thao_tác trên đều có độ phức_tạp \\mathcalO(1) .\nChú_ý ta chỉ_có thể xóa phần_tử ở cuối CTDL , nói_cách_khác là phần_tử mà mới được thêm vào gần nhất .\nVì_vậy , Stack còn được gọi_là FIFO (First In_First_Out) .\nStack có cài_đặt đơn_giản và được sử_dụng trong nhiều thuật_toán như DFS , tìm chu_trình Euler , tìm khớp của đồ_thị .\nTrong_C++_STL , có_sẵn kiểu dữ_liệu stack .\n1 . 2 . 2 . Queue_Queue là CTDL cho_phép thực_hiện các thao_tác : Thêm 1 phần_tử vào cuối CTDL_Xóa 1 phần_tử khỏi đầu CTDL .\nCả 2 thao_tác đều có độ phức_tạp \\mathcalO(1) .\nChú_ý ta chỉ_có thể xóa phần_tử ở đầu CTDL , nói_cách_khác là phần_tử mà đã được thêm vào lâu nhất .\nVì_vậy , Stack còn được gọi_là LIFO (Last In_First_Out) .\nQueue có cài_đặt đơn_giản và được sử_dụng trong BFS .\nTrong_C++_STL , có_sẵn kiểu dữ_liệu queue .\n1 . 2 . 3 . Deque_Deque (Double Ended_Queue) , là CTDL tổng_quát hơn của Stack và Queue .\nNó cho_phép : Thêm 1 phần_tử vào đầu hoặc cuối CTDL .\nXóa 1 phần_tử khỏi đầu hoặc cuối CTDL .\nCả 2 thao_tác đều có độ phức_tạp \\mathcalO(1) .\nDeque được sử_dụng trong một_số thuật_toán như : BFS 01 Tìm_Min/Max trên đoạn tịnh_tiến .\nTrong_C++_STL , có_sẵn kiểu dữ_liệu deque .\n1 . 3 . Priority_Queue - Heap_Heap là một cấu_trúc dữ_liệu cho_phép thực_hiện các thao_tác : Thêm một phần_tử , với độ phức_tạp \\mathcalO(\\logN) .\nXóa_một phần_tử , với độ phức_tạp \\mathcalO(\\logN) .\nTìm max của các phần_tử , với độ phức_tạp \\mathcalO(1) .\nBạn có_thể đọc thêm về Heap ở đây Fibonacci_Heap là một dạng heap có độ phức_tạp bé hơn .\nTrong_C++ , CTDL priority_queue được cài_đặt bằng Fibonacci_Heap .\n1 . 4 . Cây Tìm_Kiếm Nhị_Phân Cây Tìm_Kiếm Nhị_Phân ( BST_Binary_Search_Tree ) là một cây nhị_phân có tính_chất : Với mỗi giá_trị trên đỉnh_đang xét , giá_trị của mọi đỉnh trên cây_con trái luôn nhỏ hơn đỉnh_đang xét và giá_trị của mọi đỉnh trên cây_con phải luôn lớn hơn đỉnh_đang xét .\nCây tìm_kiếm nhị_phân cho_phép thực_hiện các thao_tác : Thêm 1 phần_tử .\nXóa 1 phần_tử .\nKiểm_tra 1 phần_tử có tồn_tại hay_không .\nTìm phần_tử đầu_tiên lớn hơn hoặc bằng 1 giá_trị x cho trước .\nTrong trường_hợp dữ_liệu ngẫu_nhiên , các thao_tác trên có độ phức_tạp trung_bình là \\mathcalO(\\logN) .\nTuy_nhiên trong trường_hợp xấu nhất , cây tìm_kiếm nhị_phân bị suy_biến (thành 1 \"đường thẳng\" ) , thì độ phức_tạp mỗi thao_tác là \\mathcalO(N) .\nĐể khắc_phục điều này , có rất nhiều CTDL cải_tiến từ cây tìm_kiếm nhị_phân , thường được gọi_là các cây nhị_phân cân_bằng .\nKhi đó , các thao_tác trên có_thể được thực_hiện với độ phức_tạp \\mathcalO(\\logN) .\nVí_dụ : Cây_Đỏ Đen (Red-Black Tree) là một dạng cây tìm_kiếm nhị_phân ( BST ) mà sau mỗi truy_vấn được thực_hiện , cây tự cân_bằng theo đúng tính_chất của nó với độ phức_tạp O(log(N)) .\nCTDL set trong C++ được cài_đặt bằng cây_đỏ đen .\nSplay tree , Skip list , Treap thường được dùng trong các kỳ thi bởi cài_đặt đơn_giản .\n1 . 5 . Bảng_băm (Hash Tables) Bảng_băm là một CTDL thường được sử_dụng như một từ_điển : mỗi phần_tử trong bảng_băm là một cặp (khóa , giá trị) .\nNếu so_sánh với mảng , khóa được xem như chỉ_số của mảng , còn giá_trị giống_như giá_trị mà ta lưu tại chỉ_số tương_ứng .\nBảng_băm không như các loại_từ điển thông_thường - ta có_thể tìm được_giá trị thông_qua khóa của nó .\nBảng_băm hoạt_động dựa trên hàm Hash : Hash là quá_trình khởi tạo một giá_trị khóa (thường là 32 bit hoặc 64 bit) từ một phần dữ_liệu .\nNó có_thể là n bit đầu_tiên của dữ_liệu , n bit cuối_cùng , giá_trị mod cho một_số nguyên_tố nào_đó .\nDựa theo giá_trị hash , dữ_liệu được chia vào các bucket : Trong trường_hợp hàm Hash hoạt_động tốt , mỗi bucket có rất ít phần_tử , độ phức_tạp của các thao_tác trên Hash table như_sau : Tìm 1 khóa : \\mathcalO(1) .\nThêm / xóa 1 khóa : \\mathcalO(1) .\nBạn có_thể đọc thêm về Hash table ở đây 2 .\nCTDL Truy_vấn 2 . 1 . Mảng cộng_dồn (Prefix Sum)_Mảng cộng_dồn là một_cách áp_dụng khéo_léo mảng .\nCó 2 dạng bài cơ_bản có_thể giải được bằng cách áp_dụng Prefix_Sum .\n2 . 1 . 1 . Mảng cộng_dồn - Tìm tổng một đoạn liên_tiếp Ví_dụ Cho một mảng a_1 , a_2 , a_3 , . . . , a_N .\nCần trả_lời nhiều truy_vấn , mỗi truy_vấn cho 2 số L và R , yêu_cầu in ra tổng a_L + a_L+1 + . . .\n+ a_R .\nCách làm Tạo một mảng S , với S_i = a_1 + a_2 + . . .\n+ a_i .\nMảng_S được gọi_là mảng cộng_dồn Với mỗi truy_vấn , in ra : S_R – S_L-1 .\n2 . 1 . 2 . Mảng cộng_dồn - Tăng_giá_trị các đoạn Ví_dụ Cho mảng a_1 , a_2 , . . . , a_N .\nCần thực_hiện nhiều truy_vấn , mỗi truy_vấn cho 3 số L , R , V .\nYêu_cầu : với mỗi i (L \\le i \\le R) , cộng V vào a_i .\nTính mảng a sau khi thực_hiện tất_cả các truy_vấn .\nCách làm Tạo một mảng P : p_1 , p_2 , . . . , p_N Khởi tạo p_i = 0 .\nVới mỗi truy_vấn , tăng p_L lên V và trừ p_R+1 đi V .\nCuối_cùng , với mỗi i (từ 1) , p_i += p_i–1 .\nTa có a_i = a_i + p_i .\n2 . 1 . 3 . Mảng cộng_dồn trên bảng 2 chiều Trên bảng 2 chiều A(i , j) , ta đặt f(i , j) là tổng_các ô trong hình_chữ_nhật có 2 đỉnh đối_diện là (1 , 1) và (i , j) .\nKhi đó , ta có : f(i , j) = f(i-1 , j) + f(i , j-1) - f(i-1 , j-1) + A(i , j) .\nGiải_thích công_thức trên : đỏ = xanh_da_trời + vàng - tím + xanh lá f(i , j) = f(i-1 , j) + f(i , j-1) - f(i-1 , j-1) + A(i , j) 2 . 2 . Disjoint_Sets_Disjoint_Sets là cấu_trúc dữ_liệu được sử_dụng trong thuật_toán Kruskal và thuật_toán Prim - 2 thuật_toán tìm cây khung nhỏ nhất của đồ_thị .\nNhư tên_gọi của nó , Disjoint_Set được dùng để quản_lý các tập_hợp không giao nhau .\nBài_toán Cho đồ_thị có N đỉnh .\nTa cần thực_hiện 2 loại truy_vấn : Nối 2 đỉnh i và j Kiểm_tra 2 đỉnh i và j có thuộc cùng thành_phần liên_thông hay_không .\nDisjoint set cho_phép ta thực_hiện 2 thao_tác trên với độ phức_tạp \\mathcalO(\\logN) .\nBạn có_thể đọc thêm về Disjoint_Set ở bài viết này .\n2 . 3 . Sparse_Table_Sparse_Table là cấu_trúc dữ_liệu được sử_dụng trong bài_toán LCA amp; RMQ .\nVới cả 2 bài_toán , Sparse_Table cho_phép : Khởi tạo với độ phức_tạp : \\mathcalO(N \\logN) .\nTrả_lời truy_vấn với độ phức_tạp \\mathcalO(1) .\n2 . 4 . Segment_Tree_Segment_Tree , còn được gọi_là Interval_Tree trong nhiều tài_liệu tiếng Việt , là cấu_trúc dữ_liệu cho_phép thực_hiện các truy_vấn trên một dãy_số .\nSegment_Tree rất linh_động và có_thể áp_dụng với nhiều loại truy_vấn khác_nhau , nên nó xuất_hiện rất nhiều trong các kỳ thi .\nVới dãy_số độ_dài N , Segment_Tree cho_phép thực_hiện các thao_tác với độ phức_tạp \\mathcalO(\\logN) .\nBạn có_thể đọc thêm về Segment_Tree ở đây .\nSegment_Tree cũng có_một mở_rộng với nhiều ứng_dụng quan_trọng là Segment_Tree trên tập đoạn_thẳng .\n2 . 5 . Fenwick_Cũng giống_như Segment_Tree , Fenwick tree (còn được gọi_là Binary_Indexed_Tree) là cấu_trúc dữ_liệu cho_phép thực_hiện các truy_vấn trên một dãy_số : Ưu_điểm : Độ phức_tạp mỗi thao_tác cũng là \\mathcalO(\\logN) .\nHằng_số tự_nhiên thấp hơn Segment_Tree , nên chạy nhanh hơn .\nDùng ít bộ_nhớ hơn .\nDễ cài_đặt hơn Segment_Tree Nhược_điểm : Không tổng_quát bằng Segment_Tree .\nTất_cả những bài_giải được bằng Fenwick tree đều có_thể giải được bằng Segment_Tree .\nNhưng chiều ngược_lại không đúng .\nBạn có_thể đọc thêm về Fenwick_Tree ở đây .\n2 . 6 . Heavy-light decomposition Heavy_Light_Decomposition là một thuật_toán được áp_dụng nhiều trong những bài cần xử_lý các truy_vấn trên cây .\nHeavy-light decomposition là kĩ_thuật phân_tách một cây thành nhiều chuỗi đỉnh (chain) rời nhau .\nSau_đó , chúng_ta có_thể áp_dụng các cấu_trúc dữ_liệu như Interval_Tree hay Binary-Indexed_Tree lên những chuỗi này để có_thể cập_nhật dữ_liệu hoặc trả_lời các truy_vấn trên một đường_đi giữa 2 đỉnh trong cây .\nBạn có_thể đọc thêm ở : Thuật_toán phân_tách cây 2 . 7 . Persistent_Data_Structures_Persistent_Data_Structures là những cấu_trúc dữ_liệu được dùng khi chúng_ta cần có toàn_bộ lịch_sử của các thay_đổi trên 1 cấu_trúc dữ_liệu .\nBạn có_thể đọc thêm ở : Persistent_Data_Structures 3 .\nCTDL xâu 3 . 1 . Cây Tiền_Tố (Trie) Trie là một cấu_trúc dữ_liệu dùng để quản_lý một_tập hợp các xâu .\nTrie cho_phép : Thêm một xâu vào tập_hợp , với độ phức_tạp \\mathcalO(L) với L là độ_dài xâu cần thêm .\nXóa_một xâu khỏi tập_hợp , với độ phức_tạp \\mathcalO(L) .\nKiểm_tra một xâu có tồn_tại trong tập_hợp hay_không , với độ phức_tạp \\mathcalO(L) .\nNgoài_ra trên thực_tế , trie cũng rất tiết_kiệm bộ_nhớ khi áp_dụng để lưu các từ có_nghĩa , vì_vậy nó là một CTDL có ứng_dụng rất lớn .\nBạn có_thể đọc thêm bài viết về trie .\n3 . 2 . Aho_Corasick_Bài viết sẽ được cập_nhật sau 3 . 3 . Mảng Hậu_Tố (Suffix Array) Suffix_Array là một CTDL giúp sắp_xếp các hậu_tố của một xâu theo thứ_tự từ_điển .\nCTDL này thường được sử_dụng trong các bài_toán xử_lý xâu .\nBạn có_thể đọc thêm về Suffix_Array ở đây .\n3 . 4 . Suffix_Automaton_Bài viết sẽ được cập_nhật sau .\n3 . 5 . Palindrome_Tree_Palindrome tree (còn được gọi_là Eertree) , là một CTDL mới được phổ_biến vào năm 2014 nhờ bài thuyết_trình của Mikhail_Rubinchik .\nNhư tên_gọi của nó , Palindrome tree là một CTDL giúp giải_quyết các bài_toán về Palindrome .\nBạn có_thể đọc thêm ở đây Các tài_liệu tham_khảo : Codeforces_Topcoder\n", "tagged": "Table/Np of_Contents/Np 1/M ./CH\nCTDL/Np Lưu_trữ/Np 1/M ./CH 1/M ./CH Mảng/N (array)/Np ,/CH danh_sách/N liên_kết/V (linked/Np list)/Np 1/M ./CH 2/M ./CH Stack/Np ,/CH Queue/Np ,/CH Deque/Np 1/M ./CH 2/M ./CH 1/M ./CH Stack/Np 1/M ./CH 2/M ./CH 2/M ./CH Queue/Np 1/M ./CH 2/M ./CH 3/M ./CH Deque/Np 1/M ./CH 3/M ./CH Priority_Queue/Np -/CH Heap/Np 1/M ./CH 4/M ./CH Cây/N Tìm_Kiếm/V Nhị_Phân/Np 1/M ./CH 5/M ./CH Bảng_băm/Np (Hash/Np Tables)/Np 2/M ./CH\nCTDL/Np Truy_vấn/Np 2/M ./CH 1/M ./CH Mảng/N cộng_dồn/Np (Prefix/Np Sum)/Np 2/M ./CH 1/M ./CH 1/M ./CH Mảng/N cộng_dồn/Np -/CH Tìm/V tổng/N một/M đoạn/Nc liên_tiếp/A 2/M ./CH 1/M ./CH 2/M ./CH Mảng/N cộng_dồn/Np -/CH Tăng_giá_trị/Np các/L đoạn/Nc 2/M ./CH 1/M ./CH 3/M ./CH Mảng/N cộng_dồn/Np trên/E bảng/N 2/M chiều/N 2/M ./CH 2/M ./CH Disjoint_Sets/Np 2/M ./CH 3/M ./CH Sparse_Table/Np 2/M ./CH 4/M ./CH Segment_Tree/Np 2/M ./CH 5/M ./CH Fenwick/Np 2/M ./CH 6/M ./CH Heavy-light/Np decomposition/Np 2/M ./CH 7/M ./CH Persistent_Data_Structures/Np 3/M ./CH\nCTDL/Np xâu/Np 3/M ./CH 1/M ./CH Cây/N Tiền_Tố/Np (Trie)/Np 3/M ./CH 2/M ./CH Aho_Corasick/Np 3/M ./CH 3/M ./CH Mảng/N Hậu_Tố/Np (Suffix/Np Array)/Np 3/M ./CH 4/M ./CH Suffix_Automaton/Np 3/M ./CH 5/M ./CH Palindrome_Tree_Các/Np tài_liệu/N tham_khảo/V :/CH Mặc_dù/C máy_tính/N đã/R có_thể/R xử_lý/V hàng_triệu/Np phép_tính/Np mỗi/L giây/Nu ,/CH nhưng/C khi/N một/M bài_toán/N trở/V phức_tạp/A ,/CH cách/N tổ_chức/V dữ_liệu/N vẫn/R vô_cùng/R quan_trọng/A ./CH\nĐể/E minh_họa/V điểm/N này/P ,/CH hãy/R tham_khảo/V ví_dụ/C sau/E :/CH bạn/N đi/V đến/E thư_viện/N ,/CH thử/V tìm_kiếm/V một/M quyển/Nc sách/N với/E chủ_đề/Np nào_đó/P ./CH\nCác/L cuốn/Nc sách/N được/V xếp/V theo/V lĩnh_vực/N ./CH\nTrong/E mỗi/L chủ_đề/Np ,/CH sách/N lại/R được/V xếp/V theo/V tên/N tác_giả/N ,/CH nhờ/V vậy_mà/C việc/N lấy/V và/Cc cất/V sách/N từ/E giá/N trở_nên/V khá/R dễ_dàng/A và/Cc đơn_giản/A ./CH\nBây_giờ/P ,/CH hãy/R thử/V tưởng_tượng/V thay_vì/X tổ_chức/V thành/V từng/R giá_sách/Np cụ_thể/A ,/CH sách/N được/V chất/N thành/V từng/R đống/N ở/E khắp/A thư_viện/N ./CH\nĐể/E tìm/V được/V quyển/Nc sách/N của/E mình/P ,/CH bạn/N sẽ/R phải/V mất/V hàng/N giờ/N ,/CH thậm_chí/R rất/R nhiều/A ngày/N ./CH\nTương_tự/A ,/CH một/M phần_mềm/N không_thể/R vận_hành/V hiệu_quả/N khi/N dữ_liệu/N không/R được/V lưu_trữ/Np một_cách/N phù_hợp/V với/E ứng_dụng/V ./CH\nTrong/E bài/N viết/V này/P ,/CH chúng_ta/P sẽ/R cùng_nhau/Np điểm/N qua/V các/L loại/N cấu_trúc/N dữ_liệu/N từ/E cơ_bản/A đến/E nâng_cao/Np ./CH\nĐể/E tìm_hiểu/V chi_tiết/N về/E một/M cấu_trúc/N dữ_liệu/N ,/CH các/L bạn/N có_thể/R đọc/V ở/E link/Np tương_ứng/V ./CH\nTrong/E bài/N viết/V này/P ,/CH mình/P tạm/A chia/V các/L CTDL/Np được/V chia/V thành/V các/L loại/N sau/E :/CH CTDL/Np lưu_trữ/Np :/CH thường/R có/V các/L thao_tác/V như/C thêm/V 1/M phần_tử/N ,/CH xóa/V 1/M phần_tử/N ./CH\nCó_thể/R có/V thêm/V các/L thao_tác/V như/C tìm_kiếm/V 1/M phần_tử/N ./CH\nCTDL/Np truy_vấn/Np :/CH thường_dùng/Np cho/E các/L bài_toán/N mà/C bạn/N phải/V duy_trì/V một_tập/Np hợp/V các/L số/N và/Cc thực_hiện/V 1/M số/N truy_vấn/Np trên/E đó/P ./CH\nCTDL/Np xâu/Np :/CH dùng/V cho/E các/L bài_tập/Np xử_lý/V xâu/Np ./CH\n1/M ./CH\nCTDL/Np Lưu_trữ/Np 1/M ./CH 1/M ./CH Mảng/N (array)/Np ,/CH danh_sách/N liên_kết/V (linked/Np list)/Np Mảng/N và/Cc danh_sách/N liên_kết/V là/V 2/M cấu_trúc/N dữ_liệu/N nền_tảng/N cho/E tất_cả/P các/L loại/N cấu_trúc/N dữ_liệu/N khác/A ./CH\nMảng/N và/Cc danh_sách/N liên_kết/V đều/R được/V dùng/V khi/N bạn/N muốn/V lưu/V nhiều/A dữ_liệu/N (thường/Np có/V cùng/A kiểu/N dữ/A liệu)/Np ./CH\nBảng/N dưới_đây/Np so_sánh/V các/L thao_tác/V về/E mảng/N và/Cc danh_sách/N liên_kết/V :/CH Mảng/N Danh_sách/N liên_kết/V Bộ_nhớ/Np Cố_định/A (cần/Np biết/V trước_số/Np phần/N tử)/Np Có_thể/R tăng_giảm/Np tùy_ý/V Thêm/V 1/M phần_tử/N \\mathcalO(N)/Np \\mathcalO(1)/Np ,/CH giả_sử/Np biết/V con_trỏ/Np tới/E phần_tử/N đó/P Tìm_kiếm/V 1/M phần_tử/N \\mathcalO(N)/Np \\mathcalO(N)/Np Truy_cập/Np phần_tử/N \\mathcalO(1)/Np \\mathcalO(N)/Np Khác/A -/CH Ít/A bộ_nhớ/Np hơn/A -/CH Cache/Np locality/Np :/CH các/L phần_tử/N ở/E vị_trí/N gần/A nhau/N trên/E bộ_nhớ/Np máy_tính/N ,/CH nên/C khi/N truy_cập/Np các/L phần_tử/N liên_tiếp/A sẽ/R nhanh/A hơn/A Bạn/N có_thể/R đọc/V thêm/V về/E mảng/N và/Cc danh_sách/N liên_kết/V ở/E đây/P 1/M ./CH 2/M ./CH Stack/Np ,/CH Queue/Np ,/CH Deque/Np 1/M ./CH 2/M ./CH 1/M ./CH Stack_Stack/Np là/V CTDL/Np cho_phép/V thực_hiện/V các/L thao_tác/V :/CH Thêm/V 1/M phần_tử/N vào/E cuối/N CTDL_Xóa/Np 1/M phần_tử/N khỏi/V cuối/N CTDL_Cả/Np 2/M thao_tác/V trên/E đều/R có/V độ/N phức_tạp/A \\mathcalO(1)/Np ./CH\nChú_ý/V ta/P chỉ_có/Np thể/N xóa/V phần_tử/N ở/E cuối/N CTDL/Np ,/CH nói_cách_khác/Np là/V phần_tử/N mà/C mới/R được/V thêm/V vào/E gần/A nhất/A ./CH\nVì_vậy/C ,/CH Stack/Np còn/R được/V gọi_là/V FIFO/Np (First/Np In_First_Out)/Np ./CH\nStack/Np có/V cài_đặt/V đơn_giản/A và/Cc được/V sử_dụng/V trong/E nhiều/A thuật_toán/N như/C DFS/Np ,/CH tìm/V chu_trình/N Euler/Np ,/CH tìm/V khớp/N của/E đồ_thị/Np ./CH\nTrong_C++_STL/Np ,/CH có_sẵn/Np kiểu/N dữ_liệu/N stack/Np ./CH\n1/M ./CH 2/M ./CH 2/M ./CH Queue_Queue/Np là/V CTDL/Np cho_phép/V thực_hiện/V các/L thao_tác/V :/CH Thêm/V 1/M phần_tử/N vào/E cuối/N CTDL_Xóa/Np 1/M phần_tử/N khỏi/V đầu/N CTDL/Np ./CH\nCả/P 2/M thao_tác/V đều/R có/V độ/N phức_tạp/A \\mathcalO(1)/Np ./CH\nChú_ý/V ta/P chỉ_có/Np thể/N xóa/V phần_tử/N ở/E đầu/N CTDL/Np ,/CH nói_cách_khác/Np là/V phần_tử/N mà/C đã/R được/V thêm/V vào/E lâu/A nhất/A ./CH\nVì_vậy/C ,/CH Stack/Np còn/R được/V gọi_là/V LIFO/Np (Last/Np In_First_Out)/Np ./CH\nQueue/Np có/V cài_đặt/V đơn_giản/A và/Cc được/V sử_dụng/V trong/E BFS/Np ./CH\nTrong_C++_STL/Np ,/CH có_sẵn/Np kiểu/N dữ_liệu/N queue/Np ./CH\n1/M ./CH 2/M ./CH 3/M ./CH Deque_Deque/Np (Double/Np Ended_Queue)/Np ,/CH là/V CTDL/Np tổng_quát/Np hơn/A của/E Stack/Np và/Cc Queue/Np ./CH\nNó/P cho_phép/V :/CH Thêm/V 1/M phần_tử/N vào/E đầu/N hoặc/Cc cuối/N CTDL/Np ./CH\nXóa/V 1/M phần_tử/N khỏi/V đầu/N hoặc/Cc cuối/N CTDL/Np ./CH\nCả/P 2/M thao_tác/V đều/R có/V độ/N phức_tạp/A \\mathcalO(1)/Np ./CH\nDeque/Np được/V sử_dụng/V trong/E một_số/L thuật_toán/N như/C :/CH BFS/Np 01/M Tìm_Min/Np trên/E đoạn/Nc tịnh_tiến/Np ./CH\nTrong_C++_STL/Np ,/CH có_sẵn/Np kiểu/N dữ_liệu/N deque/Np ./CH\n1/M ./CH 3/M ./CH Priority_Queue/Np -/CH Heap_Heap/Np là/V một/M cấu_trúc/N dữ_liệu/N cho_phép/V thực_hiện/V các/L thao_tác/V :/CH Thêm/V một/M phần_tử/N ,/CH với/E độ/N phức_tạp/A \\mathcalO(\\logN)/Np ./CH\nXóa_một/Np phần_tử/N ,/CH với/E độ/N phức_tạp/A \\mathcalO(\\logN)/Np ./CH\nTìm/V max/Np của/E các/L phần_tử/N ,/CH với/E độ/N phức_tạp/A \\mathcalO(1)/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Heap/Np ở/E đây/P Fibonacci_Heap/Np là/V một/M dạng/N heap/Np có/V độ/N phức_tạp/A bé/N hơn/A ./CH\nTrong_C++/Np ,/CH CTDL/Np priority_queue/Np được/V cài_đặt/V bằng/E Fibonacci_Heap/Np ./CH\n1/M ./CH 4/M ./CH Cây/N Tìm_Kiếm/V Nhị_Phân/Np Cây/N Tìm_Kiếm/V Nhị_Phân/Np (/CH BST_Binary_Search_Tree/Np )/CH là/V một/M cây/N nhị_phân/Np có/V tính_chất/N :/CH Với/E mỗi/L giá_trị/N trên/E đỉnh_đang/Np xét/V ,/CH giá_trị/N của/E mọi/L đỉnh/N trên/E cây_con/Np trái/Nc luôn/R nhỏ/A hơn/A đỉnh_đang/Np xét/V và/Cc giá_trị/N của/E mọi/L đỉnh/N trên/E cây_con/Np phải/V luôn/R lớn/A hơn/A đỉnh_đang/Np xét/V ./CH\nCây/N tìm_kiếm/V nhị_phân/Np cho_phép/V thực_hiện/V các/L thao_tác/V :/CH Thêm/V 1/M phần_tử/N ./CH\nXóa/V 1/M phần_tử/N ./CH\nKiểm_tra/V 1/M phần_tử/N có/V tồn_tại/V hay_không/Np ./CH\nTìm/V phần_tử/N đầu_tiên/A lớn/A hơn/A hoặc/Cc bằng/E 1/M giá_trị/N x/CH cho/E trước/E ./CH\nTrong/E trường_hợp/N dữ_liệu/N ngẫu_nhiên/A ,/CH các/L thao_tác/V trên/E có/V độ/N phức_tạp/A trung_bình/A là/V \\mathcalO(\\logN)/Np ./CH\nTuy_nhiên/C trong/E trường_hợp/N xấu/A nhất/A ,/CH cây/N tìm_kiếm/V nhị_phân/Np bị/V suy_biến/Np (thành/Np 1/M \"đường/Np thẳng\"/Np )/CH ,/CH thì/C độ/N phức_tạp/A mỗi/L thao_tác/V là/V \\mathcalO(N)/Np ./CH\nĐể/E khắc_phục/V điều/N này/P ,/CH có/V rất/R nhiều/A CTDL/Np cải_tiến/V từ/E cây/N tìm_kiếm/V nhị_phân/Np ,/CH thường/R được/V gọi_là/V các/L cây/N nhị_phân/Np cân_bằng/A ./CH\nKhi/N đó/P ,/CH các/L thao_tác/V trên/E có_thể/R được/V thực_hiện/V với/E độ/N phức_tạp/A \\mathcalO(\\logN)/Np ./CH\nVí_dụ/C :/CH Cây_Đỏ/Np Đen/A (Red-Black/Np Tree)/Np là/V một/M dạng/N cây/N tìm_kiếm/V nhị_phân/Np (/CH BST/Np )/CH mà/C sau/E mỗi/L truy_vấn/Np được/V thực_hiện/V ,/CH cây/N tự/P cân_bằng/A theo/V đúng/A tính_chất/N của/E nó/P với/E độ/N phức_tạp/A O(log(N))/Np ./CH\nCTDL/Np set/N trong/E C++/Np được/V cài_đặt/V bằng/E cây_đỏ/Np đen/A ./CH\nSplay/Np tree/Np ,/CH Skip/Np list/Np ,/CH Treap/Np thường/R được/V dùng/V trong/E các/L kỳ/N thi/V bởi/E cài_đặt/V đơn_giản/A ./CH\n1/M ./CH 5/M ./CH Bảng_băm/Np (Hash/Np Tables)/Np Bảng_băm/Np là/V một/M CTDL/Np thường/R được/V sử_dụng/V như/C một/M từ_điển/Np :/CH mỗi/L phần_tử/N trong/E bảng_băm/Np là/V một/M cặp/N (khóa/Np ,/CH giá/N trị)/Np ./CH\nNếu/C so_sánh/V với/E mảng/N ,/CH khóa/N được/V xem/V như/C chỉ_số/N của/E mảng/N ,/CH còn/R giá_trị/N giống_như/Np giá_trị/N mà/C ta/P lưu/V tại/E chỉ_số/N tương_ứng/V ./CH\nBảng_băm/Np không/R như/C các/L loại_từ/Np điển/Np thông_thường/A -/CH ta/P có_thể/R tìm/V được_giá/Np trị/V thông_qua/V khóa/N của/E nó/P ./CH\nBảng_băm/Np hoạt_động/N dựa/V trên/E hàm/Np Hash/Np :/CH Hash/Np là/V quá_trình/N khởi/V tạo/V một/M giá_trị/N khóa/N (thường/Np là/V 32/M bit/Np hoặc/Cc 64/M bit)/Np từ/E một/M phần/N dữ_liệu/N ./CH\nNó/P có_thể/R là/V n/Ny bit/Np đầu_tiên/A của/E dữ_liệu/N ,/CH n/Ny bit/Np cuối_cùng/A ,/CH giá_trị/N mod/Np cho/E một_số/L nguyên_tố/N nào_đó/P ./CH\nDựa/V theo/V giá_trị/N hash/Np ,/CH dữ_liệu/N được/V chia/V vào/E các/L bucket/Np :/CH Trong/E trường_hợp/N hàm/Np Hash/Np hoạt_động/N tốt/A ,/CH mỗi/L bucket/Np có/V rất/R ít/A phần_tử/N ,/CH độ/N phức_tạp/A của/E các/L thao_tác/V trên/E Hash/Np table/Np như_sau/Np :/CH Tìm/V 1/M khóa/N :/CH \\mathcalO(1)/Np ./CH\nThêm/V //CH xóa/V 1/M khóa/N :/CH \\mathcalO(1)/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Hash/Np table/Np ở/E đây/P 2/M ./CH\nCTDL/Np Truy_vấn/Np 2/M ./CH 1/M ./CH Mảng/N cộng_dồn/Np (Prefix/Np Sum)_Mảng/Np cộng_dồn/Np là/V một_cách/N áp_dụng/V khéo_léo/A mảng/N ./CH\nCó/V 2/M dạng/N bài/N cơ_bản/A có_thể/R giải/N được/V bằng/E cách/N áp_dụng/V Prefix_Sum/Np ./CH\n2/M ./CH 1/M ./CH 1/M ./CH Mảng/N cộng_dồn/Np -/CH Tìm/V tổng/N một/M đoạn/Nc liên_tiếp/A Ví_dụ/C Cho/E một/M mảng/N a_1/Np ,/CH a_2/Np ,/CH a_3/Np ,/CH ./CH ./CH ./CH ,/CH a_N/Np ./CH\nCần/V trả_lời/V nhiều/A truy_vấn/Np ,/CH mỗi/L truy_vấn/Np cho/E 2/M số/N L/Ny và/Cc R/Np ,/CH yêu_cầu/V in/V ra/V tổng/N a_L/Np +/CH a_L+1/Np +/CH ./CH ./CH ./CH\n+/CH a_R/Np ./CH\nCách/N làm/V Tạo/V một/M mảng/N S/Y ,/CH với/E S_i/Np =/CH a_1/Np +/CH a_2/Np +/CH ./CH ./CH ./CH\n+/CH a_i/Np ./CH\nMảng_S/Np được/V gọi_là/V mảng/N cộng_dồn/Np Với/E mỗi/L truy_vấn/Np ,/CH in/V ra/V :/CH S_R/Np –/CH S_L-1/Np ./CH\n2/M ./CH 1/M ./CH 2/M ./CH Mảng/N cộng_dồn/Np -/CH Tăng_giá_trị/Np các/L đoạn/Nc Ví_dụ/C Cho/E mảng/N a_1/Np ,/CH a_2/Np ,/CH ./CH ./CH ./CH ,/CH a_N/Np ./CH\nCần/V thực_hiện/V nhiều/A truy_vấn/Np ,/CH mỗi/L truy_vấn/Np cho/E 3/M số/N L/Ny ,/CH R/Np ,/CH V/Nu ./CH\nYêu_cầu/V :/CH với/E mỗi/L i/M (L/Np \\le/Np i/M \\le/Np R)/Np ,/CH cộng/V V/Nu vào/E a_i/Np ./CH\nTính/V mảng/N a/Ni sau/E khi/N thực_hiện/V tất_cả/P các/L truy_vấn/Np ./CH\nCách/N làm/V Tạo/V một/M mảng/N P/Ny :/CH p_1/Np ,/CH p_2/Np ,/CH ./CH ./CH ./CH ,/CH p_N/Np Khởi/V tạo/V p_i/Np =/CH 0/M ./CH\nVới/E mỗi/L truy_vấn/Np ,/CH tăng/V p_L/Np lên/V V/Nu và/Cc trừ/V p_R+1/Np đi/V V/Nu ./CH\nCuối_cùng/A ,/CH với/E mỗi/L i/M (từ/Np 1)/Np ,/CH p_i/Np +=/Np p_i–1/Np ./CH\nTa/P có/V a_i/Np =/CH a_i/Np +/CH p_i/Np ./CH\n2/M ./CH 1/M ./CH 3/M ./CH Mảng/N cộng_dồn/Np trên/E bảng/N 2/M chiều/N Trên/E bảng/N 2/M chiều/N A(i/Np ,/CH j)/Np ,/CH ta/P đặt/V f(i/Np ,/CH j)/Np là/V tổng_các/Np ô/N trong/E hình_chữ_nhật/N có/V 2/M đỉnh/N đối_diện/V là/V (1/Np ,/CH 1)/Np và/Cc (i/Np ,/CH j)/Np ./CH\nKhi/N đó/P ,/CH ta/P có/V :/CH f(i/Np ,/CH j)/Np =/CH f(i-1/Np ,/CH j)/Np +/CH f(i/Np ,/CH j-1)/Np -/CH f(i-1/Np ,/CH j-1)/Np +/CH A(i/Np ,/CH j)/Np ./CH\nGiải_thích/V công_thức/N trên/E :/CH đỏ/A =/CH xanh_da_trời/Np +/CH vàng/N -/CH tím/A +/CH xanh/A lá/N f(i/Np ,/CH j)/Np =/CH f(i-1/Np ,/CH j)/Np +/CH f(i/Np ,/CH j-1)/Np -/CH f(i-1/Np ,/CH j-1)/Np +/CH A(i/Np ,/CH j)/Np 2/M ./CH 2/M ./CH Disjoint_Sets_Disjoint_Sets/Np là/V cấu_trúc/N dữ_liệu/N được/V sử_dụng/V trong/E thuật_toán/N Kruskal/Np và/Cc thuật_toán/N Prim/Np -/CH 2/M thuật_toán/N tìm/V cây/N khung/N nhỏ/A nhất/A của/E đồ_thị/Np ./CH\nNhư/C tên_gọi/Np của/E nó/P ,/CH Disjoint_Set/Np được/V dùng/V để/E quản_lý/V các/L tập_hợp/N không/R giao/V nhau/N ./CH\nBài_toán/N Cho/E đồ_thị/Np có/V N/Ny đỉnh/N ./CH\nTa/P cần/V thực_hiện/V 2/M loại/N truy_vấn/Np :/CH Nối/V 2/M đỉnh/N i/M và/Cc j/Np Kiểm_tra/V 2/M đỉnh/N i/M và/Cc j/Np có/V thuộc/V cùng/A thành_phần/N liên_thông/V hay_không/Np ./CH\nDisjoint/Np set/N cho_phép/V ta/P thực_hiện/V 2/M thao_tác/V trên/E với/E độ/N phức_tạp/A \\mathcalO(\\logN)/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Disjoint_Set/Np ở/E bài/N viết/V này/P ./CH\n2/M ./CH 3/M ./CH Sparse_Table_Sparse_Table/Np là/V cấu_trúc/N dữ_liệu/N được/V sử_dụng/V trong/E bài_toán/N LCA/Np amp;/Np RMQ/Np ./CH\nVới/E cả/P 2/M bài_toán/N ,/CH Sparse_Table/Np cho_phép/V :/CH Khởi/V tạo/V với/E độ/N phức_tạp/A :/CH \\mathcalO(N/Np \\logN)/Np ./CH\nTrả_lời/V truy_vấn/Np với/E độ/N phức_tạp/A \\mathcalO(1)/Np ./CH\n2/M ./CH 4/M ./CH Segment_Tree_Segment_Tree/Np ,/CH còn/R được/V gọi_là/V Interval_Tree/Np trong/E nhiều/A tài_liệu/N tiếng/N Việt/Np ,/CH là/V cấu_trúc/N dữ_liệu/N cho_phép/V thực_hiện/V các/L truy_vấn/Np trên/E một/M dãy_số/Np ./CH\nSegment_Tree/Np rất/R linh_động/Np và/Cc có_thể/R áp_dụng/V với/E nhiều/A loại/N truy_vấn/Np khác_nhau/Np ,/CH nên/C nó/P xuất_hiện/V rất/R nhiều/A trong/E các/L kỳ/N thi/V ./CH\nVới/E dãy_số/Np độ_dài/Np N/Ny ,/CH Segment_Tree/Np cho_phép/V thực_hiện/V các/L thao_tác/V với/E độ/N phức_tạp/A \\mathcalO(\\logN)/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Segment_Tree/Np ở/E đây/P ./CH\nSegment_Tree/Np cũng/R có_một/Np mở_rộng/V với/E nhiều/A ứng_dụng/V quan_trọng/A là/V Segment_Tree/Np trên/E tập/V đoạn_thẳng/Np ./CH\n2/M ./CH 5/M ./CH Fenwick_Cũng/Np giống_như/Np Segment_Tree/Np ,/CH Fenwick/Np tree/Np (còn/Np được/V gọi_là/V Binary_Indexed_Tree)/Np là/V cấu_trúc/N dữ_liệu/N cho_phép/V thực_hiện/V các/L truy_vấn/Np trên/E một/M dãy_số/Np :/CH Ưu_điểm/N :/CH Độ/N phức_tạp/A mỗi/L thao_tác/V cũng/R là/V \\mathcalO(\\logN)/Np ./CH\nHằng_số/Np tự_nhiên/A thấp/A hơn/A Segment_Tree/Np ,/CH nên/C chạy/V nhanh/A hơn/A ./CH\nDùng/V ít/A bộ_nhớ/Np hơn/A ./CH\nDễ/A cài_đặt/V hơn/A Segment_Tree/Np Nhược_điểm/N :/CH Không/R tổng_quát/Np bằng/E Segment_Tree/Np ./CH\nTất_cả/P những/L bài_giải/Np được/V bằng/E Fenwick/Np tree/Np đều/R có_thể/R giải/N được/V bằng/E Segment_Tree/Np ./CH\nNhưng/C chiều/N ngược_lại/X không/R đúng/A ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Fenwick_Tree/Np ở/E đây/P ./CH\n2/M ./CH 6/M ./CH Heavy-light/Np decomposition/Np Heavy_Light_Decomposition/Np là/V một/M thuật_toán/N được/V áp_dụng/V nhiều/A trong/E những/L bài/N cần/V xử_lý/V các/L truy_vấn/Np trên/E cây/N ./CH\nHeavy-light/Np decomposition/Np là/V kĩ_thuật/N phân_tách/Np một/M cây/N thành/V nhiều/A chuỗi/N đỉnh/N (chain)/Np rời/V nhau/N ./CH\nSau_đó/Np ,/CH chúng_ta/P có_thể/R áp_dụng/V các/L cấu_trúc/N dữ_liệu/N như/C Interval_Tree/Np hay/Cc Binary-Indexed_Tree/Np lên/V những/L chuỗi/N này/P để/E có_thể/R cập_nhật/V dữ_liệu/N hoặc/Cc trả_lời/V các/L truy_vấn/Np trên/E một/M đường_đi/Np giữa/N 2/M đỉnh/N trong/E cây/N ./CH\nBạn/N có_thể/R đọc/V thêm/V ở/E :/CH Thuật_toán/N phân_tách/Np cây/N 2/M ./CH 7/M ./CH Persistent_Data_Structures_Persistent_Data_Structures/Np là/V những/L cấu_trúc/N dữ_liệu/N được/V dùng/V khi/N chúng_ta/P cần/V có/V toàn_bộ/L lịch_sử/N của/E các/L thay_đổi/V trên/E 1/M cấu_trúc/N dữ_liệu/N ./CH\nBạn/N có_thể/R đọc/V thêm/V ở/E :/CH Persistent_Data_Structures/Np 3/M ./CH\nCTDL/Np xâu/Np 3/M ./CH 1/M ./CH Cây/N Tiền_Tố/Np (Trie)/Np Trie/Np là/V một/M cấu_trúc/N dữ_liệu/N dùng/V để/E quản_lý/V một_tập/Np hợp/V các/L xâu/Np ./CH\nTrie/Np cho_phép/V :/CH Thêm/V một/M xâu/Np vào/E tập_hợp/N ,/CH với/E độ/N phức_tạp/A \\mathcalO(L)/Np với/E L/Ny là/V độ_dài/Np xâu/Np cần/V thêm/V ./CH\nXóa_một/Np xâu/Np khỏi/V tập_hợp/N ,/CH với/E độ/N phức_tạp/A \\mathcalO(L)/Np ./CH\nKiểm_tra/V một/M xâu/Np có/V tồn_tại/V trong/E tập_hợp/N hay_không/Np ,/CH với/E độ/N phức_tạp/A \\mathcalO(L)/Np ./CH\nNgoài_ra/X trên/E thực_tế/N ,/CH trie/Np cũng/R rất/R tiết_kiệm/V bộ_nhớ/Np khi/N áp_dụng/V để/E lưu/V các/L từ/E có_nghĩa/A ,/CH vì_vậy/C nó/P là/V một/M CTDL/Np có/V ứng_dụng/V rất/R lớn/A ./CH\nBạn/N có_thể/R đọc/V thêm/V bài/N viết/V về/E trie/Np ./CH\n3/M ./CH 2/M ./CH Aho_Corasick_Bài/Np viết/V sẽ/R được/V cập_nhật/V sau/E 3/M ./CH 3/M ./CH Mảng/N Hậu_Tố/Np (Suffix/Np Array)/Np Suffix_Array/Np là/V một/M CTDL/Np giúp/V sắp_xếp/V các/L hậu_tố/Np của/E một/M xâu/Np theo/V thứ_tự/N từ_điển/Np ./CH\nCTDL/Np này/P thường/R được/V sử_dụng/V trong/E các/L bài_toán/N xử_lý/V xâu/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V về/E Suffix_Array/Np ở/E đây/P ./CH\n3/M ./CH 4/M ./CH Suffix_Automaton_Bài/Np viết/V sẽ/R được/V cập_nhật/V sau/E ./CH\n3/M ./CH 5/M ./CH Palindrome_Tree_Palindrome/Np tree/Np (còn/Np được/V gọi_là/V Eertree)/Np ,/CH là/V một/M CTDL/Np mới/R được/V phổ_biến/V vào/E năm/N 2014/M nhờ/V bài/N thuyết_trình/Np của/E Mikhail_Rubinchik/Np ./CH\nNhư/C tên_gọi/Np của/E nó/P ,/CH Palindrome/Np tree/Np là/V một/M CTDL/Np giúp/V giải_quyết/V các/L bài_toán/N về/E Palindrome/Np ./CH\nBạn/N có_thể/R đọc/V thêm/V ở/E đây/P Các/L tài_liệu/N tham_khảo/V :/CH Codeforces_Topcoder/Np\n", "title": "Tổng quan về Cấu Trúc Dữ Liệu\n", "link": "http://vnoi.info/wiki/algo/data-structures/data-structures-overview\n"}