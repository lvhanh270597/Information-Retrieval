{"content": "Bài viết bởi bmerry .\nNguồn : Topcoder_Table of_Contents Giới_thiệu Cơ_bản Tách từng bit Đếm_số bit Tất_cả các tập_con Cài_đặt : Chỉ_cần một bit sai cũng 0 điểm Một_số mẹo hay (và cute) Bài_tập mẫu Giới_thiệu Hầu_hết các kĩ_thuật tối_ưu dùng trong các kì_thi Topcoder đều là những kĩ_thuật cao_cấp , có_nghĩa là , các kĩ_thuật này tối_ưu trực_tiếp thuật_toán hơn_là tối_ưu cách cài_đặt .\nTuy_nhiên , có_một kĩ_thuật tối_ưu cơ_bản nhưng sử_dụng rất hiệu_quả là thao_tác bit (bit manipulation) , hay sử_dụng những bit thuộc biểu_diễn của một_số nguyên để biểu_diễn một_tập hợp .\nNó không chỉ làm tăng_tốc_độ chạy , giảm dung_lượng bộ_nhớ , mà_còn làm code chúng_ta trở_nên đơn_giản hơn .\nMình sẽ bắt_đầu bằng việc nhắc_lại một_số kiến_thức cơ_bản về bit , trước_khi nghiên_cứu những kĩ_thuật sâu hơn .\nCơ_bản Những thứ quan_trọng nhất trong thao_tác bit là những toán_tử trên bit (bit-wise operator) : amp; (and) , (or) , ~ (not) và (xor) .\nChắc_hẳn các bạn đã quá quen với ba toán_tử đầu_tiên trong các phép_toán logic ( amp;amp; , , và ! ) .\nDưới_đây là bảng chân_trị (truth tables) : A_B ! A_A amp;amp; B_A_B_A_B 0 0 1 0 0 0 0 1 1 0 1 1 1 0 0 0 1 1 1 1 0 1 1 0 Toán_tử bit trên số_nguyên cũng thực hiên giống_vậy , chỉ khác một thứ là thay_vì chuyển các tham_số về true hoặc false , thì các toán_tử bit được thực_hiện trên các bit của các tham_số .\nDo_đó , nếu A là 1010 và B là 1100 , thì A amp; B = 1000 A_B = 1110 A_B = 0110 ~A = 11110101 (số chữ_số 1 phụ_thuộc vào kiểu dữ_liệu của A)_Hai toán_tử mà chúng_ta cần phải_biết nữa đó là toán_tử dịch bit a lt;lt; b và a gt;gt; b .\nToán_tử đầu_tiên là dịch tất_cả các bit của a sang trái b vị trí; Toán_tử thứ_hai cũng giống_vậy nhưng dịch sang phải .\nVới những giá_trị không âm (cũng là những số duy_nhất mà ta sẽ xét đến) , những bit mới xuất_hiện (do dịch trái) sẽ bằng 0 .\nDịch trái (left-shifting) b bit đồng_nghĩa với việc nhân với 2b và dịch phải (right-shifting) đồng_nghĩa với chia nguyên cho 2b .\nDịch bit được sử_dụng nhiều nhất để truy_cập vào một bit bất_kì , ví_dụ , 1 lt;lt; x là một_số nhị_phân với bit thứ x bằng 1 và các bit khác bằng 0 (bit luôn_luôn được đếm từ bên phải (least-significant) , đếm bắt_đầu_từ 0) .\nThông_thường , chúng_ta sẽ sử_dụng một_số nguyên để biểu_diễn một_tập hợp với miền giá_trị lên đến 32 giá_trị (hoặc 64 nếu sử_dụng số_nguyên 64 bit) , với bit 1 cho_biết phần_tử đó có trong tập_hợp và bit 0 thì không có .\nSau_đó thì các phép_toán thì không có gì phức_tạp , trong đó ALL_BITS trả về số bit 1 , tương_ứng với số phần_tử có trong tập_hợp : Phép_toán hợp (Set union) A_B Phép_toán giao (Set intersection) A amp; B Phép_toán hiệu (Set subtraction) A amp; ~B Phép_toán phủ_định (Set negation) ALL_BIT A_Gán bit bằng 1 (Set bit) A = 1 lt;lt; bit Gán bit bằng 0 (Clear bit) A amp;= ~(1 lt;lt; bit) Truy_cập giá_trị (Test bit) (A amp; 1 lt;lt; bit) ! = 0 Tách từng bit Trong phần này , chúng_ta sẽ bàn đến việc tìm vị_trí của bit 1 cao nhất (bit 1 nằm xa nhất về bên trái) và thấp nhất (bit 1 nằm xa nhất về bên phải) trong một_số .\nĐây là những phép_toán cơ_bản để tách một_tập hợp ra thành những phần_tử .\nTìm bit 1 thấp nhất khá là đơn_giản , chỉ_cần kết_hợp đúng_đắn giữa toán_tử bit và phép_toán số_học .\nGiả_sử chúng_ta muốn tìm bit 1 thấp nhất của số x (x khác 0) .\nNếu chúng_ta trừ 1 từ x thì bit này được xoá , nhưng tất_cả các bit một khác vẫn còn .\nDo_đó , x amp; ~(x - 1) chỉ chứa duy_nhất bit 1 thấp nhất của x .\nTuy_nhiên , cách này chỉ cho chúng_ta biết giá_trị của bit đó , không_phải là vị_trí .\nNếu chúng_ta muốn biết vị_trí của bit 1 cao nhất và thấp nhất , cách tiếp_cận đơn_giản nhất đó là duyệt qua các bit (từ trái qua hay từ phải qua) cho tới khi tìm được bit 1 đầu_tiên .\nLúc đầu , ta có_thể cảm_thấy cách làm này hơi chậm vì không tận_dụng được lợi_thế gì về bit .\nTuy_nhiên , nếu xác_suất 2N tập_con của miền giá_trị_N phần_tử đều bằng_nhau , thì trung_bình vòng_lặp chỉ_cần 2 lần chạy , thật_ra đây là phương_pháp nhanh nhất .\nCPU 386 có hỗ_trợ duyệt bit (bit scanning) : BSF (bit scan forward) và BSR (bit scan reverse) .\nGCC cung_cấp những hỗ_trợ này qua những hàm xây_dựng sẵn (built-in functions) __builtin_ctz (đếm số chữ_số 0 đứng cuối) và __builtin_clz (đếm số chữ_số 0 đứng đầu) .\nĐây là những cách tiện_lợi nhất để tìm vị_trí của bit dành cho lập_trình_viên C++ ở Topcoder .\nLưu_ý : giá_trị trả về là undefined nếu tham_số đầu_vào bằng 0 .\nCuối_cùng , còn một phương_pháp khác để thay_thế trong những testcase mà dùng vòng_lặp tốn nhiều thời_gian .\nSử_dụng mỗi byte của số_nguyên 4 byte hoặc số_nguyên 8 byte để tính trước bảng 256 phần_tử lưu_trữ vị_trí của bit 1 cao nhất (thấp nhất) trong byte đó .\nBit 1 cao nhất (thấp nhất) của số_nguyên là giá_trị lớn nhất (giá trị nhỏ nhất) của bảng này .\nPhương_pháp này được đề_cập đến để làm đa_dạng thêm các phương_pháp , tốc_độ cũng chưa được đánh_giá rõ_ràng qua các kì_thi Topcoder .\nĐếm_số bit Chúng_ta có_thể dễ_dàng kiểm_tra một_số có_phải là luỹ_thừa của 2 bằng cách xoá bit 1 thấp nhất và kiểm_tra xem nếu kết_quả có bằng 0 chưa .\nTuy_nhiên , trong một_số trường_hợp chúng_ta cần phải_biết có bao_nhiêu bit đã được set (bit đã được set là bit 1 , bit chưa được set là bit bằng 0) , chúng_ta cần phải thực_hiện nhiều việc phức_tạp hơn tí .\nGCC có_một hàm gọi_là __builtin_popcount thực_hiện đúng những thứ ta cần .\nTuy_nhiên , không giống_như hàm __builtin_ctz , nó không được chuyển thành những chỉ_thị trên phần_cứng (ít nhất_là trên x86) .\nThay vào đó , nó sẽ sử_dụng phương_pháp lưu bảng giống_như trên đã trình_bày để tìm_kiếm bit .\nPhương_pháp này khá là hiệu_quả và cũng cực_kì tiện_lợi .\nNhững người dùng các ngôn_ngữ khác không_thể dùng cách này (mặc dù họ có_thể cài_đặt lại nó) .\nNếu một_số được dự_đoán rằng có rất ít bit 1 , một phương_pháp thay_thế là chỉ_cần lặp_lại quá_trình tìm bit 1 thấp nhất và xoá nó .\nTất_cả các tập_con Một ưu_điểm lớn của thao_tác bit là việc duyệt qua tất_cả các tập_con của một_tập hợp N phần_tử rất đơn_giản : mỗi số_nguyên đại_diện cho một_tập con .\nHơn_thế_nữa , nếu A là tập_con của B thì số_nguyên đại_diện cho A sẽ nhỏ hơn số_nguyên đại_diện cho B , rất tiện_lợi cho việc kết_hợp với quy_hoạch_động .\nViệc duyệt qua tất_cả các tập_con của một_tập con khác cũng rất dễ_dàng (được biểu_diễn bằng một dãy bit) , nếu bạn không quan_tâm đến thứ_tự duyệt ngược_lại (hoặc có_thể lưu các tập_hợp vào một danh_sách và đi ngược lại) .\nMẹo được sử_dụng cũng giống_như việc tìm bit 1 thấp nhất vậy .\nNếu chúng_ta trừ đi 1 từ tập_con , thì phần_tử đại_diện bởi bit 1 đó sẽ được xoá , và mỗi phần_tử 0 phía bên phải nó đều trở_thành 1 .\nTuy_nhiên , chúng_ta chỉ muốn các phần_tử được chọn là những phần_tử có trong tập cha .\nNên bước lặp chỉ_cần thay_thế ngắn_gọn bằng i = (i - 1) amp; superset .\nCài_đặt : // xét tất_cả các tập_con khác rỗng của S for ( int i = S ; i gt; 0 ; i = ( i - 1 ) amp; S ); Chỉ_cần một bit sai cũng 0 điểm Có_một số lỗi mà mọi người_thường mắc_phải khi sử_dụng các thao_tác bit .\nChú_ý cẩn_thận với code của bạn .\nKhi thực_hiện phép_toán dịch , a lt;lt; b , kiến_trúc x86 chỉ sử_dụng the 5 bit thấp nhất của b (6 cho số_nguyên 64 bit) .\nĐiều này có_nghĩa là dịch trái (hoặc phải) 32 bit đồng_nghĩa_là không làm_gì cả , ngoài việc xoá tất_cả các bit .\nViệc này cũng được nhắc đến trong Java và C;_C99 đề_cập rằng việc dịch ít_nhất bằng giá_trị của số sẽ trả về kết_quả là undefined .\nLịch_sử : máy 8086 sử_dụng full shift register , thường thao_tác này còn được dùng để kiểm_tra processor mới .\nToán_tử amp; và có độ ưu_tiên thực_hiện thấp hơn phép so_sánh .\nĐiều đó có_nghĩa là x amp; 3 == 1 bằng với x amp; (3 == 1) , đây là những lỗi bạn không_hề muốn mắc_phải .\nNếu bạn muốn viết những dòng code C/C++ dùng ở nhiều nơi , hãy đảm_bảo rằng bạn sử_dụng kiểu unsigned , cụ_thể trong trường_hợp bạn có_ý định sử_dụng bit cao nhất (top-most) .\nC99 nói rằng dịch bit trên giá_trị âm sẽ trả về undefined .\nJava chỉ_có kiểu dữ_liệu có dấu : gt;gt; sẽ tự_động thay_đổi dấu của giá_trị nếu_cần thiết (nhưng đây là thứ bạn thường không muốn xảy ra) , nhưng toán_tử đặc_biệt này của Java là gt;gt;gt; sẽ thêm các số 0 vào phía trước_sau khi dịch .\nMột_số mẹo hay (và cute) Có_một số mẹo hay có_thể sử_dụng với thao_tác bit .\nNhững mẹo này khá hay để đem đi_chém gió với bạn_bè , nhưng thông_thường hiệu_quả cũng không cải_thiện lắm ở thực_tế .\nĐảo thứ_tự các bit trong một_số nguyên x = ((x amp; 0xaaaaaaaa) gt;gt; 1) ((x amp; 0x55555555) lt;lt; 1); x = ((x amp; 0xcccccccc) gt;gt; 2) ((x amp; 0x33333333) lt;lt; 2); x = ((x amp; 0xf0f0f0f0) gt;gt; 4) ((x amp; 0x0f0f0f0f) lt;lt; 4); x = ((x amp; 0xff00ff00) gt;gt; 8) ((x amp; 0x00ff00ff) lt;lt; 8); x = ((x amp; 0xffff0000) gt;gt; 16) ((x amp; 0x0000ffff) lt;lt; 16); Bài_tập là bạn hãy dùng kĩ_thuật phía trên để đếm_số bit với kiểu dữ_liệu word .\nDuyệt qua tất_cả các tập_con có k phần_tử int s = (1 lt;lt; k) - 1; while ( ! (s amp; 1 lt;lt; N)) //làm gì đó với s int lo = s amp; ~(s - 1); //bit 1 thấp nhất int lz = (s + lo) amp; ~s; //bit 0 thấp nhất trên lo s = lz; //thêm lz vào tập_hợp s amp;= ~(lz - 1); //reset bit phía dưới lz s = (lz / lo / 2) - 1; //đặt lại đúng số bit ở cuối Trong_C , dòng cuối có_thể viết là s = (lz gt;gt; ffs(lo)) - 1 để tránh phép_chia .\nXác_định x ?\ny : -y , trong đó x bằng 0 hoặc 1 (-x y) + x Câu_lệnh trên chạy được trên kiến_trúc số bù 2 (tồn tại ở hầu_hết các máy_tính bạn thấy ngày nay) , trong đó số_âm được biểu_diễn bằng cách đảo tất_cả các bit và cộng thêm cho 1 .\nChú_ý rằng trên i686 và trước đó , câu_lệnh này chạy khá hiệu_quả (không cần rẽ nhánh ) nhờ vào lệnh CMOVE (di chuyển có_điều kiện) .\nBài_tập mẫu TCCC 2006 , Round 1B Medium_Với mỗi thành_phố , giữ một bit-set của những thành_phố kề nó .\nMột_khi một phần của nhà_máy đã được chọn (đệ quy) , AND những bit-set đó lại sẽ cho ra một bit-set mới mô_tả những vị_trí có_thể của những phần của nhà_máy .\nNếu bit-set này có k bit , thì_có Ck_m cách để chọn các phần của nhà_máy .\nTCO 2006 , Round 1 Easy Số_lượng nút nhỏ cho thấy rằng bài này có_thể giải_quyết bằng việc xét tất_cả các tập_con .\nVới mỗi tập_con ta xét 2 trường_hợp : nút nhỏ nhất không có trao_đổi gì cả , trong trường_hợp ta xét tập_con mà không có nó , hoặc nó trao_đổi với một_số nút , ta sẽ xét các tập_hợp không có nó và các nút mà nó trao_đổi .\nCode bài_giải rất ngắn_gọn : static int dp1 lt;lt; 18; int SeparateConnections : : howMany(vector lt;stringgt; mat) int N = mat . size(); int N2 = 1 lt;lt; N; dp0 = 0; for (int i = 1; i lt; N2; i++) int bot = i amp; ~(i - 1); int use = __builtin_ctz(bot); dpi = dpi bot; for (int j = use + 1; j lt; N; j++) if ((i amp; (1 lt;lt; j)) amp;amp; matusej == Y) dpi = max(dpi , dpi bot (1 lt;lt; j) + 2); return dpN2 - 1; SRM 308 , Division_Medium_Cái bảng chứa 36 hình_vuông và những con_cờ không_thể phân_biệt được , nên những vị_trí có_thể được mã_hoá vào số_nguyên 64 bit .\nBước_đầu tiên là liệt_kê tất_cả các bước_đi hợp_lệ .\nBất_kì bước_đi hợp_lệ nào cũng đều được mã_hoá sử_dụng 3 trường : 1 trạng_thái trước , 1 trạng_thái sau và một mask dùng để định_nghĩa phần_nào của trạng_thái trước là quan_trọng .\nMột_bước đi có_thể được tạo ra từ trạng_thái hiện_tại nếu (current amp; mask) == before .\nNếu nó được tạo ra , thì trạng_thái mới là (current amp; ~mask) after .\nSRM 320 , Division 1 Hard Điều_kiện cho ta biết rằng chỉ_có nhiều nhất 8 cột (nếu có nhiều hơn , ta có_thể đổi giữa dòng và cột) , nên chúng_ta có_thể xét từng cách để một dòng .\nMột_khi chúng_ta có thông_tin này , ta có_thể giải_quyết vấn_đề còn_lại của bài_toán (xem tutorial để biết thêm chi tiết) .\nDo_đó ta cần một danh_sách tất_cả số_nguyên n bit mà không có 2 bit 1 kề nhau , và ta cũng cần biết_có bao_nhiêu bit 1 trong mỗi dòng như_vậy .\nĐây là code của mình : for (int i = 0; i lt; (1 lt;lt; n); i++) if (i amp; (i lt;lt; 1)) continue; pg . push_back(i); pgb . push_back(__builtin_popcount(i));\n", "tagged": "Bài/N viết/V bởi/E bmerry/Np ./CH\nNguồn/N :/CH Topcoder_Table/Np of_Contents/Np Giới_thiệu/V Cơ_bản/A Tách/V từng/R bit/Np Đếm_số/Np bit/Np Tất_cả/P các/L tập_con/Np Cài_đặt/V :/CH Chỉ_cần/Np một/M bit/Np sai/A cũng/R 0/M điểm/N Một_số/L mẹo/N hay/Cc (và/Np cute)/Np Bài_tập/Np mẫu/N Giới_thiệu/V Hầu_hết/R các/L kĩ_thuật/N tối_ưu/A dùng/V trong/E các/L kì_thi/Np Topcoder/Np đều/R là/V những/L kĩ_thuật/N cao_cấp/A ,/CH có_nghĩa/A là/V ,/CH các/L kĩ_thuật/N này/P tối_ưu/A trực_tiếp/A thuật_toán/N hơn_là/Np tối_ưu/A cách/N cài_đặt/V ./CH\nTuy_nhiên/C ,/CH có_một/Np kĩ_thuật/N tối_ưu/A cơ_bản/A nhưng/C sử_dụng/V rất/R hiệu_quả/N là/V thao_tác/V bit/Np (bit/Np manipulation)/Np ,/CH hay/Cc sử_dụng/V những/L bit/Np thuộc/V biểu_diễn/V của/E một_số/L nguyên/A để/E biểu_diễn/V một_tập/Np hợp/V ./CH\nNó/P không/R chỉ/R làm/V tăng_tốc_độ/Np chạy/V ,/CH giảm/V dung_lượng/Np bộ_nhớ/Np ,/CH mà_còn/C làm/V code/Np chúng_ta/P trở_nên/V đơn_giản/A hơn/A ./CH\nMình/P sẽ/R bắt_đầu/V bằng/E việc/N nhắc_lại/Np một_số/L kiến_thức/N cơ_bản/A về/E bit/Np ,/CH trước_khi/Np nghiên_cứu/V những/L kĩ_thuật/N sâu/A hơn/A ./CH\nCơ_bản/A Những/L thứ/N quan_trọng/A nhất/A trong/E thao_tác/V bit/Np là/V những/L toán_tử/Np trên/E bit/Np (bit-wise/Np operator)/Np :/CH amp;/Np (and)/Np ,/CH (or)/Np ,/CH ~/CH (not)/Np và/Cc (xor)/Np ./CH\nChắc_hẳn/R các/L bạn/N đã/R quá/R quen/V với/E ba/M toán_tử/Np đầu_tiên/A trong/E các/L phép_toán/Np logic/Np (/CH amp;amp;/Np ,/CH ,/CH và/Cc !/CH )/CH ./CH\nDưới_đây/Np là/V bảng/N chân_trị/Np (truth/Np tables)/Np :/CH A_B/Np !/CH A_A/Np amp;amp;/Np B_A_B_A_B/Np 0/M 0/M 1/M 0/M 0/M 0/M 0/M 1/M 1/M 0/M 1/M 1/M 1/M 0/M 0/M 0/M 1/M 1/M 1/M 1/M 0/M 1/M 1/M 0/M Toán_tử/Np bit/Np trên/E số_nguyên/Np cũng/R thực/A hiên/N giống_vậy/Np ,/CH chỉ/R khác/A một/M thứ/N là/V thay_vì/X chuyển/V các/L tham_số/Np về/E true/Np hoặc/Cc false/Np ,/CH thì/C các/L toán_tử/Np bit/Np được/V thực_hiện/V trên/E các/L bit/Np của/E các/L tham_số/Np ./CH\nDo_đó/C ,/CH nếu/C A/Ni là/V 1010/Np và/Cc B/Ni là/V 1100/Np ,/CH thì/C A/Ni amp;/Np B/Ni =/CH 1000/M A_B/Np =/CH 1110/Np A_B/Np =/CH 0110/Np ~A/Np =/CH 11110101/Np (số/Np chữ_số/Np 1/M phụ_thuộc/V vào/E kiểu/N dữ_liệu/N của/E A)_Hai/Np toán_tử/Np mà/C chúng_ta/P cần/V phải_biết/N nữa/R đó/P là/V toán_tử/Np dịch/N bit/Np a/Ni lt;lt;/Np b/Ni và/Cc a/Ni gt;gt;/Np b/Ni ./CH\nToán_tử/Np đầu_tiên/A là/V dịch/N tất_cả/P các/L bit/Np của/E a/Ni sang/V trái/Nc b/Ni vị/Nc trí;/Np Toán_tử/Np thứ_hai/N cũng/R giống_vậy/Np nhưng/C dịch/N sang/V phải/V ./CH\nVới/E những/L giá_trị/N không/R âm/A (cũng/Np là/V những/L số/N duy_nhất/A mà/C ta/P sẽ/R xét/V đến)/Np ,/CH những/L bit/Np mới/R xuất_hiện/V (do/Np dịch/N trái)/Np sẽ/R bằng/E 0/M ./CH\nDịch/N trái/Nc (left-shifting)/Np b/Ni bit/Np đồng_nghĩa/A với/E việc/N nhân/N với/E 2b/Np và/Cc dịch/N phải/V (right-shifting)/Np đồng_nghĩa/A với/E chia/V nguyên/A cho/E 2b/Np ./CH\nDịch/N bit/Np được/V sử_dụng/V nhiều/A nhất/A để/E truy_cập/Np vào/E một/M bit/Np bất_kì/R ,/CH ví_dụ/C ,/CH 1/M lt;lt;/Np x/CH là/V một_số/L nhị_phân/Np với/E bit/Np thứ/N x/CH bằng/E 1/M và/Cc các/L bit/Np khác/A bằng/E 0/M (bit/Np luôn_luôn/R được/V đếm/V từ/E bên/N phải/V (least-significant)/Np ,/CH đếm/V bắt_đầu_từ/Np 0)/Np ./CH\nThông_thường/A ,/CH chúng_ta/P sẽ/R sử_dụng/V một_số/L nguyên/A để/E biểu_diễn/V một_tập/Np hợp/V với/E miền/N giá_trị/N lên/V đến/E 32/M giá_trị/N (hoặc/Np 64/M nếu/C sử_dụng/V số_nguyên/Np 64/M bit)/Np ,/CH với/E bit/Np 1/M cho_biết/V phần_tử/N đó/P có/V trong/E tập_hợp/N và/Cc bit/Np 0/M thì/C không/R có/V ./CH\nSau_đó/Np thì/C các/L phép_toán/Np thì/C không/R có/V gì/P phức_tạp/A ,/CH trong/E đó/P ALL_BITS/Np trả/V về/E số/N bit/Np 1/M ,/CH tương_ứng/V với/E số/N phần_tử/N có/V trong/E tập_hợp/N :/CH Phép_toán/Np hợp/V (Set/Np union)/Np A_B/Np Phép_toán/Np giao/V (Set/Np intersection)/Np A/Ni amp;/Np B/Ni Phép_toán/Np hiệu/N (Set/Np subtraction)/Np A/Ni amp;/Np ~B/Np Phép_toán/Np phủ_định/Np (Set/Np negation)/Np ALL_BIT/Np A_Gán/Np bit/Np bằng/E 1/M (Set/Np bit)/Np A/Ni =/CH 1/M lt;lt;/Np bit/Np Gán/V bit/Np bằng/E 0/M (Clear/Np bit)/Np A/Ni amp;=/Np ~(1/Np lt;lt;/Np bit)/Np Truy_cập/Np giá_trị/N (Test/Np bit)/Np (A/Np amp;/Np 1/M lt;lt;/Np bit)/Np !/CH =/CH 0/M Tách/V từng/R bit/Np Trong/E phần/N này/P ,/CH chúng_ta/P sẽ/R bàn/N đến/E việc/N tìm/V vị_trí/N của/E bit/Np 1/M cao/A nhất/A (bit/Np 1/M nằm/V xa/A nhất/A về/E bên/N trái)/Np và/Cc thấp/A nhất/A (bit/Np 1/M nằm/V xa/A nhất/A về/E bên/N phải)/Np trong/E một_số/L ./CH\nĐây/P là/V những/L phép_toán/Np cơ_bản/A để/E tách/V một_tập/Np hợp/V ra/V thành/V những/L phần_tử/N ./CH\nTìm/V bit/Np 1/M thấp/A nhất/A khá/R là/V đơn_giản/A ,/CH chỉ_cần/Np kết_hợp/V đúng_đắn/A giữa/N toán_tử/Np bit/Np và/Cc phép_toán/Np số_học/Np ./CH\nGiả_sử/Np chúng_ta/P muốn/V tìm/V bit/Np 1/M thấp/A nhất/A của/E số/N x/CH (x/Np khác/A 0)/Np ./CH\nNếu/C chúng_ta/P trừ/V 1/M từ/E x/CH thì/C bit/Np này/P được/V xoá/V ,/CH nhưng/C tất_cả/P các/L bit/Np một/M khác/A vẫn/R còn/R ./CH\nDo_đó/C ,/CH x/CH amp;/Np ~(x/Np -/CH 1)/Np chỉ/R chứa/V duy_nhất/A bit/Np 1/M thấp/A nhất/A của/E x/CH ./CH\nTuy_nhiên/C ,/CH cách/N này/P chỉ/R cho/E chúng_ta/P biết/V giá_trị/N của/E bit/Np đó/P ,/CH không_phải/Np là/V vị_trí/N ./CH\nNếu/C chúng_ta/P muốn/V biết/V vị_trí/N của/E bit/Np 1/M cao/A nhất/A và/Cc thấp/A nhất/A ,/CH cách/N tiếp_cận/V đơn_giản/A nhất/A đó/P là/V duyệt/V qua/V các/L bit/Np (từ/Np trái/Nc qua/V hay/Cc từ/E phải/V qua)/Np cho/E tới/E khi/N tìm/V được/V bit/Np 1/M đầu_tiên/A ./CH\nLúc/N đầu/N ,/CH ta/P có_thể/R cảm_thấy/V cách/N làm/V này/P hơi/R chậm/A vì/E không/R tận_dụng/V được/V lợi_thế/N gì/P về/E bit/Np ./CH\nTuy_nhiên/C ,/CH nếu/C xác_suất/N 2N/Np tập_con/Np của/E miền/N giá_trị_N/Np phần_tử/N đều/R bằng_nhau/Np ,/CH thì/C trung_bình/A vòng_lặp/Np chỉ_cần/Np 2/M lần/N chạy/V ,/CH thật_ra/X đây/P là/V phương_pháp/N nhanh/A nhất/A ./CH\nCPU/Np 386/Np có/V hỗ_trợ/V duyệt/V bit/Np (bit/Np scanning)/Np :/CH BSF/Np (bit/Np scan/Np forward)/Np và/Cc BSR/Np (bit/Np scan/Np reverse)/Np ./CH\nGCC/Np cung_cấp/V những/L hỗ_trợ/V này/P qua/V những/L hàm/Np xây_dựng/V sẵn/A (built-in/Np functions)/Np __builtin_ctz/Np (đếm/Np số/N chữ_số/Np 0/M đứng/V cuối)/Np và/Cc __builtin_clz/Np (đếm/Np số/N chữ_số/Np 0/M đứng/V đầu)/Np ./CH\nĐây/P là/V những/L cách/N tiện_lợi/A nhất/A để/E tìm/V vị_trí/N của/E bit/Np dành/V cho/E lập_trình_viên/Np C++/Np ở/E Topcoder/Np ./CH\nLưu_ý/V :/CH giá_trị/N trả/V về/E là/V undefined/Np nếu/C tham_số/Np đầu_vào/N bằng/E 0/M ./CH\nCuối_cùng/A ,/CH còn/R một/M phương_pháp/N khác/A để/E thay_thế/V trong/E những/L testcase/Np mà/C dùng/V vòng_lặp/Np tốn/V nhiều/A thời_gian/N ./CH\nSử_dụng/V mỗi/L byte/Np của/E số_nguyên/Np 4/M byte/Np hoặc/Cc số_nguyên/Np 8/M byte/Np để/E tính/V trước/E bảng/N 256/Np phần_tử/N lưu_trữ/Np vị_trí/N của/E bit/Np 1/M cao/A nhất/A (thấp/Np nhất)/Np trong/E byte/Np đó/P ./CH\nBit/Np 1/M cao/A nhất/A (thấp/Np nhất)/Np của/E số_nguyên/Np là/V giá_trị/N lớn/A nhất/A (giá/Np trị/V nhỏ/A nhất)/Np của/E bảng/N này/P ./CH\nPhương_pháp/N này/P được/V đề_cập/V đến/E để/E làm/V đa_dạng/A thêm/V các/L phương_pháp/N ,/CH tốc_độ/N cũng/R chưa/R được/V đánh_giá/V rõ_ràng/A qua/V các/L kì_thi/Np Topcoder/Np ./CH\nĐếm_số/Np bit/Np Chúng_ta/P có_thể/R dễ_dàng/A kiểm_tra/V một_số/L có_phải/Np là/V luỹ_thừa/Np của/E 2/M bằng/E cách/N xoá/V bit/Np 1/M thấp/A nhất/A và/Cc kiểm_tra/V xem/V nếu/C kết_quả/N có/V bằng/E 0/M chưa/R ./CH\nTuy_nhiên/C ,/CH trong/E một_số/L trường_hợp/N chúng_ta/P cần/V phải_biết/N có/V bao_nhiêu/P bit/Np đã/R được/V set/N (bit/Np đã/R được/V set/N là/V bit/Np 1/M ,/CH bit/Np chưa/R được/V set/N là/V bit/Np bằng/E 0)/Np ,/CH chúng_ta/P cần/V phải/V thực_hiện/V nhiều/A việc/N phức_tạp/A hơn/A tí/N ./CH\nGCC/Np có_một/Np hàm/Np gọi_là/V __builtin_popcount/Np thực_hiện/V đúng/A những/L thứ/N ta/P cần/V ./CH\nTuy_nhiên/C ,/CH không/R giống_như/Np hàm/Np __builtin_ctz/Np ,/CH nó/P không/R được/V chuyển/V thành/V những/L chỉ_thị/N trên/E phần_cứng/Np (ít/Np nhất_là/X trên/E x86)/Np ./CH\nThay/V vào/E đó/P ,/CH nó/P sẽ/R sử_dụng/V phương_pháp/N lưu/V bảng/N giống_như/Np trên/E đã/R trình_bày/V để/E tìm_kiếm/V bit/Np ./CH\nPhương_pháp/N này/P khá/R là/V hiệu_quả/N và/Cc cũng/R cực_kì/R tiện_lợi/A ./CH\nNhững/L người/N dùng/V các/L ngôn_ngữ/N khác/A không_thể/R dùng/V cách/N này/P (mặc/Np dù/C họ/P có_thể/R cài_đặt/V lại/R nó)/Np ./CH\nNếu/C một_số/L được/V dự_đoán/V rằng/C có/V rất/R ít/A bit/Np 1/M ,/CH một/M phương_pháp/N thay_thế/V là/V chỉ_cần/Np lặp_lại/Np quá_trình/N tìm/V bit/Np 1/M thấp/A nhất/A và/Cc xoá/V nó/P ./CH\nTất_cả/P các/L tập_con/Np Một/M ưu_điểm/N lớn/A của/E thao_tác/V bit/Np là/V việc/N duyệt/V qua/V tất_cả/P các/L tập_con/Np của/E một_tập/Np hợp/V N/Ny phần_tử/N rất/R đơn_giản/A :/CH mỗi/L số_nguyên/Np đại_diện/N cho/E một_tập/Np con/Nc ./CH\nHơn_thế_nữa/Np ,/CH nếu/C A/Ni là/V tập_con/Np của/E B/Ni thì/C số_nguyên/Np đại_diện/N cho/E A/Ni sẽ/R nhỏ/A hơn/A số_nguyên/Np đại_diện/N cho/E B/Ni ,/CH rất/R tiện_lợi/A cho/E việc/N kết_hợp/V với/E quy_hoạch_động/Np ./CH\nViệc/N duyệt/V qua/V tất_cả/P các/L tập_con/Np của/E một_tập/Np con/Nc khác/A cũng/R rất/R dễ_dàng/A (được/Np biểu_diễn/V bằng/E một/M dãy/Nc bit)/Np ,/CH nếu/C bạn/N không/R quan_tâm/V đến/E thứ_tự/N duyệt/V ngược_lại/X (hoặc/Np có_thể/R lưu/V các/L tập_hợp/N vào/E một/M danh_sách/N và/Cc đi/V ngược/A lại)/Np ./CH\nMẹo/N được/V sử_dụng/V cũng/R giống_như/Np việc/N tìm/V bit/Np 1/M thấp/A nhất/A vậy/P ./CH\nNếu/C chúng_ta/P trừ/V đi/V 1/M từ/E tập_con/Np ,/CH thì/C phần_tử/N đại_diện/N bởi/E bit/Np 1/M đó/P sẽ/R được/V xoá/V ,/CH và/Cc mỗi/L phần_tử/N 0/M phía/N bên/N phải/V nó/P đều/R trở_thành/V 1/M ./CH\nTuy_nhiên/C ,/CH chúng_ta/P chỉ/R muốn/V các/L phần_tử/N được/V chọn/V là/V những/L phần_tử/N có/V trong/E tập/V cha/N ./CH\nNên/C bước/V lặp/V chỉ_cần/Np thay_thế/V ngắn_gọn/A bằng/E i/M =/CH (i/Np -/CH 1)/Np amp;/Np superset/Np ./CH\nCài_đặt/V :/CH //CH xét/V tất_cả/P các/L tập_con/Np khác/A rỗng/A của/E S/Y for/Np (/CH int/Np i/M =/CH S/Y ;/CH i/M gt;/Np 0/M ;/CH i/M =/CH (/CH i/M -/CH 1/M )/CH amp;/Np S/Y );/CH Chỉ_cần/Np một/M bit/Np sai/A cũng/R 0/M điểm/N Có_một/Np số/N lỗi/N mà/C mọi/L người_thường/Np mắc_phải/Np khi/N sử_dụng/V các/L thao_tác/V bit/Np ./CH\nChú_ý/V cẩn_thận/A với/E code/Np của/E bạn/N ./CH\nKhi/N thực_hiện/V phép_toán/Np dịch/N ,/CH a/Ni lt;lt;/Np b/Ni ,/CH kiến_trúc/V x86/Np chỉ/R sử_dụng/V the/B 5/M bit/Np thấp/A nhất/A của/E b/Ni (6/Np cho/E số_nguyên/Np 64/M bit)/Np ./CH\nĐiều/N này/P có_nghĩa/A là/V dịch/N trái/Nc (hoặc/Np phải)/Np 32/M bit/Np đồng_nghĩa_là/Np không/R làm_gì/X cả/P ,/CH ngoài/E việc/N xoá/V tất_cả/P các/L bit/Np ./CH\nViệc/N này/P cũng/R được/V nhắc/V đến/E trong/E Java/Np và/Cc C;_C99/Np đề_cập/V rằng/C việc/N dịch/N ít_nhất/A bằng/E giá_trị/N của/E số/N sẽ/R trả/V về/E kết_quả/N là/V undefined/Np ./CH\nLịch_sử/N :/CH máy/N 8086/Np sử_dụng/V full/Np shift/Np register/Np ,/CH thường/R thao_tác/V này/P còn/R được/V dùng/V để/E kiểm_tra/V processor/Np mới/R ./CH\nToán_tử/Np amp;/Np và/Cc có/V độ/N ưu_tiên/V thực_hiện/V thấp/A hơn/A phép/N so_sánh/V ./CH\nĐiều/N đó/P có_nghĩa/A là/V x/CH amp;/Np 3/M ==/Np 1/M bằng/E với/E x/CH amp;/Np (3/Np ==/Np 1)/Np ,/CH đây/P là/V những/L lỗi/N bạn/N không_hề/Np muốn/V mắc_phải/Np ./CH\nNếu/C bạn/N muốn/V viết/V những/L dòng/N code/Np C/Ni dùng/V ở/E nhiều/A nơi/N ,/CH hãy/R đảm_bảo/V rằng/C bạn/N sử_dụng/V kiểu/N unsigned/Np ,/CH cụ_thể/A trong/E trường_hợp/N bạn/N có_ý/Np định/V sử_dụng/V bit/Np cao/A nhất/A (top-most)/Np ./CH\nC99/Np nói/V rằng/C dịch/N bit/Np trên/E giá_trị/N âm/A sẽ/R trả/V về/E undefined/Np ./CH\nJava/Np chỉ_có/Np kiểu/N dữ_liệu/N có/V dấu/N :/CH gt;gt;/Np sẽ/R tự_động/A thay_đổi/V dấu/N của/E giá_trị/N nếu_cần/Np thiết/N (nhưng/Np đây/P là/V thứ/N bạn/N thường/R không/R muốn/V xảy/V ra)/Np ,/CH nhưng/C toán_tử/Np đặc_biệt/A này/P của/E Java/Np là/V gt;gt;gt;/Np sẽ/R thêm/V các/L số/N 0/M vào/E phía/N trước_sau/Np khi/N dịch/N ./CH\nMột_số/L mẹo/N hay/Cc (và/Np cute)/Np Có_một/Np số/N mẹo/N hay/Cc có_thể/R sử_dụng/V với/E thao_tác/V bit/Np ./CH\nNhững/L mẹo/N này/P khá/R hay/Cc để/E đem/V đi_chém/Np gió/N với/E bạn_bè/N ,/CH nhưng/C thông_thường/A hiệu_quả/N cũng/R không/R cải_thiện/V lắm/R ở/E thực_tế/N ./CH\nĐảo/N thứ_tự/N các/L bit/Np trong/E một_số/L nguyên/A x/CH =/CH ((x/Np amp;/Np 0xaaaaaaaa)/Np gt;gt;/Np 1)/Np ((x/Np amp;/Np 0x55555555)/Np lt;lt;/Np 1);/Np x/CH =/CH ((x/Np amp;/Np 0xcccccccc)/Np gt;gt;/Np 2)/Np ((x/Np amp;/Np 0x33333333)/Np lt;lt;/Np 2);/Np x/CH =/CH ((x/Np amp;/Np 0xf0f0f0f0)/Np gt;gt;/Np 4)/Np ((x/Np amp;/Np 0x0f0f0f0f)/Np lt;lt;/Np 4);/Np x/CH =/CH ((x/Np amp;/Np 0xff00ff00)/Np gt;gt;/Np 8)/Np ((x/Np amp;/Np 0x00ff00ff)/Np lt;lt;/Np 8);/Np x/CH =/CH ((x/Np amp;/Np 0xffff0000)/Np gt;gt;/Np 16)/Np ((x/Np amp;/Np 0x0000ffff)/Np lt;lt;/Np 16);/Np Bài_tập/Np là/V bạn/N hãy/R dùng/V kĩ_thuật/N phía/N trên/E để/E đếm_số/Np bit/Np với/E kiểu/N dữ_liệu/N word/Np ./CH\nDuyệt/V qua/V tất_cả/P các/L tập_con/Np có/V k/N phần_tử/N int/Np s/Y =/CH (1/Np lt;lt;/Np k)/Np -/CH 1;/Np while/Np (/CH !/CH (s/Np amp;/Np 1/M lt;lt;/Np N))/Np //CH gì/P đó/P với/E s/Y int/Np lo/V =/CH s/Y amp;/Np ~(s/Np -/CH 1);/Np //CH 1/M thấp/A nhất/A int/Np lz/Np =/CH (s/Np +/CH lo)/Np amp;/Np ~s;/Np //CH 0/M thấp/A nhất/A trên/E lo/V s/Y =/CH lz;/Np //CH lz/Np vào/E tập_hợp/N s/Y amp;=/Np ~(lz/Np -/CH 1);/Np //CH bit/Np phía/N dưới/E lz/Np s/Y =/CH (lz/Np //CH lo/V //CH 2)/Np -/CH 1;/Np //CH lại/R đúng/A số/N bit/Np ở/E cuối/N Trong_C/Np ,/CH dòng/N cuối/N có_thể/R viết/V là/V s/Y =/CH (lz/Np gt;gt;/Np ffs(lo))/Np -/CH 1/M để/E tránh/V phép_chia/Np ./CH\nXác_định/V x/CH ?/CH\ny/N :/CH -y/Np ,/CH trong/E đó/P x/CH bằng/E 0/M hoặc/Cc 1/M (-x/Np y)/Np +/CH x/CH Câu_lệnh/Np trên/E chạy/V được/V trên/E kiến_trúc/V số/N bù/V 2/M (tồn/Np tại/E ở/E hầu_hết/R các/L máy_tính/N bạn/N thấy/V ngày/N nay)/Np ,/CH trong/E đó/P số_âm/Np được/V biểu_diễn/V bằng/E cách/N đảo/N tất_cả/P các/L bit/Np và/Cc cộng/V thêm/V cho/E 1/M ./CH\nChú_ý/V rằng/C trên/E i686/Np và/Cc trước/E đó/P ,/CH câu_lệnh/Np này/P chạy/V khá/R hiệu_quả/N (không/Np cần/V rẽ/V nhánh/N )/CH nhờ/V vào/E lệnh/N CMOVE/Np (di/Np chuyển/V có_điều/X kiện)/Np ./CH\nBài_tập/Np mẫu/N TCCC/Np 2006/M ,/CH Round/Np 1B/Np Medium_Với/Np mỗi/L thành_phố/N ,/CH giữ/V một/M bit-set/Np của/E những/L thành_phố/N kề/V nó/P ./CH\nMột_khi/X một/M phần/N của/E nhà_máy/N đã/R được/V chọn/V (đệ/Np quy)/Np ,/CH AND/Np những/L bit-set/Np đó/P lại/R sẽ/R cho/E ra/V một/M bit-set/Np mới/R mô_tả/V những/L vị_trí/N có_thể/R của/E những/L phần/N của/E nhà_máy/N ./CH\nNếu/C bit-set/Np này/P có/V k/N bit/Np ,/CH thì_có/X Ck_m/Np cách/N để/E chọn/V các/L phần/N của/E nhà_máy/N ./CH\nTCO/Np 2006/M ,/CH Round/Np 1/M Easy/Np Số_lượng/N nút/N nhỏ/A cho/E thấy/V rằng/C bài/N này/P có_thể/R giải_quyết/V bằng/E việc/N xét/V tất_cả/P các/L tập_con/Np ./CH\nVới/E mỗi/L tập_con/Np ta/P xét/V 2/M trường_hợp/N :/CH nút/N nhỏ/A nhất/A không/R có/V trao_đổi/V gì/P cả/P ,/CH trong/E trường_hợp/N ta/P xét/V tập_con/Np mà/C không/R có/V nó/P ,/CH hoặc/Cc nó/P trao_đổi/V với/E một_số/L nút/N ,/CH ta/P sẽ/R xét/V các/L tập_hợp/N không/R có/V nó/P và/Cc các/L nút/N mà/C nó/P trao_đổi/V ./CH\nCode/Np bài_giải/Np rất/R ngắn_gọn/A :/CH static/Np int/Np dp1/Np lt;lt;/Np 18;/Np int/Np SeparateConnections/Np :/CH :/CH howMany(vector/Np lt;stringgt;/Np mat)/Np int/Np N/Ny =/CH mat/Np ./CH size();/Np int/Np N2/Np =/CH 1/M lt;lt;/Np N;/Np dp0/Np =/CH 0;/Np for/Np (int/Np i/M =/CH 1;/Np i/M lt;/Np N2;/Np i++)/Np int/Np bot/Ny =/CH i/M amp;/Np ~(i/Np -/CH 1);/Np int/Np use/Np =/CH __builtin_ctz(bot);/Np dpi/Np =/CH dpi/Np bot;/Np for/Np (int/Np j/Np =/CH use/Np +/CH 1;/Np j/Np lt;/Np N;/Np j++)/Np if/Np ((i/Np amp;/Np (1/Np lt;lt;/Np j))/Np amp;amp;/Np matusej/Np ==/Np Y)/Np dpi/Np =/CH max(dpi/Np ,/CH dpi/Np bot/Ny (1/Np lt;lt;/Np j)/Np +/CH 2);/Np return/Np dpN2/Np -/CH 1;/Np SRM/Np 308/Np ,/CH Division_Medium_Cái/Np bảng/N chứa/V 36/M hình_vuông/N và/Cc những/L con_cờ/Np không_thể/R phân_biệt/V được/V ,/CH nên/C những/L vị_trí/N có_thể/R được/V mã_hoá/Np vào/E số_nguyên/Np 64/M bit/Np ./CH\nBước_đầu/N tiên/N là/V liệt_kê/V tất_cả/P các/L bước_đi/N hợp_lệ/A ./CH\nBất_kì/R bước_đi/N hợp_lệ/A nào/P cũng/R đều/R được/V mã_hoá/Np sử_dụng/V 3/M trường/N :/CH 1/M trạng_thái/N trước/E ,/CH 1/M trạng_thái/N sau/E và/Cc một/M mask/Np dùng/V để/E định_nghĩa/N phần_nào/L của/E trạng_thái/N trước/E là/V quan_trọng/A ./CH\nMột_bước/Np đi/V có_thể/R được/V tạo/V ra/V từ/E trạng_thái/N hiện_tại/N nếu/C (current/Np amp;/Np mask)/Np ==/Np before/Np ./CH\nNếu/C nó/P được/V tạo/V ra/V ,/CH thì/C trạng_thái/N mới/R là/V (current/Np amp;/Np ~mask)/Np after/Np ./CH\nSRM/Np 320/Np ,/CH Division/Np 1/M Hard/Np Điều_kiện/N cho/E ta/P biết/V rằng/C chỉ_có/Np nhiều/A nhất/A 8/M cột/N (nếu/Np có/V nhiều/A hơn/A ,/CH ta/P có_thể/R đổi/V giữa/N dòng/N và/Cc cột)/Np ,/CH nên/C chúng_ta/P có_thể/R xét/V từng/R cách/N để/E một/M dòng/N ./CH\nMột_khi/X chúng_ta/P có/V thông_tin/N này/P ,/CH ta/P có_thể/R giải_quyết/V vấn_đề/N còn_lại/Np của/E bài_toán/N (xem/Np tutorial/Np để/E biết/V thêm/V chi/V tiết)/Np ./CH\nDo_đó/C ta/P cần/V một/M danh_sách/N tất_cả/P số_nguyên/Np n/Ny bit/Np mà/C không/R có/V 2/M bit/Np 1/M kề/V nhau/N ,/CH và/Cc ta/P cũng/R cần/V biết_có/Np bao_nhiêu/P bit/Np 1/M trong/E mỗi/L dòng/N như_vậy/X ./CH\nĐây/P là/V code/Np của/E mình/P :/CH for/Np (int/Np i/M =/CH 0;/Np i/M lt;/Np (1/Np lt;lt;/Np n);/Np i++)/Np if/Np (i/Np amp;/Np (i/Np lt;lt;/Np 1))/Np continue;/Np pg/Np ./CH push_back(i);/Np pgb/Np ./CH push_back(__builtin_popcount(i));/Np\n", "title": "Fun with Bits\n", "link": "http://vnoi.info/wiki/translate/topcoder/fun-with-bits\n"}