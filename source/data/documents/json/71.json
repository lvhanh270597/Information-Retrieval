{"content": "Tác_giả : Vũ_chipchip Phúc_Hoàng_A : \"Mày AC bài Z kiểu gì thế ?\nTao dùng set không được . \" B : \"Dễ mà mày , tao code Splay thôi .\n400 dòng 20 phút ez gg . \" A : \"-_-\" Câu_chuyện thật tưởng như đùa trên cũng không_phải là hiếm gặp .\nSplay_Tree (hay nói rộng hơn , Balanced_Binary_Search_Tree) là một cấu_trúc dữ_liệu toàn_năng có_thể giải_quyết rất nhiều bài_toán , tuy_nhiên nó cũng là một thứ đáng khiếp_sợ đối_với dân competitive programmers vì độ khó code của nó .\nTrong một contest với áp_lực thời_gian căng_thẳng , chẳng_mấy ai dám code Balanced_Binary_Search_Tree và còn đảm_bảo code không bị bug nữa .\nTuy_nhiên , bạn không_thể hoàn_toàn tránh được nó , vẫn có những bài mà những thư_viện có_sẵn như std : : set hay những cấu_trúc đơn_giản như Segment_Tree , Fenwick_Tree không_thể giải được , và bạn vẫn phải nhờ_cậy đến Splay_Tree trong nỗi tuyệt_vọng .\nMay_mắn thay , dân competitive programmers đã tìm_ra cách sử_dụng Skip_Lists như một sự thay_thế cho Balanced_Binary_Search_Tree .\nSkip_Lists với ý_tưởng hết_sức đơn_giản dễ nhớ , cộng thêm với khả_năng tùy_biến tuyệt_vời đã phần_nào làm xua_tan đi nỗi sợ code khó bug nhiều (trừ khi bạn có trình_độ Da xua thượng thừa như nhân_vật B trong đoạn hội_thoại trên; trong trường_hợp đó , bạn có_thể bỏ_qua bài viết này) .\nBài viết này sẽ giới_thiệu cho các bạn những ý_tưởng và cách sử_dụng Skip_Lists cơ_bản nhất .\nTable of_Contents Bài_toán cơ_bản Các hướng tiếp_cận Ý_tưởng Skip_Lists So_sánh các cấu_trúc dữ_liệu Hướng_dẫn chi_tiết Mở_rộng Lời kết Bài_toán cơ_bản Hãy lập_trình một cấu_trúc dữ_liệu S có_thể thực_hiện các thao_tác sau : Chèn một phần_tử x vào S .\nXóa_một phần_tử x khỏi S .\nCho một phần_tử x , tìm một phần_tử gần x nhất trong S .\nCác hướng tiếp_cận Ta sẽ xét một_số cấu_trúc dữ_liệu (chưa đề_cập đến Skip_Lists) sử_dụng để giải bài_toán cơ_bản trên : Sorted_Array : Biểu_diễn S là một mảng các phần_tử .\nCác phần_tử trong mảng được sắp_xếp theo thứ_tự tăng dần .\nChèn : Dịch tất_cả các phần_tử bên phải vị_trí cần chèn sang phải một chỉ_số , rồi chèn phần_tử cần chèn vào vị_trí đó .\nXóa : Dịch tất_cả các phần_tử bên phải phần_tử bị xóa sang trái một chỉ_số .\nTìm : Tìm_kiếm nhị_phân phần_tử .\nĐộ phức_tạp : O(Nlog(N)) với thao_tác khởi tạo , O(N) với thao_tác chèn/xóa , O(log(N)) với thao_tác tìm_kiếm .\nSorted_Linked_List : Biểu_diễn S là một danh_sách liên_kết chứa các phần_tử .\nCác phần_tử trong danh_sách liên_kết được sắp_xếp theo thứ_tự tăng dần .\nChèn : Thay_đổi liên_kết giữa phần_tử cần chèn , phần_tử đứng trước , và phần_tử đứng sau .\nXóa : Thay_đổi liên_kết giữa phần_tử cần chèn , phần_tử đứng trước , và phần_tử đứng sau .\nTìm : Duyệt_S từ_đầu đến cuối .\nĐộ phức_tạp : O(N) với các thao_tác chèn/xóa/tìm .\nO(Nlog(N)) với thao_tác khởi tạo .\nBinary_Search_Tree : Biểu_diễn S là một cây nhị_phân tìm_kiếm chứa các phần_tử .\nCây này có tính_chất tất_cả các nút thuộc cây_con bên trái đều nhỏ hơn nút cha , và tất_cả các nút thuộc cây_con bên phải đều lớn hơn nút cha .\nChèn (Nhiều cách làm) : Đi từ trên gốc xuống , so_sánh phần_tử được chèn với hai nút con , nếu có thì đi_vào nút con , còn không thì thêm một nút vào cây_chứa phần_tử cần chèn .\nXóa (Nhiều cách làm) : Thay nút bị xóa bằng nút lớn nhất của cây_con bên trái (và xóa nút đó đi) , nếu_không có cây_con bên trái thì thay bằng nút nhỏ nhất của cây_con bên phải , nếu_không có_con thì đơn_giản là xóa đi .\nTìm : Đi từ trên gốc xuống , so_sánh phần_tử cần tìm với hai nút con , đi_vào cây_con chứa nút cần tìm , cứ thế đến khi tìm được .\nĐộ phức_tạp : Với trường_hợp trung_bình , các thao_tác này có độ phức_tạp O(log(N)) .\nCòn với trường_hợp xấu nhất_là O(N) .\nBalanced_Binary_Search_Tree : Giống_Binary_Search_Tree , nhưng cây có thêm cơ_chế tự cần bằng để tránh việc cây bị suy_biến , luôn giữ chiều_cao cây ở mức ổn_định (thường là O(log(N)) .\nLưu_ý : Thao_tác chèn và xóa đều phải đi_qua thao_tác tìm .\nTa nhận_thấy mỗi cấu_trúc dữ_liệu kể_trên đều có nhược_điểm của nó .\nSorted_Array có thao_tác chèn xóa chậm , Sorted_Linked_List có thao_tác tìm chậm , Binary_Search_Tree có_thể bị suy_biến về chiều_cao làm_cho cả 3 thao_tác đều chậm , Balanced_Binary_Search_Tree hoàn_hảo nhưng lại quá phức_tạp để cài_đặt trong giới_hạn thời_gian của competitive programming .\nTừ_đó , Skip_Lists , một phiên_bản nâng_cấp của Sorted_Linked_List , được sử_dụng trong competitive programming như một sự thay_thế cho Balanced_Binary_Search_Tree .\nVề tộc độ và bộ_nhớ , Skip_Lists không thua gì Balanced_Binary_Search_Tree , tuy_nhiên lại dễ cài_đặt hơn rất nhiều .\nÝ_tưởng Skip_Lists_Skip_Lists là một phiên_bản nâng_cấp của Sorted_Linked_Lists .\nTa hãy bắt_đầu với một ví_dụ về Sorted_Linked_List chứa 8 số và nghĩ cách cải_thiện vấn_đề của nó .\nSorted_Linked_List có ưu_điểm lớn khi thao_tác chèn xóa chỉ mất O(1) (ta chỉ việc chỉnh_sửa liên_kết giữa phần_tử được chèn/xóa và các phần_tử đằng trước/sau) .\nTuy_nhiên thao_tác tìm_kiếm lại mất O(N) do phải duyệt từ_đầu đến cuối .\nMột ý_tưởng để cân_bằng điều này là ta thêm nhiều tầng liên_kết , cứ lên một tầng số liên_kết lại giảm còn một_nửa .\nKhi tìm phần_tử , ta sẽ duyệt từ trái sang phải nhưng sẽ nhảy_xa hơn nhờ những liên_kết trên các tầng cao , khi_nào không nhảy được mới xuống tầng thấp hơn .\nÝ_tưởng này khá giống với phương_pháp nhảy lên tổ_tiên thứ 2K khi tìm Lowest_Common_Ancestor (LCA) .\nTrong hình trên , để tìm số 7 , ta sẽ nhảy thẳng từ 0 đến 5 bằng liên_kết trên tầng thứ_ba , sau_đó nhảy từ 5 đến 6 bằng liên_kết trên tầng thứ nhất .\nTa tìm được 6 là số gần nhất với 7 .\nVới cấu_trúc này , ta có_thể thực_hiện thao_tác tìm trong O(log(N)) .\nTuy_nhiên việc chèn và xóa_một phần_tử vào sẽ làm thay_đổi cấu_trúc này .\nChẳng_hạn nếu ta chèn số 7 : Như hình trên , cấu_trúc của ta không còn \"chuẩn\" , có_nghĩa là chính_xác tầng thứ nhất liên_kết cách 20 , tầng thứ_hai liên_kết cách 21 , tầng thứ_ba liên_kết cách 22 , . . .\nTuy_nhiên , với cấu_trúc như hình trên vẫn chạy tốt - chỉ_có điều ở mỗi tầng_ta có_thể phải nhảy nhiều hơn một_lần (chẳng hạn , muốn tìm số 7 , ở tầng thứ nhất ta phải nhảy đến hai lần 5 ~gt; 6 ~gt; 7) .\nTừ_đó ta có nhận_xét sau : Các liên_kết trên mỗi tầng không nhất_thiết phải chuẩn , tuy_nhiên , nếu các độ_dài giữa các liên_kết xấp_xỉ nhau và số liên_kết ở tầng trên xấp_xỉ bằng nửa số liên_kết ở tầng dưới , thuật_toán tìm_kiếm vẫn chạy tốt và không mất quá nhiều lần nhảy ở mỗi tầng .\nTa sẽ duy_trì cấu_trúc này bằng kĩ_thuật tung đồng xu ngẫu_nhiên : Mỗi lần chèn một nút vào , đầu_tiên_ta xây_dựng liên_kết ở tầng thứ nhất cho nó .\nSau_đó ta tung đồng xu , nếu ngửa thì ta xây_dựng liên_kết ở tầng trên và tiếp_tục tung đồng xu , còn nếu sấp ta dừng việc xây_dựng liên_kết lại .\nĐây chính là Skip_Lists - một cấu_trúc dữ_liệu được xây_dựng bằng nhiều tầng Sorted_Linked_List được xây_dựng một_cách ngẫu_nhiên , trong đó tầng cao chứa những bước nhảy_dài hơn và tầng thấp chứa những bước nhảy ngắn hơn .\nSkip_Lists cho_phép ta thực_hiện thao_tác tìm_kiếm với độ phức_tạp xấp_xỉ O(log(N)) .\nSo_sánh các cấu_trúc dữ_liệu Hướng_dẫn chi_tiết Học phải đi_đôi với hành .\nCách hiểu lý_thuyết nhanh nhất_là đập ngay vào bài_tập .\nTa sẽ đi chi_tiết vào cách sử_dụng Skip_Lists để giải bài CPPSET .\nBạn hãy đọc đề và ngẫm_nghĩ một_lúc trước_khi đọc_tiếp bài viết này .\nBài_giải ở dưới được code_bằng ngôn_ngữ C++98 .\nCPPSET , đúng như tên_gọi của nó , bạn có_thể AC trong một nốt_nhạc nếu sử_dụng std : : set của C++ , một container đã được code sẵn bằng Reb-Black_Tree (một loại Balanced_Binary_Search_Tree) để thực_hiện bài_toán cơ_bản nêu ở đầu .\nĐể luyện_tập , ta sẽ tự code một cái set \"dỏm\" bằng Skip_Lists .\nTrước_tiên ta cần xây_dựng các struct biểu_diễn Skip_Lists .\nTa sẽ có 3 struct : SkipLists , Column , Cell .\nSkipLists là một danh_sách các Column liên_kết với_nhau .\nColumn là một cột gồm các Cell , biểu_diễn cho cột liên_kết của một phần_tử trong set của ta với các phần_tử đằng_trước và đằng_sau .\nCell là một liên_kết cơ_bản nhất trên một tầng của Column , chứa hai liên_kết đến Column đằng_trước và đằng_sau .\nĐể_cho dễ_hiểu , bạn hãy xem hình dưới .\nstruct SkipLists static const int MAX_LEVEL = 20 ; // Giới_hạn số tầng , nên chọn một_số khoảng log(N) Column head , tail ; // thêm 2 cột không có_giá trị vào đầu và cuối để dễ xử_lí ; struct Column int value ; vector lt; Cell gt; cells ; ; struct Cell_Column previous_column , next_column ; // Mỗi_Cell có hai liên_kết đến Column đằng_trước và đằng_sau (không giống trong hình chỉ_vẽ một liên_kết về đằng_sau cho_đơn giản) ; Sau khi đã biết cách biểu_diễn dữ_liệu , ta sẽ code các hàm cho SkipLists .\nSet \"dỏm\" của chúng_ta sẽ gồm 6 hàm sau : struct SkipLists static const int MAX_LEVEL = 20 ; Column head , tail ; SkipLists (); // Khởi tạo bool empty (); // Kiểm_tra SkipLists có rỗng_không Column lower_bound ( int ); // Tìm vị_trí Column chứa giá_trị nhỏ nhất không nhỏ hơn giá_trị cần tìm Column upper_bound ( int ); // Tìm vị_trí Column chứa giá_trị nhỏ nhất lớn hơn giá_trị cần tìm void insert ( int ); // Chèn một phần_tử mang giá_trị cho trước vào SkipLists void erase ( int ); // Xóa_một phần_tử mang giá_trị cho trước khỏi SkipLists ; Ta sẽ bắt_đầu với constructor SkipLists() .\nĐể khởi tạo SkipLists , ta sẽ tạo ra hai cột head và tail có chiều_cao là số tầng tối_đa , và tại liên_kết giữa head và tail trên tất_cả các Cell .\nSkipLists : : SkipLists () head = new Column ; tail = new Column ; head -gt; value = 0 ; tail -gt; value = 0 ; for ( int i = 0 ; i lt; MAX_LEVEL ; i ++ ) head -gt; cells .\npush_back (( Cell ) NULL , tail ); tail -gt; cells .\npush_back (( Cell ) head , NULL ); Với hàm empty() , ta chỉ đơn_giản kiểm_tra liên_kết cấp 0 (liên kết trực tiếp) của head có nối với tail không .\nbool SkipLists : : empty () return head -gt; cells 0 .\nnext_column == tail ; Với hàm lower_bound() , ta sẽ đi từ tầng cao nhất đến tầng thấp nhất , chừng_nào nhảy về phía trước vẫn vào một phần_tử có_giá trị nhỏ hơn giá_trị cần tìm thì ta cứ nhảy .\nSau khi duyệt , ta sẽ đứng ở phần_tử lớn nhất có_giá trị nhỏ hơn giá_trị cần tìm .\nTa nhảy trên liên_kết cấp 0 một_lần nữa để lấy_được lower_bound() .\nColumn_SkipLists : : lower_bound ( int value ) Column iter = head ; for ( int level = MAX_LEVEL - 1 ; level gt;= 0 ; level -- ) while ( iter -gt; cells level .\nnext_column ! = tail amp;amp; iter -gt; cells level .\nnext_column -gt; value lt; value ) iter = iter -gt; cells level .\nnext_column ; return iter -gt; cells 0 .\nnext_column ; Hàm upper_bound() không khác_gì lower_bound() , ngoại_trừ việc thay dấu lt; thành lt;= lúc so_sánh với value .\nColumn_SkipLists : : upper_bound ( int value ) Column iter = head ; for ( int level = MAX_LEVEL - 1 ; level gt;= 0 ; level -- ) while ( iter -gt; cells level .\nnext_column ! = tail amp;amp; iter -gt; cells level .\nnext_column -gt; value lt;= value ) iter = iter -gt; cells level .\nnext_column ; return iter -gt; cells 0 .\nnext_column ; Với hàm insert() , ta sẽ chia thành 3 bước sau : Sử_dụng lower_bound() để kiểm_tra giá_trị đã tồn_tại trong SkipLists chưa .\nNếu đã tồn_tại , thoát_khỏi hàm .\nTạo ra một Column mới để chèn vào SkipLists .\nTa sẽ sử_dụng hàm rand() để tung đồng xu , xây_dựng chiều_cao cho Column này .\nChèn_Column vào SkipLists .\nTa duyệt_y_như trong lower_bound() và upper_bound() , ở mỗi tầng chèn liên_kết với Column vào hai cột đằng_sau và đằng_trước Column .\nvoid SkipLists : : insert ( int value ) // Kiểm_tra value đã tồn_tại chưa Column temp = lower_bound ( value ); if ( temp ! = tail amp;amp; temp -gt; value == value ) return ; // Tạo inserted_column là cột chứa value để chèn vào SkipLists_Column inserted_column = new Column ; inserted_column -gt; value = value ; inserted_column -gt; cells .\npush_back (( Cell ) NULL , NULL ); // Tung đồng xu tăng chiều_cao while ( inserted_column -gt; cells .\nsize () lt; MAX_LEVEL amp;amp; rand () % 2 == 0 ) inserted_column -gt; cells .\npush_back (( Cell ) NULL , NULL ); // Duyệt để chèn Column iter = head ; for ( int level = MAX_LEVEL - 1 ; level gt;= 0 ; level -- ) while ( iter -gt; cells level .\nnext_column ! = tail amp;amp; iter -gt; cells level .\nnext_column -gt; value lt; value ) iter = iter -gt; cells level .\nnext_column ; if ( level lt; inserted_column -gt; cells .\nsize ()) // Nối iter với inserted_column , nối inserted_column với next_iter Column next_iter = iter -gt; cells level .\nnext_column ; iter -gt; cells level .\nnext_column = inserted_column ; next_iter -gt; cells level .\nprevious_column = inserted_column ; inserted_column -gt; cells level .\nprevious_column = iter ; inserted_column -gt; cells level .\nnext_column = next_iter ; Với hàm erase() , ta sẽ chia thành 3 bước sau : Sử_dụng lower_bound() để kiểm_tra giá_trị đã tồn_tại trong SkipLists chưa .\nNếu_không tồn_tại , thoát_khỏi hàm .\nXóa cột chứa giá_trị cần xóa_khỏi SkipLists bằng cách nối từng liên_kết giữa các Cell liền trước và liền sau nó trên từng tầng .\nXóa cột chứa giá_trị cần xóa để giải_phóng bộ_nhớ .\nvoid SkipLists : : erase ( int value ) // Kiểm_tra value đã tồn_tại chưa Column erased_column = lower_bound ( value ); if ( erased_column == tail erased_column -gt; value ! = value ) return ; // Duyệt để xóa Column iter = head ; for ( int level = MAX_LEVEL - 1 ; level gt;= 0 ; level -- ) while ( iter -gt; cells level .\nnext_column ! = tail amp;amp; iter -gt; cells level .\nnext_column -gt; value lt;= value ) iter = iter -gt; cells level .\nnext_column ; if ( iter == erased_column ) // Nối previous_iter với next_iter Column previous_iter = iter -gt; cells level .\nprevious_column , next_iter = iter -gt; cells level .\nnext_column ; previous_iter -gt; cells level .\nnext_column = next_iter ; next_iter -gt; cells level .\nprevious_column = previous_iter ; delete erased_column ; Với 6 hàm trên , bạn đã có_thể mô_phỏng một_cách đơn_giản một cái set \"dỏm\" để giải bài này .\nBạn hãy thử tự làm tiếp và nộp trên SPOJ nhé .\nToàn_bộ code cho bài CPPSET có_thể xem ở đây .\nMở_rộng Ở trên mới là một code Skip_Lists đơn_giản nhất mô_phỏng std : : set để giải bài CPPSET .\nLiệu bạn có_thể code lại một std : : set hoàn_hảo bằng Skip_Lists không ?\nHãy thử xem ! Code trên sử_dụng cả liên_kết xuôi ( next_column ) và liên_kết ngược ( previous_column ) để dễ xử_lí .\nBạn có_thể code lại CPPSET mà không cần sử_dụng liên_kết ngược không ?\nKhi xây_dựng cột để chèn vào Skip_Lists , ta sử_dụng kĩ_thuật tung đồng xu với xác_suất 1/2 mỗi mặt để xây_dựng chiều_cao cột .\nTại_sao phải là 1/2 , liệu có_thể là một con_số khác không ?\nBạn hãy thử các con_số khác_nhau , sử_dụng cả phân_tích lý_thuyết và thực_nghiệm , cho thấy độ hiệu_quả của các con_số khác .\nHẳn bạn sẽ thắc_mắc dùng Skip_Lists làm_gì khi nó cũng chỉ để thay std : : set , mà std : : set thì_có sẵn rồi .\nSkip_Lists có rất nhiều ứng_dụng và khả_năng tùy_biến nâng_cao mà sẽ được giới_thiệu trong phần 2 của bài viết này , giúp nó làm được những điều std : : set không_thể làm được , đơn_giản nhất_là tìm phần thử lớn thứ k trong tập_hợp .\nBạn thử tự nghĩ cách tìm phần_tử lớn thứ k trong Skip_Lists xem .\nLời kết Trên đây là những gì cơ_bản nhất các bạn có_thể biết về Skip_Lists , hi_vọng các bạn có_thể ứng_dụng cấu_trúc dữ_liệu tuyệt_vời này một_cách hiệu_quả trong các contests .\nCá_nhân mình thấy Skip_Lists là một cấu_trúc dữ_liệu rất hay nhưng ít được sử_dụng , competitive programmers Việt_Nam chúng_ta thường thích dùng Splay_Tree hơn mặc_dù chẳng_mấy ai dám code lúc đi_thi . . .\nMình rất mong sau bài viết này mọi người sẽ dùng Skip_Lists nhiều hơn .\nNhững cách sử_dụng Skip_Lists nâng_cao sẽ được giới_thiệu trong phần 2 , mọi người cùng đón đọc nhé .\n\n", "tagged": "Tác_giả/N :/CH Vũ_chipchip/Np Phúc_Hoàng_A/Np :/CH \"Mày/Np AC/Np bài/N Z/Y kiểu/N gì/P thế/P ?/CH\nTao/P dùng/V set/N không/R được/V ./CH \"/CH B/Ni :/CH \"Dễ/Np mà/C mày/P ,/CH tao/P code/Np Splay/Np thôi/T ./CH\n400/M dòng/N 20/M phút/Nu ez/Np gg/Np ./CH \"/CH A/Ni :/CH \"-_-\"/Np Câu_chuyện/N thật/R tưởng/V như/C đùa/V trên/E cũng/R không_phải/Np là/V hiếm/A gặp/V ./CH\nSplay_Tree/Np (hay/Np nói/V rộng/A hơn/A ,/CH Balanced_Binary_Search_Tree)/Np là/V một/M cấu_trúc/N dữ_liệu/N toàn_năng/Np có_thể/R giải_quyết/V rất/R nhiều/A bài_toán/N ,/CH tuy_nhiên/C nó/P cũng/R là/V một/M thứ/N đáng/V khiếp_sợ/Np đối_với/E dân/N competitive/Np programmers/Np vì/E độ/N khó/A code/Np của/E nó/P ./CH\nTrong/E một/M contest/Np với/E áp_lực/N thời_gian/N căng_thẳng/A ,/CH chẳng_mấy/Np ai/P dám/V code/Np Balanced_Binary_Search_Tree/Np và/Cc còn/R đảm_bảo/V code/Np không/R bị/V bug/Np nữa/R ./CH\nTuy_nhiên/C ,/CH bạn/N không_thể/R hoàn_toàn/A tránh/V được/V nó/P ,/CH vẫn/R có/V những/L bài/N mà/C những/L thư_viện/N có_sẵn/Np như/C std/Np :/CH :/CH set/N hay/Cc những/L cấu_trúc/N đơn_giản/A như/C Segment_Tree/Np ,/CH Fenwick_Tree/Np không_thể/R giải/N được/V ,/CH và/Cc bạn/N vẫn/R phải/V nhờ_cậy/Np đến/E Splay_Tree/Np trong/E nỗi/Nc tuyệt_vọng/V ./CH\nMay_mắn/A thay/V ,/CH dân/N competitive/Np programmers/Np đã/R tìm_ra/Np cách/N sử_dụng/V Skip_Lists/Np như/C một/M sự/N thay_thế/V cho/E Balanced_Binary_Search_Tree/Np ./CH\nSkip_Lists/Np với/E ý_tưởng/N hết_sức/R đơn_giản/A dễ/A nhớ/V ,/CH cộng/V thêm/V với/E khả_năng/N tùy_biến/Np tuyệt_vời/A đã/R phần_nào/L làm/V xua_tan/Np đi/V nỗi/Nc sợ/V code/Np khó/A bug/Np nhiều/A (trừ/Np khi/N bạn/N có/V trình_độ/N Da/N xua/V thượng/Np thừa/V như/C nhân_vật/N B/Ni trong/E đoạn/Nc hội_thoại/Np trên;/Np trong/E trường_hợp/N đó/P ,/CH bạn/N có_thể/R bỏ_qua/V bài/N viết/V này)/Np ./CH\nBài/N viết/V này/P sẽ/R giới_thiệu/V cho/E các/L bạn/N những/L ý_tưởng/N và/Cc cách/N sử_dụng/V Skip_Lists/Np cơ_bản/A nhất/A ./CH\nTable/Np of_Contents/Np Bài_toán/N cơ_bản/A Các/L hướng/N tiếp_cận/V Ý_tưởng/N Skip_Lists/Np So_sánh/V các/L cấu_trúc/N dữ_liệu/N Hướng_dẫn/V chi_tiết/N Mở_rộng/V Lời/N kết/V Bài_toán/N cơ_bản/A Hãy/R lập_trình/V một/M cấu_trúc/N dữ_liệu/N S/Y có_thể/R thực_hiện/V các/L thao_tác/V sau/E :/CH Chèn/V một/M phần_tử/N x/CH vào/E S/Y ./CH\nXóa_một/Np phần_tử/N x/CH khỏi/V S/Y ./CH\nCho/E một/M phần_tử/N x/CH ,/CH tìm/V một/M phần_tử/N gần/A x/CH nhất/A trong/E S/Y ./CH\nCác/L hướng/N tiếp_cận/V Ta/P sẽ/R xét/V một_số/L cấu_trúc/N dữ_liệu/N (chưa/Np đề_cập/V đến/E Skip_Lists)/Np sử_dụng/V để/E giải/N bài_toán/N cơ_bản/A trên/E :/CH Sorted_Array/Np :/CH Biểu_diễn/V S/Y là/V một/M mảng/N các/L phần_tử/N ./CH\nCác/L phần_tử/N trong/E mảng/N được/V sắp_xếp/V theo/V thứ_tự/N tăng/V dần/R ./CH\nChèn/V :/CH Dịch/N tất_cả/P các/L phần_tử/N bên/N phải/V vị_trí/N cần/V chèn/V sang/V phải/V một/M chỉ_số/N ,/CH rồi/C chèn/V phần_tử/N cần/V chèn/V vào/E vị_trí/N đó/P ./CH\nXóa/V :/CH Dịch/N tất_cả/P các/L phần_tử/N bên/N phải/V phần_tử/N bị/V xóa/V sang/V trái/Nc một/M chỉ_số/N ./CH\nTìm/V :/CH Tìm_kiếm/V nhị_phân/Np phần_tử/N ./CH\nĐộ/N phức_tạp/A :/CH O(Nlog(N))/Np với/E thao_tác/V khởi/V tạo/V ,/CH O(N)/Np với/E thao_tác/V chèn/V ,/CH O(log(N))/Np với/E thao_tác/V tìm_kiếm/V ./CH\nSorted_Linked_List/Np :/CH Biểu_diễn/V S/Y là/V một/M danh_sách/N liên_kết/V chứa/V các/L phần_tử/N ./CH\nCác/L phần_tử/N trong/E danh_sách/N liên_kết/V được/V sắp_xếp/V theo/V thứ_tự/N tăng/V dần/R ./CH\nChèn/V :/CH Thay_đổi/V liên_kết/V giữa/N phần_tử/N cần/V chèn/V ,/CH phần_tử/N đứng/V trước/E ,/CH và/Cc phần_tử/N đứng/V sau/E ./CH\nXóa/V :/CH Thay_đổi/V liên_kết/V giữa/N phần_tử/N cần/V chèn/V ,/CH phần_tử/N đứng/V trước/E ,/CH và/Cc phần_tử/N đứng/V sau/E ./CH\nTìm/V :/CH Duyệt_S/Np từ_đầu/Np đến/E cuối/N ./CH\nĐộ/N phức_tạp/A :/CH O(N)/Np với/E các/L thao_tác/V chèn/xóa/Np ./CH\nO(Nlog(N))/Np với/E thao_tác/V khởi/V tạo/V ./CH\nBinary_Search_Tree/Np :/CH Biểu_diễn/V S/Y là/V một/M cây/N nhị_phân/Np tìm_kiếm/V chứa/V các/L phần_tử/N ./CH\nCây/N này/P có/V tính_chất/N tất_cả/P các/L nút/N thuộc/V cây_con/Np bên/N trái/Nc đều/R nhỏ/A hơn/A nút/N cha/N ,/CH và/Cc tất_cả/P các/L nút/N thuộc/V cây_con/Np bên/N phải/V đều/R lớn/A hơn/A nút/N cha/N ./CH\nChèn/V (Nhiều/Np cách/N làm)/Np :/CH Đi/V từ/E trên/E gốc/N xuống/V ,/CH so_sánh/V phần_tử/N được/V chèn/V với/E hai/M nút/N con/Nc ,/CH nếu/C có/V thì/C đi_vào/Np nút/N con/Nc ,/CH còn/R không/R thì/C thêm/V một/M nút/N vào/E cây_chứa/Np phần_tử/N cần/V chèn/V ./CH\nXóa/V (Nhiều/Np cách/N làm)/Np :/CH Thay/V nút/N bị/V xóa/V bằng/E nút/N lớn/A nhất/A của/E cây_con/Np bên/N trái/Nc (và/Np xóa/V nút/N đó/P đi)/Np ,/CH nếu_không/Np có/V cây_con/Np bên/N trái/Nc thì/C thay/V bằng/E nút/N nhỏ/A nhất/A của/E cây_con/Np bên/N phải/V ,/CH nếu_không/Np có_con/Np thì/C đơn_giản/A là/V xóa/V đi/V ./CH\nTìm/V :/CH Đi/V từ/E trên/E gốc/N xuống/V ,/CH so_sánh/V phần_tử/N cần/V tìm/V với/E hai/M nút/N con/Nc ,/CH đi_vào/Np cây_con/Np chứa/V nút/N cần/V tìm/V ,/CH cứ/R thế/P đến/E khi/N tìm/V được/V ./CH\nĐộ/N phức_tạp/A :/CH Với/E trường_hợp/N trung_bình/A ,/CH các/L thao_tác/V này/P có/V độ/N phức_tạp/A O(log(N))/Np ./CH\nCòn/R với/E trường_hợp/N xấu/A nhất_là/X O(N)/Np ./CH\nBalanced_Binary_Search_Tree/Np :/CH Giống_Binary_Search_Tree/Np ,/CH nhưng/C cây/N có/V thêm/V cơ_chế/N tự/P cần/V bằng/E để/E tránh/V việc/N cây/N bị/V suy_biến/Np ,/CH luôn/R giữ/V chiều_cao/N cây/N ở/E mức/N ổn_định/A (thường/Np là/V O(log(N))/Np ./CH\nLưu_ý/V :/CH Thao_tác/V chèn/V và/Cc xóa/V đều/R phải/V đi_qua/Np thao_tác/V tìm/V ./CH\nTa/P nhận_thấy/Np mỗi/L cấu_trúc/N dữ_liệu/N kể_trên/Np đều/R có/V nhược_điểm/N của/E nó/P ./CH\nSorted_Array/Np có/V thao_tác/V chèn/V xóa/V chậm/A ,/CH Sorted_Linked_List/Np có/V thao_tác/V tìm/V chậm/A ,/CH Binary_Search_Tree/Np có_thể/R bị/V suy_biến/Np về/E chiều_cao/N làm_cho/Np cả/P 3/M thao_tác/V đều/R chậm/A ,/CH Balanced_Binary_Search_Tree/Np hoàn_hảo/A nhưng/C lại/R quá/R phức_tạp/A để/E cài_đặt/V trong/E giới_hạn/V thời_gian/N của/E competitive/Np programming/Np ./CH\nTừ_đó/Np ,/CH Skip_Lists/Np ,/CH một/M phiên_bản/N nâng_cấp/V của/E Sorted_Linked_List/Np ,/CH được/V sử_dụng/V trong/E competitive/Np programming/Np như/C một/M sự/N thay_thế/V cho/E Balanced_Binary_Search_Tree/Np ./CH\nVề/E tộc/Np độ/N và/Cc bộ_nhớ/Np ,/CH Skip_Lists/Np không/R thua/V gì/P Balanced_Binary_Search_Tree/Np ,/CH tuy_nhiên/C lại/R dễ/A cài_đặt/V hơn/A rất/R nhiều/A ./CH\nÝ_tưởng/N Skip_Lists_Skip_Lists/Np là/V một/M phiên_bản/N nâng_cấp/V của/E Sorted_Linked_Lists/Np ./CH\nTa/P hãy/R bắt_đầu/V với/E một/M ví_dụ/C về/E Sorted_Linked_List/Np chứa/V 8/M số/N và/Cc nghĩ/V cách/N cải_thiện/V vấn_đề/N của/E nó/P ./CH\nSorted_Linked_List/Np có/V ưu_điểm/N lớn/A khi/N thao_tác/V chèn/V xóa/V chỉ/R mất/V O(1)/Np (ta/Np chỉ/R việc/N chỉnh_sửa/V liên_kết/V giữa/N phần_tử/N được/V chèn/V và/Cc các/L phần_tử/N đằng/N trước/E ./CH\nTuy_nhiên/C thao_tác/V tìm_kiếm/V lại/R mất/V O(N)/Np do/E phải/V duyệt/V từ_đầu/Np đến/E cuối/N ./CH\nMột/M ý_tưởng/N để/E cân_bằng/A điều/N này/P là/V ta/P thêm/V nhiều/A tầng/N liên_kết/V ,/CH cứ/R lên/V một/M tầng/N số/N liên_kết/V lại/R giảm/V còn/R một_nửa/N ./CH\nKhi/N tìm/V phần_tử/N ,/CH ta/P sẽ/R duyệt/V từ/E trái/Nc sang/V phải/V nhưng/C sẽ/R nhảy_xa/Np hơn/A nhờ/V những/L liên_kết/V trên/E các/L tầng/N cao/A ,/CH khi_nào/Np không/R nhảy/V được/V mới/R xuống/V tầng/N thấp/A hơn/A ./CH\nÝ_tưởng/N này/P khá/R giống/N với/E phương_pháp/N nhảy/V lên/V tổ_tiên/N thứ/N 2K/Np khi/N tìm/V Lowest_Common_Ancestor/Np (LCA)/Np ./CH\nTrong/E hình/N trên/E ,/CH để/E tìm/V số/N 7/M ,/CH ta/P sẽ/R nhảy/V thẳng/A từ/E 0/M đến/E 5/M bằng/E liên_kết/V trên/E tầng/N thứ_ba/N ,/CH sau_đó/Np nhảy/V từ/E 5/M đến/E 6/M bằng/E liên_kết/V trên/E tầng/N thứ/N nhất/A ./CH\nTa/P tìm/V được/V 6/M là/V số/N gần/A nhất/A với/E 7/M ./CH\nVới/E cấu_trúc/N này/P ,/CH ta/P có_thể/R thực_hiện/V thao_tác/V tìm/V trong/E O(log(N))/Np ./CH\nTuy_nhiên/C việc/N chèn/V và/Cc xóa_một/Np phần_tử/N vào/E sẽ/R làm/V thay_đổi/V cấu_trúc/N này/P ./CH\nChẳng_hạn/X nếu/C ta/P chèn/V số/N 7/M :/CH Như/C hình/N trên/E ,/CH cấu_trúc/N của/E ta/P không/R còn/R \"chuẩn\"/Np ,/CH có_nghĩa/A là/V chính_xác/A tầng/N thứ/N nhất/A liên_kết/V cách/N 20/M ,/CH tầng/N thứ_hai/N liên_kết/V cách/N 21/M ,/CH tầng/N thứ_ba/N liên_kết/V cách/N 22/M ,/CH ./CH ./CH ./CH\nTuy_nhiên/C ,/CH với/E cấu_trúc/N như/C hình/N trên/E vẫn/R chạy/V tốt/A -/CH chỉ_có/Np điều/N ở/E mỗi/L tầng_ta/Np có_thể/R phải/V nhảy/V nhiều/A hơn/A một_lần/Np (chẳng/Np hạn/N ,/CH muốn/V tìm/V số/N 7/M ,/CH ở/E tầng/N thứ/N nhất/A ta/P phải/V nhảy/V đến/E hai/M lần/N 5/M ~gt;/Np 6/M ~gt;/Np 7)/Np ./CH\nTừ_đó/Np ta/P có/V nhận_xét/N sau/E :/CH Các/L liên_kết/V trên/E mỗi/L tầng/N không/R nhất_thiết/R phải/V chuẩn/N ,/CH tuy_nhiên/C ,/CH nếu/C các/L độ_dài/Np giữa/N các/L liên_kết/V xấp_xỉ/A nhau/N và/Cc số/N liên_kết/V ở/E tầng/N trên/E xấp_xỉ/A bằng/E nửa/M số/N liên_kết/V ở/E tầng/N dưới/E ,/CH thuật_toán/N tìm_kiếm/V vẫn/R chạy/V tốt/A và/Cc không/R mất/V quá/R nhiều/A lần/N nhảy/V ở/E mỗi/L tầng/N ./CH\nTa/P sẽ/R duy_trì/V cấu_trúc/N này/P bằng/E kĩ_thuật/N tung/V đồng/Nu xu/N ngẫu_nhiên/A :/CH Mỗi/L lần/N chèn/V một/M nút/N vào/E ,/CH đầu_tiên_ta/Np xây_dựng/V liên_kết/V ở/E tầng/N thứ/N nhất/A cho/E nó/P ./CH\nSau_đó/Np ta/P tung/V đồng/Nu xu/N ,/CH nếu/C ngửa/V thì/C ta/P xây_dựng/V liên_kết/V ở/E tầng/N trên/E và/Cc tiếp_tục/V tung/V đồng/Nu xu/N ,/CH còn/R nếu/C sấp/A ta/P dừng/V việc/N xây_dựng/V liên_kết/V lại/R ./CH\nĐây/P chính/T là/V Skip_Lists/Np -/CH một/M cấu_trúc/N dữ_liệu/N được/V xây_dựng/V bằng/E nhiều/A tầng/N Sorted_Linked_List/Np được/V xây_dựng/V một_cách/N ngẫu_nhiên/A ,/CH trong/E đó/P tầng/N cao/A chứa/V những/L bước/V nhảy_dài/Np hơn/A và/Cc tầng/N thấp/A chứa/V những/L bước/V nhảy/V ngắn/A hơn/A ./CH\nSkip_Lists/Np cho_phép/V ta/P thực_hiện/V thao_tác/V tìm_kiếm/V với/E độ/N phức_tạp/A xấp_xỉ/A O(log(N))/Np ./CH\nSo_sánh/V các/L cấu_trúc/N dữ_liệu/N Hướng_dẫn/V chi_tiết/N Học/V phải/V đi_đôi/Np với/E hành/V ./CH\nCách/N hiểu/V lý_thuyết/Np nhanh/A nhất_là/X đập/V ngay/R vào/E bài_tập/Np ./CH\nTa/P sẽ/R đi/V chi_tiết/N vào/E cách/N sử_dụng/V Skip_Lists/Np để/E giải/N bài/N CPPSET/Np ./CH\nBạn/N hãy/R đọc/V đề/V và/Cc ngẫm_nghĩ/V một_lúc/Np trước_khi/Np đọc_tiếp/Np bài/N viết/V này/P ./CH\nBài_giải/Np ở/E dưới/E được/V code_bằng/Np ngôn_ngữ/N C++98/Np ./CH\nCPPSET/Np ,/CH đúng/A như/C tên_gọi/Np của/E nó/P ,/CH bạn/N có_thể/R AC/Np trong/E một/M nốt_nhạc/Np nếu/C sử_dụng/V std/Np :/CH :/CH set/N của/E C++/Np ,/CH một/M container/Nb đã/R được/V code/Np sẵn/A bằng/E Reb-Black_Tree/Np (một/Np loại/N Balanced_Binary_Search_Tree)/Np để/E thực_hiện/V bài_toán/N cơ_bản/A nêu/V ở/E đầu/N ./CH\nĐể/E luyện_tập/V ,/CH ta/P sẽ/R tự/P code/Np một/M cái/Nc set/N \"dỏm\"/Np bằng/E Skip_Lists/Np ./CH\nTrước_tiên/N ta/P cần/V xây_dựng/V các/L struct/Np biểu_diễn/V Skip_Lists/Np ./CH\nTa/P sẽ/R có/V 3/M struct/Np :/CH SkipLists/Np ,/CH Column/Np ,/CH Cell/Np ./CH\nSkipLists/Np là/V một/M danh_sách/N các/L Column/Np liên_kết/V với_nhau/Np ./CH\nColumn/Np là/V một/M cột/N gồm/V các/L Cell/Np ,/CH biểu_diễn/V cho/E cột/N liên_kết/V của/E một/M phần_tử/N trong/E set/N của/E ta/P với/E các/L phần_tử/N đằng_trước/Np và/Cc đằng_sau/Np ./CH\nCell/Np là/V một/M liên_kết/V cơ_bản/A nhất/A trên/E một/M tầng/N của/E Column/Np ,/CH chứa/V hai/M liên_kết/V đến/E Column/Np đằng_trước/Np và/Cc đằng_sau/Np ./CH\nĐể_cho/Np dễ_hiểu/Np ,/CH bạn/N hãy/R xem/V hình/N dưới/E ./CH\nstruct/Np SkipLists/Np static/Np const/Np int/Np MAX_LEVEL/Np =/CH 20/M ;/CH //CH Giới_hạn/V số/N tầng/N ,/CH nên/C chọn/V một_số/L khoảng/N log(N)/Np Column/Np head/Np ,/CH tail/Np ;/CH //CH thêm/V 2/M cột/N không/R có_giá/Np trị/V vào/E đầu/N và/Cc cuối/N để/E dễ/A xử_lí/V ;/CH struct/Np Column/Np int/Np value/Np ;/CH vector/Np lt;/Np Cell/Np gt;/Np cells/Np ;/CH ;/CH struct/Np Cell_Column/Np previous_column/Np ,/CH next_column/Np ;/CH //CH Mỗi_Cell/Np có/V hai/M liên_kết/V đến/E Column/Np đằng_trước/Np và/Cc đằng_sau/Np (không/Np giống/N trong/E hình/N chỉ_vẽ/Np một/M liên_kết/V về/E đằng_sau/Np cho_đơn/Np giản)/Np ;/CH Sau/E khi/N đã/R biết/V cách/N biểu_diễn/V dữ_liệu/N ,/CH ta/P sẽ/R code/Np các/L hàm/Np cho/E SkipLists/Np ./CH\nSet/N \"dỏm\"/Np của/E chúng_ta/P sẽ/R gồm/V 6/M hàm/Np sau/E :/CH struct/Np SkipLists/Np static/Np const/Np int/Np MAX_LEVEL/Np =/CH 20/M ;/CH Column/Np head/Np ,/CH tail/Np ;/CH SkipLists/Np ();/Np //CH Khởi/V tạo/V bool/Np empty/Np ();/Np //CH Kiểm_tra/V SkipLists/Np có/V rỗng_không/A Column/Np lower_bound/Np (/CH int/Np );/CH //CH Tìm/V vị_trí/N Column/Np chứa/V giá_trị/N nhỏ/A nhất/A không/R nhỏ/A hơn/A giá_trị/N cần/V tìm/V Column/Np upper_bound/Np (/CH int/Np );/CH //CH Tìm/V vị_trí/N Column/Np chứa/V giá_trị/N nhỏ/A nhất/A lớn/A hơn/A giá_trị/N cần/V tìm/V void/Np insert/Np (/CH int/Np );/CH //CH Chèn/V một/M phần_tử/N mang/V giá_trị/N cho/E trước/E vào/E SkipLists/Np void/Np erase/Np (/CH int/Np );/CH //CH Xóa_một/Np phần_tử/N mang/V giá_trị/N cho/E trước/E khỏi/V SkipLists/Np ;/CH Ta/P sẽ/R bắt_đầu/V với/E constructor/Np SkipLists()/Np ./CH\nĐể/E khởi/V tạo/V SkipLists/Np ,/CH ta/P sẽ/R tạo/V ra/V hai/M cột/N head/Np và/Cc tail/Np có/V chiều_cao/N là/V số/N tầng/N tối_đa/A ,/CH và/Cc tại/E liên_kết/V giữa/N head/Np và/Cc tail/Np trên/E tất_cả/P các/L Cell/Np ./CH\nSkipLists/Np :/CH :/CH SkipLists/Np ()/Np head/Np =/CH new/Np Column/Np ;/CH tail/Np =/CH new/Np Column/Np ;/CH head/Np -gt;/Np value/Np =/CH 0/M ;/CH tail/Np -gt;/Np value/Np =/CH 0/M ;/CH for/Np (/CH int/Np i/M =/CH 0/M ;/CH i/M lt;/Np MAX_LEVEL/Np ;/CH i/M ++/Np )/CH head/Np -gt;/Np cells/Np ./CH\npush_back/Np ((/Np Cell/Np )/CH NULL/Np ,/CH tail/Np );/CH tail/Np -gt;/Np cells/Np ./CH\npush_back/Np ((/Np Cell/Np )/CH head/Np ,/CH NULL/Np );/CH Với/E hàm/Np empty()/Np ,/CH ta/P chỉ/R đơn_giản/A kiểm_tra/V liên_kết/V cấp/V 0/M (liên/Np kết/V trực/V tiếp)/Np của/E head/Np có/V nối/V với/E tail/Np không/R ./CH\nbool/Np SkipLists/Np :/CH :/CH empty/Np ()/Np return/Np head/Np -gt;/Np cells/Np 0/M ./CH\nnext_column/Np ==/Np tail/Np ;/CH Với/E hàm/Np lower_bound()/Np ,/CH ta/P sẽ/R đi/V từ/E tầng/N cao/A nhất/A đến/E tầng/N thấp/A nhất/A ,/CH chừng_nào/Np nhảy/V về/E phía/N trước/E vẫn/R vào/E một/M phần_tử/N có_giá/Np trị/V nhỏ/A hơn/A giá_trị/N cần/V tìm/V thì/C ta/P cứ/R nhảy/V ./CH\nSau/E khi/N duyệt/V ,/CH ta/P sẽ/R đứng/V ở/E phần_tử/N lớn/A nhất/A có_giá/Np trị/V nhỏ/A hơn/A giá_trị/N cần/V tìm/V ./CH\nTa/P nhảy/V trên/E liên_kết/V cấp/V 0/M một_lần/Np nữa/R để/E lấy_được/X lower_bound()/Np ./CH\nColumn_SkipLists/Np :/CH :/CH lower_bound/Np (/CH int/Np value/Np )/CH Column/Np iter/Np =/CH head/Np ;/CH for/Np (/CH int/Np level/Np =/CH MAX_LEVEL/Np -/CH 1/M ;/CH level/Np gt;=/Np 0/M ;/CH level/Np --/Np )/CH while/Np (/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np !/CH =/CH tail/Np amp;amp;/Np iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np -gt;/Np value/Np lt;/Np value/Np )/CH iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH return/Np iter/Np -gt;/Np cells/Np 0/M ./CH\nnext_column/Np ;/CH Hàm/Np upper_bound()/Np không/R khác_gì/X lower_bound()/Np ,/CH ngoại_trừ/Np việc/N thay/V dấu/N lt;/Np thành/V lt;=/Np lúc/N so_sánh/V với/E value/Np ./CH\nColumn_SkipLists/Np :/CH :/CH upper_bound/Np (/CH int/Np value/Np )/CH Column/Np iter/Np =/CH head/Np ;/CH for/Np (/CH int/Np level/Np =/CH MAX_LEVEL/Np -/CH 1/M ;/CH level/Np gt;=/Np 0/M ;/CH level/Np --/Np )/CH while/Np (/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np !/CH =/CH tail/Np amp;amp;/Np iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np -gt;/Np value/Np lt;=/Np value/Np )/CH iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH return/Np iter/Np -gt;/Np cells/Np 0/M ./CH\nnext_column/Np ;/CH Với/E hàm/Np insert()/Np ,/CH ta/P sẽ/R chia/V thành/V 3/M bước/V sau/E :/CH Sử_dụng/V lower_bound()/Np để/E kiểm_tra/V giá_trị/N đã/R tồn_tại/V trong/E SkipLists/Np chưa/R ./CH\nNếu/C đã/R tồn_tại/V ,/CH thoát_khỏi/Np hàm/Np ./CH\nTạo/V ra/V một/M Column/Np mới/R để/E chèn/V vào/E SkipLists/Np ./CH\nTa/P sẽ/R sử_dụng/V hàm/Np rand()/Np để/E tung/V đồng/Nu xu/N ,/CH xây_dựng/V chiều_cao/N cho/E Column/Np này/P ./CH\nChèn_Column/Np vào/E SkipLists/Np ./CH\nTa/P duyệt_y_như/Np trong/E lower_bound()/Np và/Cc upper_bound()/Np ,/CH ở/E mỗi/L tầng/N chèn/V liên_kết/V với/E Column/Np vào/E hai/M cột/N đằng_sau/Np và/Cc đằng_trước/Np Column/Np ./CH\nvoid/Np SkipLists/Np :/CH :/CH insert/Np (/CH int/Np value/Np )/CH //CH Kiểm_tra/V value/Np đã/R tồn_tại/V chưa/R Column/Np temp/Np =/CH lower_bound/Np (/CH value/Np );/CH if/Np (/CH temp/Np !/CH =/CH tail/Np amp;amp;/Np temp/Np -gt;/Np value/Np ==/Np value/Np )/CH return/Np ;/CH //CH Tạo/V inserted_column/Np là/V cột/N chứa/V value/Np để/E chèn/V vào/E SkipLists_Column/Np inserted_column/Np =/CH new/Np Column/Np ;/CH inserted_column/Np -gt;/Np value/Np =/CH value/Np ;/CH inserted_column/Np -gt;/Np cells/Np ./CH\npush_back/Np ((/Np Cell/Np )/CH NULL/Np ,/CH NULL/Np );/CH //CH Tung/V đồng/Nu xu/N tăng/V chiều_cao/N while/Np (/CH inserted_column/Np -gt;/Np cells/Np ./CH\nsize/Nb ()/Np lt;/Np MAX_LEVEL/Np amp;amp;/Np rand/Np ()/Np %/CH 2/M ==/Np 0/M )/CH inserted_column/Np -gt;/Np cells/Np ./CH\npush_back/Np ((/Np Cell/Np )/CH NULL/Np ,/CH NULL/Np );/CH //CH Duyệt/V để/E chèn/V Column/Np iter/Np =/CH head/Np ;/CH for/Np (/CH int/Np level/Np =/CH MAX_LEVEL/Np -/CH 1/M ;/CH level/Np gt;=/Np 0/M ;/CH level/Np --/Np )/CH while/Np (/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np !/CH =/CH tail/Np amp;amp;/Np iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np -gt;/Np value/Np lt;/Np value/Np )/CH iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH if/Np (/CH level/Np lt;/Np inserted_column/Np -gt;/Np cells/Np ./CH\nsize/Nb ())/Np //CH Nối/V iter/Np với/E inserted_column/Np ,/CH nối/V inserted_column/Np với/E next_iter/Np Column/Np next_iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np =/CH inserted_column/Np ;/CH next_iter/Np -gt;/Np cells/Np level/Np ./CH\nprevious_column/Np =/CH inserted_column/Np ;/CH inserted_column/Np -gt;/Np cells/Np level/Np ./CH\nprevious_column/Np =/CH iter/Np ;/CH inserted_column/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np =/CH next_iter/Np ;/CH Với/E hàm/Np erase()/Np ,/CH ta/P sẽ/R chia/V thành/V 3/M bước/V sau/E :/CH Sử_dụng/V lower_bound()/Np để/E kiểm_tra/V giá_trị/N đã/R tồn_tại/V trong/E SkipLists/Np chưa/R ./CH\nNếu_không/Np tồn_tại/V ,/CH thoát_khỏi/Np hàm/Np ./CH\nXóa/V cột/N chứa/V giá_trị/N cần/V xóa_khỏi/Np SkipLists/Np bằng/E cách/N nối/V từng/R liên_kết/V giữa/N các/L Cell/Np liền/R trước/E và/Cc liền/R sau/E nó/P trên/E từng/R tầng/N ./CH\nXóa/V cột/N chứa/V giá_trị/N cần/V xóa/V để/E giải_phóng/V bộ_nhớ/Np ./CH\nvoid/Np SkipLists/Np :/CH :/CH erase/Np (/CH int/Np value/Np )/CH //CH Kiểm_tra/V value/Np đã/R tồn_tại/V chưa/R Column/Np erased_column/Np =/CH lower_bound/Np (/CH value/Np );/CH if/Np (/CH erased_column/Np ==/Np tail/Np erased_column/Np -gt;/Np value/Np !/CH =/CH value/Np )/CH return/Np ;/CH //CH Duyệt/V để/E xóa/V Column/Np iter/Np =/CH head/Np ;/CH for/Np (/CH int/Np level/Np =/CH MAX_LEVEL/Np -/CH 1/M ;/CH level/Np gt;=/Np 0/M ;/CH level/Np --/Np )/CH while/Np (/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np !/CH =/CH tail/Np amp;amp;/Np iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np -gt;/Np value/Np lt;=/Np value/Np )/CH iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH if/Np (/CH iter/Np ==/Np erased_column/Np )/CH //CH Nối/V previous_iter/Np với/E next_iter/Np Column/Np previous_iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nprevious_column/Np ,/CH next_iter/Np =/CH iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np ;/CH previous_iter/Np -gt;/Np cells/Np level/Np ./CH\nnext_column/Np =/CH next_iter/Np ;/CH next_iter/Np -gt;/Np cells/Np level/Np ./CH\nprevious_column/Np =/CH previous_iter/Np ;/CH delete/Np erased_column/Np ;/CH Với/E 6/M hàm/Np trên/E ,/CH bạn/N đã/R có_thể/R mô_phỏng/Np một_cách/N đơn_giản/A một/M cái/Nc set/N \"dỏm\"/Np để/E giải/N bài/N này/P ./CH\nBạn/N hãy/R thử/V tự/P làm/V tiếp/V và/Cc nộp/V trên/E SPOJ/Np nhé/T ./CH\nToàn_bộ/L code/Np cho/E bài/N CPPSET/Np có_thể/R xem/V ở/E đây/P ./CH\nMở_rộng/V Ở/E trên/E mới/R là/V một/M code/Np Skip_Lists/Np đơn_giản/A nhất/A mô_phỏng/Np std/Np :/CH :/CH set/N để/E giải/N bài/N CPPSET/Np ./CH\nLiệu/V bạn/N có_thể/R code/Np lại/R một/M std/Np :/CH :/CH set/N hoàn_hảo/A bằng/E Skip_Lists/Np không/R ?/CH\nHãy/R thử/V xem/V !/CH Code/Np trên/E sử_dụng/V cả/P liên_kết/V xuôi/N (/CH next_column/Np )/CH và/Cc liên_kết/V ngược/A (/CH previous_column/Np )/CH để/E dễ/A xử_lí/V ./CH\nBạn/N có_thể/R code/Np lại/R CPPSET/Np mà/C không/R cần/V sử_dụng/V liên_kết/V ngược/A không/R ?/CH\nKhi/N xây_dựng/V cột/N để/E chèn/V vào/E Skip_Lists/Np ,/CH ta/P sử_dụng/V kĩ_thuật/N tung/V đồng/Nu xu/N với/E xác_suất/N 1/M mỗi/L mặt/N để/E xây_dựng/V chiều_cao/N cột/N ./CH\nTại_sao/X phải/V là/V 1/M ,/CH liệu/V có_thể/R là/V một/M con_số/N khác/A không/R ?/CH\nBạn/N hãy/R thử/V các/L con_số/N khác_nhau/Np ,/CH sử_dụng/V cả/P phân_tích/V lý_thuyết/Np và/Cc thực_nghiệm/V ,/CH cho/E thấy/V độ/N hiệu_quả/N của/E các/L con_số/N khác/A ./CH\nHẳn/R bạn/N sẽ/R thắc_mắc/V dùng/V Skip_Lists/Np làm_gì/X khi/N nó/P cũng/R chỉ/R để/E thay/V std/Np :/CH :/CH set/N ,/CH mà/C std/Np :/CH :/CH set/N thì_có/X sẵn/A rồi/C ./CH\nSkip_Lists/Np có/V rất/R nhiều/A ứng_dụng/V và/Cc khả_năng/N tùy_biến/Np nâng_cao/Np mà/C sẽ/R được/V giới_thiệu/V trong/E phần/N 2/M của/E bài/N viết/V này/P ,/CH giúp/V nó/P làm/V được/V những/L điều/N std/Np :/CH :/CH set/N không_thể/R làm/V được/V ,/CH đơn_giản/A nhất_là/X tìm/V phần/N thử/V lớn/A thứ/N k/N trong/E tập_hợp/N ./CH\nBạn/N thử/V tự/P nghĩ/V cách/N tìm/V phần_tử/N lớn/A thứ/N k/N trong/E Skip_Lists/Np xem/V ./CH\nLời/N kết/V Trên/E đây/P là/V những/L gì/P cơ_bản/A nhất/A các/L bạn/N có_thể/R biết/V về/E Skip_Lists/Np ,/CH hi_vọng/V các/L bạn/N có_thể/R ứng_dụng/V cấu_trúc/N dữ_liệu/N tuyệt_vời/A này/P một_cách/N hiệu_quả/N trong/E các/L contests/Np ./CH\nCá_nhân/N mình/P thấy/V Skip_Lists/Np là/V một/M cấu_trúc/N dữ_liệu/N rất/R hay/Cc nhưng/C ít/A được/V sử_dụng/V ,/CH competitive/Np programmers/Np Việt_Nam/N chúng_ta/P thường/R thích/V dùng/V Splay_Tree/Np hơn/A mặc_dù/C chẳng_mấy/Np ai/P dám/V code/Np lúc/N đi_thi/Np ./CH ./CH ./CH\nMình/P rất/R mong/V sau/E bài/N viết/V này/P mọi/L người/N sẽ/R dùng/V Skip_Lists/Np nhiều/A hơn/A ./CH\nNhững/L cách/N sử_dụng/V Skip_Lists/Np nâng_cao/Np sẽ/R được/V giới_thiệu/V trong/E phần/N 2/M ,/CH mọi/L người/N cùng/A đón/V đọc/V nhé/T ./CH\n\n", "title": "Skip Lists\n", "link": "http://vnoi.info/wiki/algo/data-structures/Skip-Lists\n"}