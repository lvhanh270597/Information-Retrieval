{"content": "Table of_Contents 0 .\nGiới_thiệu Ví_dụ Cài_đặt Áp_dụng Phân_tích thời_gian chạy Thao_tác loại 1 Thao_tác loại 2 Phân_tích bộ_nhớ 1 .\nSegment_Tree cổ_điển Ví_dụ 1 Tóm_tắt_đề Lời_giải Định_lý Ví_dụ 2 2 .\nLazy_Propagation Tư_tưởng Bài_Toán Tóm_tắt_đề Phân_tích Cài_đặt 3 .\nỨng_dụng với cấu_trúc mảng động Ví_dụ Tóm_tắt_đề Phân_tích 4 .\nỨng_dụng với cấu_trúc set 5 .\nỨng_dụng với các cấu_trúc dữ_liệu khác 6 .\nỨng_dụng trong cây có gốc 7 .\nPersistent_Segment_Trees 8 .\nIT đoạn_thẳng Bài_tập áp_dụng : Đọc thêm : Các nguồn tham_khảo : LƯU_Ý : Segment_Tree trong 1 số tài_liệu Tiếng_Việt còn được dịch là Interval_Tree .\nỞ bài viết này , mình sẽ dùng tên Segment_Tree (ST) - tên_gọi phổ_biến hơn của CTDL này .\nTất_cả hàm trong bài đều đánh_số từ 1 .\nCác nút của cây phân_đoạn sẽ quản_lý đoạn l , r Segment_Tree còn có_một cách cài_đặt khác sử_dụng ít bộ_nhớ hơn (tối đa 2N phần tử) , cài_đặt ngắn hơn và chạy nhanh hơn .\nTuy_nhiên theo cá_nhân mình không dễ_hiểu bằng cách cài_đặt trong bài viết này .\n0 .\nGiới_thiệu Segment_Tree là một cấu_trúc dữ_liệu được sử_dụng rất nhiều trong các kỳ thi , đặc_biệt là trong những bài_toán xử_lý trên dãy_số .\nSegment_Tree là một cây .\nCụ_thể hơn , nó là một cây nhị_phân đầy_đủ (mỗi nút là lá hoặc có đúng 2 nút con) , với mỗi nút quản_lý một đoạn trên dãy_số .\nVới một dãy_số gồm N phần_tử , nút gốc sẽ lưu_thông_tin về đoạn 1 , N , nút con trái của nó sẽ lưu_thông_tin về đoạn 1 , ⌊N/2⌋ và nút con phải sẽ lưu_thông_tin về đoạn ⌊N/2⌋+1 , N .\nTổng_quát hơn : nếu nút A lưu_thông_tin đoạn i , j , thì 2 con của nó : A1 và A2 sẽ lưu_thông_tin của các đoạn i , ⌊(i+j)/2⌋ và đoạn ⌊(i+j)/2⌋ + 1 , j .\nVí_dụ Xét một dãy gồm 7 phần_tử , Segment_Tree sẽ quản_lý các đoạn như_sau : Cài_đặt Để cài_đặt , ta có_thể dùng một mảng 1 chiều , phần_tử thứ nhất của mảng thể_hiện nút gốc .\nPhần_tử thứ id sẽ có 2 con là 2 id (con trái) và 2 id+1 (con phải) .\nVới cách cài_đặt này , người_ta đã chứng_minh được bộ_nhớ cần_dùng cho ST không quá 4 N phần_tử .\nÁp_dụng Để dễ hình_dung , ta lấy 1 ví_dụ cụ_thể : Cho dãy N phần_tử (N \\le 105) .\nBan_đầu mỗi phần_tử có giả trị 0 .\nCó_Q truy_vấn (Q \\le 105) .\nMỗi truy_vấn có 1 trong 2 loại : Gán giá_trị v cho phần_tử ở vị_trí i .\nTìm giá_trị lớn nhất cho đoạn i , j .\nCách đơn_giản nhất_là dùng 1 mảng A duy_trì giá_trị các phần_tử .\nVới thao_tác 1 thì ta gán Ai = v .\nVới thao_tác 2 thì ta dùng 1 vòng_lặp từ i đến j để tìm giá_trị lớn nhất .\nRõ_ràng cách này có độ phức_tạp là O(NQ) và không_thể chạy trong thời_gian cho_phép .\nCách dùng Segment_Tree như_sau : Với truy_vấn loại 1 , ta sẽ cập_nhật thông_tin của các nút trên cây ST mà đoạn nó quản_lý_chứa phần_tử i .\nVới truy_vấn loại 2 , ta sẽ tìm tất_cả các nút trên cây ST mà đoạn nó quản_lý nằm trong i , j , rồi lấy max của các nút này .\nCài_đặt như_sau : // Truy_vấn : A(i) = v // Hàm_cập_nhật trên cây ST , cập_nhật cây_con gốc id quản_lý đọan l , r void update ( int id , int l , int r , int i , int v ) if ( i lt; l r lt; i ) // i nằm ngoài đoạn l , r , ta bỏ_qua nút i return ; // i nằm trong đoạn l , r , ta cần cập_nhật nút id ST id = max ( ST id , v ); if ( l == r ) // Đoạn chỉ gồm 1 phần_tử , không có nút con return ; // Gọi đệ_quy để xử_lý các nút con của nút id int mid = ( l + r ) / 2 ; update ( id 2 , l , mid , i , v ); update ( id 2 + 1 , mid + 1 , r , i , v ); // Truy_vấn : tìm max đoạn u , v // Hàm tìm max các phần_tử trên cây ST nằm trong cây_con gốc id - quản_lý đoạn l , r int get ( int id , int l , int r , int u , int v ) if ( v lt; l r lt; u ) // Đoạn u , v không giao với đoạn l , r , ta bỏ_qua đoạn này return - INFINITY ; if ( u lt;= l amp;amp; r lt;= v ) // Đoạn l , r nằm hoàn_toàn trong đoạn u , v mà ta đang truy_vấn , ta trả_lại // thông_tin lưu ở nút id return ST id ; int mid = ( l + r ) / 2 ; // Gọi đệ_quy với các con của nút id return max ( get ( id 2 , l , mid , u , v ) , get ( id 2 + 1 , mid + 1 , r , u , v )); Phân_tích thời_gian chạy Mỗi thao_tác truy_vấn trên cây ST có độ phức_tạp O(\\logN) .\nĐể chứng_minh điều này , ta xét 2 loại thao_tác trên cây ST : Truy_vấn 1 phần_tử trên ST (giống thao_tác update ở trên) Truy_vấn nhiều phần_tử trên ST (giống thao_tác get ở trên) Đầu_tiên_ta có_thể chứng_minh được : Độ_cao của cây ST không quá O(\\logN) .\nTại mỗi độ sâu của cây , không có phần_tử nào nằm trong 2 nút khác_nhau của cây .\nThao_tác loại 1 Với thao_tác này , ở mỗi độ sâu của cây , ta chỉ gọi đệ_quy các con của không quá 1 nút .\nPhân_tích đoạn code trên , ta xét các trường_hợp : Phần_tử cần xét không nằm trong đoạn l , r do nút id quản_lý .\nTrường_hợp này ta dừng lại , không xét tiếp .\nPhần_tử cần xét nằm trong đoạn l , r do nút id quản_lý .\nTa xét các con của nút id .\nTuy_nhiên chỉ_có 1 con của nút id_chứa phần_tử cần xét và ta sẽ phải xét tiếp các con của nút này .\nVới con còn_lại , ta sẽ dừng ngay mà không xét các con của nó nữa .\nDo_đó độ phức_tạp của thao_tác này không quá O(\\logN) .\nThao_tác loại 2 Với thao này , ta cũng chứng_minh tương_tự , nhưng ở mỗi độ sâu của cây , ta chỉ gọi hàm đệ_quy với các con của không quá 2 nút .\nTa chứng_minh bằng phản_chứng , giả_sử_ta gọi đệ_quy với 3 nút khác_nhau của cây ST (đánh dấu màu đỏ) : Trong trường_hợp này , rõ_ràng toàn_bộ đoạn của nút ở giữa quản_lý nằm trong đoạn đang truy_vấn .\nDo_đó ta không cần phải gọi đệ_quy các con của nút ở giữa .\nTừ_đó suy ra vô_lý , nghĩa_là ở mỗi độ sâu_ta chỉ gọi đệ_quy với không quá 2 nút .\nPhân_tích bộ_nhớ Ta xét 2 trường_hợp : N = 2k : Cây_ST đầy_đủ , ở độ sâu cuối_cùng có đúng 2k lá , và các độ sâu thấp hơn không có nút lá nào (và các nút này đều có đúng 2 con) .\nNhư_vậy : Tầng k : có 2k nút Tầng k-1 : có 2k-1 nút . . .\nTổng_số nút không quá 2k+1 .\nVới_N gt; 2k và N lt; 2k+1 .\nSố nút của cây ST không quá số nút của cây ST với N = 2k+1 .\nDo_đó , số nút của cây cho dãy N phần_tử , với N \\le 2k là không quá 2k+1 , giá_trị này xấp_xỉ 4 N .\nBằng thực_nghiệm , ta thấy dùng 4 N là đủ .\n1 .\nSegment_Tree cổ_điển Tại_sao lại gọi_là cổ_điển ?\nĐây là dạng ST đơn_giản nhất , chúng_ta chỉ giải_quyết truy_vấn update một phần_tử và truy_vấn đoạn , mỗi nút lưu một loại dữ_liệu cơ_bản như số_nguyên , boolean , . . .\nVí_dụ 1 Bài_toán : 380C-Codeforces Tóm_tắt_đề Cho một dãy ngoặc độ_dài N (N\\le106) , cho M truy_vấn có dạng l_i , r_i (1\\le l_i\\le r_i \\le N) .\nYêu_cầu của bài_toán là với mỗi truy_vấn tìm một chuỗi con (không cần liên tiếp) của chuỗi từ l_i đến r_i dài nhất mà tạo_thành dãy ngoặc đúng .\nLời_giải Với mỗi nút(ví dụ như nút id , quản_lý đoạn l , r) chúng_ta lưu ba biến nguyên : optimal : Là kết_quả tối_ưu trong đoạn l , r .\nopen : Số_lượng dấu ( sau khi đã xóa hết các phần_tử thuộc dãy ngoặc đúng độ_dài optimal trong đoạn .\nclose : Số_lượng dấu ) sau khi đã xóa hết các phần_tử thuộc dãy ngoặc đúng độ_dài optimal trong đoạn .\nTa tạo 1 kiểu dữ_liệu cho 1 nút của cây ST như_sau : struct Node int optimal ; int open ; int close ; Node ( int opt , int o , int c ) // Khởi tạo struct Node optimal = opt ; open = o ; close = c ; ; Và ta khai_báo cây ST như_sau : Node st MAXN 4 ; Định_lý Để tính thông_tin ở nút id quản_lý đoạn l , r , dựa trên 2 nút con 2id và 2id+1 , ta định_nghĩa 1 thao_tác kết_hợp 2 nút của cây ST : Node operator + ( const Node amp; left , const Node amp; right ) Node res ; // min(số dấu \"(\" thừa ra ở cây_con trái , và số dấu \")\" thừa ra ở cây_con phải) int tmp = min ( left .\nopen , right .\nclose ); // Để xây_dựng kết_quả tối_ưu ở nút id , ta nối dãy ngoặc tối_ưu ở 2 con , rồi thêm // min(số \"(\" thừa ra ở con trái , số \")\" thừa ra ở con phải) .\nres .\noptimal = left .\noptimal + right .\noptimal + tmp ; res .\nopen = left .\nopen + right .\nopen - tmp ; res .\nclose = left .\nclose + right .\nclose - tmp ; return res ; Ban_đầu ta có_thể khởi tạo cây như_sau : void build ( int id , int l , int r ) if ( l == r ) // Đoạn l , r chỉ_có 1 phần_tử .\nif ( s l == ( ) st id = Node ( 0 , 1 , 0 ); else st id = Node ( 0 , 0 , 1 ); return ; int mid = ( l + r ) / 2 ; build ( id 2 , l , mid ); build ( id 2 + 1 , mid + 1 , r ); st id = st id 2 + st id 2 + 1 ; Để trả_lời truy_vấn , ta cũng làm tương_tự như trong bài_toán cơ_bản : Node query ( int id , int l , int r , int u , int v ) if ( v lt; l r lt; u ) // Trường_hợp không giao nhau return Node ( 0 , 0 , 0 ); if ( u lt;= l amp;amp; r lt;= v ) // Trường_hợp l , r nằm hoàn_toàn trong u , v return st id ; int mid = ( l + r ) / 2 ; return query ( id 2 , l , mid , u , v ) + query ( id 2 + 1 , mid + 1 , r , u , v ); Ví_dụ 2 Bài_toán : SPOJ-KQUERY Tóm_đề : Cho một dãy_số a_i(1\\le a_i \\le 109) có N(1\\le_N \\le 30 , 000) phần_tử Cho_Q(1\\le_Q \\le 200 , 000) truy_vấn có dạng 3 số_nguyên là l_i , r_i , k_i (1\\le l_i\\le r_i\\le N , 1\\le k \\le 109) .\nYêu_cầu của bài_toán là đếm_số lượng số a_j (l_i\\le j \\le r_i) mà a_j\\ge k .\nGiả_sử chúng_ta có_một mảng b với b_i=1 nếu a_igt;k và bằng 0 nếu ngược_lại .\nThì chúng_ta có_thể dễ_dàng trả_lời truy_vấn (i , j , k) bằng cách lấy tổng_từ i đến j .\nCách làm của bài này là xử_lý các truy_vấn theo một thứ_tự khác , để ta có_thể dễ_dàng tính được mảng b .\nKĩ_năng này được gọi_là xử_lý offline (tương tự nếu ta trả_lời các truy_vấn theo đúng thứ_tự trong input , thì được gọi_là xử_lý online ) : Sắp_xếp các truy_vấn theo thứ_tự tăng dần của k .\nLúc đầu mảng b gồm toàn_bộ các số 1 .\nVới mỗi truy_vấn , ta xem trong mảng a có những phần_tử nào lớn hơn giá_trị k của truy_vấn trước , và nhỏ hơn giá_trị k của truy_vấn hiện_tại , rồi đánh_dấu các_vị trí đó trên mảng b thành 0 .\nĐể làm được_việc này một_cách hiệu_quả , ta cũng cần sắp_xếp lại mảng a theo thứ_tự tăng dần .\nTa tạo kiểu dữ_liệu cho truy_vấn : struct Query int k ; int l , r ; ; // so_sánh 2 truy_vấn để dùng vào việc sort .\nbool operator lt; ( const Query amp; a , const Query amp; b ) return a .\nk lt; b .\nk ; Phần xử_lý chính sẽ như_sau : vector lt; Query gt; queries ; // các truy_vấn // Đọc vào các truy_vấn readInput (); // Sắp_xếp các truy_vấn sort ( queries .\nbegin () , queries .\nend ()); // Khởi tạo mảng id sao_cho : // aid1 , aid2 , aid3 là mảng a đã sắp_xếp tăng dần .\n// Khởi tạo Segment_Tree for ( Query q : queries ) while ( a id i lt;= q .\nk ) b id i = 0 ; // Cập_nhật cây Segment_Tree .\n++ i ; Vậy_ta có_thể viết hàm xây_dựng cây như_sau : void build ( int id , int l , int r ) if ( l == r ) // Nút id chỉ gồm 1 phần_tử st id = 1 ; return ; int mid = ( l + r ) / 2 ; build ( id 2 , l , mid ); build ( id 2 , mid + 1 , r ); st id = st id 2 + st id 2 + 1 ; Một hàm_cập_nhật khi ta muốn gán lại một vị_trí bằng 0 : void update ( int id , int l , int r , int u ) if ( u lt; l r lt; u ) // u nằm ngoài đoạn l , r return ; if ( l == r ) st id = 0 ; return ; int mid = ( l + r ) / 2 ; update ( id 2 , l , mid , u ); update ( id 2 + 1 , mid + 1 , r , u ); st id = st id 2 + st id 2 + 1 ; Và cuối_cùng là thực_hiện truy_vấn lấy tổng một đoạn : int get ( int id , int l , int r , int u , int v ) if ( v lt; l r lt; u ) // Đoạn l , r nằm ngoài đoạn u , v return 0 ; if ( u lt;= l amp;amp; r lt;= v ) // Đoạn l , r nằm hoàn_toàn trong đoạn u , v return st id ; int mid = ( l + r ) / 2 ; return get ( id 2 , l , mid , u , v ) + get ( id 2 + 1 , mid + 1 , r , u , v ); 2 .\nLazy_Propagation_Đây là kĩ_thuật được sử_dụng trong ST để giảm độ phức_tạp của ST với các truy_vấn cập_nhật đoạn .\nTư_tưởng Giả_sử_ta cần cập_nhật đoạn u , v .\nDễ thấy ta không_thể_nào cập_nhật tất_cả các nút trên Segment_Tree (do tổng_số nút nằm trong đoạn u , v có_thể lên đến O(N)) .\nDo_đó , trong quá_trình cập_nhật , ta chỉ thay_đổi giá_trị ở các nút quản_lý các đoạn to nhất nằm trong u , v .\nVí_dụ với N = 7 , cây Segment tree như hình minh_hoạ ở đầu_bài .\nGiả_sử bạn cần cập_nhật 1 , 6 : Bạn chỉ cập_nhật giá_trị ở các nút quản_lý các đoạn 1 , 4 và 5 , 6 .\nGiá_trị của các nút quản_lý các đoạn 1 , 2 , 3 , 4 , 1 , 1 , 2 , 2 , 5 , 5 , . . .\nsẽ không đúng .\nTa sẽ chỉ cập_nhật lại giá_trị của các nút này khi thật_sự cần_thiết (Do đó kĩ_thuật này được gọi_là lazy - lười biếng) .\nCụ_thể , chúng_ta cùng xem bài_toán sau : Bài_Toán VOJ - QMAX2 Tóm_tắt_đề Cho dãy_số A với N phần_tử (N \\le 50 , 000) .\nBạn cần thực_hiện 2 loại truy_vấn : Cộng tất_cả các số trong đoạn l , r lên_giá trị val .\nIn ra giá_trị lớn nhất của các số trong đoạn l , r .\nPhân_tích Thao_tác 2 là thao_tác cơ_bản trên Segment_Tree , đã được ta phân_tích ở bài_toán đầu_tiên .\nVới thao_tác 1 , truy_vấn đoạn u , v .\nGiả_sử_ta gọi F(id) là giá_trị lớn nhất trong đoạn mà nút id quản_lý .\nTrong_lúc cập_nhật , muốn hàm này thực_hiện với độ phức_tạp không quá O(\\logN) , thì khi đến 1 nút id quản_lý đoạn l , r với đoạn l , r nằm hoàn_toàn trong đoạn u , v , thì ta không được đi_vào các nút con của nó nữa (nếu không độ phức_tạp sẽ là O(N) do ta đi_vào tất_cả các nút nằm trong đoạn u , v) .\nĐể giải_quyết , ta dùng kĩ_thuật Lazy_Propagation như_sau : Lưu_T(id) với ý_nghĩa , tất_cả các phần_tử trong đoạn l , r mà nút id quản_lý đều được cộng thêm T(id) .\nTrước_khi ta_cập nhật hoặc lấy 1 giá_trị của 1 nút id nào_đó , ta phải đảm_bảo ta đã \"đẩy\" giá_trị của mảng T ở tất_cả các nút tổ_tiên của id xuống id .\nĐể làm được điều này , ở các hàm_get và update , trước_khi gọi đệ_quy xuống các con 2 id và 2 id+1 , ta phải gán : Tid2 += Tid_Tid2+1 += Tid_Tid = 0 chú_ý ta cần phải thực_hiện thao_tác này , nếu_không mỗi phần_tử của dãy sẽ bị cộng nhiều lần , do ta đẩy xuống nhiều lần .\nChú_ý : Bài_QMAX2 này có cách cài_đặt khác không sử_dụng Lazy_Propagation , tuy_nhiên sẽ không được trình_bày ở đây .\nCài_đặt Ta có kiểu dữ_liệu cho 1 nút của ST như_sau : struct Node int lazy ; // giá_trị T trong phân_tích trên int val ; // giá_trị lớn nhất .\nnodes MAXN 4 ; Hàm \"đẩy\" giá_trị T xuống các con : void down ( int id ) int t = nodes id .\nlazy ; nodes id 2 .\nlazy += t ; nodes id 2 .\nval += t ; nodes id 2 + 1 .\nlazy += t ; nodes id 2 + 1 .\nval += t ; nodes id .\nlazy = 0 ; Hàm_cập_nhật : void update ( int id , int l , int r , int u , int v , int val ) if ( v lt; l r lt; u ) return ; if ( u lt;= l amp;amp; r lt;= v ) // Khi cài_đặt , ta LUÔN ĐẢM_BẢO giá_trị của nút được cập_nhật ĐỒNG_THỜI với // giá_trị lazy propagation .\nNhư_vậy sẽ tránh sai_sót .\nnodes id .\nval += val ; nodes id .\nlazy += val ; return ; int mid = ( l + r ) / 2 ; down ( id ); // đẩy giá_trị lazy propagation xuống các con update ( id 2 , l , mid , u , v , val ); update ( id 2 + 1 , mid + 1 , r , u , v , val ); nodes id .\nval = max ( nodes id 2 .\nval , nodes id 2 + 1 .\nval ); Hàm lấy giá_trị lớn nhất : int get ( int id , int l , int r , int u , int v ) if ( v lt; l r lt; u ) return - INFINITY ; if ( u lt;= l amp;amp; r lt;= v ) return nodes id .\nval ; int mid = ( l + r ) / 2 ; down ( id ); // đẩy giá_trị lazy propagation xuống các con return max ( get ( id 2 , l , mid , u , v ) , get ( id 2 + 1 , mid + 1 , r , u , v )); // Trong các bài_toán tổng_quát , giá_trị ở nút id có_thể bị thay_đổi (do ta đẩy lazy propagation // xuống các con) .\nKhi đó , ta cần cập_nhật lại thông_tin của nút id dựa trên thông_tin của các con .\nĐến đây các bạn đã nắm được kiến_thức cơ_bản về Segment_Tree .\nNhững phần tiếp_theo nói về các kiến_thức nâng_cao - các mở_rộng của ST .\nBạn nên làm nhiều bài luyện_tập (tham khảo ở cuối bài) trước_khi nghiên_cứu tiếp .\n3 .\nỨng_dụng với cấu_trúc mảng động Trong loại bài_toán này với mỗi nút của cây_ta lưu lại một vector và một_số biến khác .\nVí_dụ KQUERY2 .\nTóm_tắt_đề Cho dãy A với N phần_tử .\nCần trả_lời Q truy_vấn .\nCó 2 loại truy_vấn : Cập_nhật : Gán A_i = v Truy_vấn : đếm_số phần_tử lớn hơn k trong đoạn l , r .\nGiới_hạn : N \\le 30 , 000 A_i , v \\le 10 , 000 Q \\le 200 , 000 Bài này tương_đối giống với bài KQUERY đã phân_tích ở trên , tuy_nhiên vì có thao_tác cập_nhật , nên ta buộc phải xử_lý online .\nPhân_tích Có \\logN nút mà ta cần xét khi trả_lời truy_vấn của đoạn u , v .\nNếu trên mỗi nút chúng_ta có_thể lưu lại danh_sách các phần_tử đó theo thứ_tự tăng dần , ta có_thể tìm_ra kết_quả ở mỗi nút bằng tìm_kiếm nhị_phân .\nVì_thế với mỗi nút ta lưu lại một vector chứa các phần_tử từ l đến r theo thứ_tự tăng dần .\nĐiều này có_thể được thực_hiện với bộ phức_tạp bộ_nhớ là \\mathcalO(N\\logN) do mỗi phần_tử có_thể ở tối_đa \\mathcalO(\\logN) nút (độ sâu của cây không quá \\mathcalO(\\logN)) .\nỞ mỗi nút cha có ta có_thể gộp hai nút con vào nút cha bằng phương_pháp giống_như Merge_Sort (lưu lại hai biến chạy và so_sánh lần_lượt từng phần_tử ở hai mảng) để có_thể xây_dựng cây trong \\mathcalO(N\\logN) .\nHàm xây cây có_thể được như_sau : void build ( int id , int l , int r ) if ( l == r ) // Đoạn gồm 1 phần_tử .\nTa dễ_dàng khởi tạo nút trên ST .\nst id .\npush_back ( a l ); return ; int mid = ( l + r ) / 2 ; build ( id 2 , l , mid ); build ( id 2 + 1 , mid + 1 , r ); merge ( st id 2 .\nbegin () , st id 2 .\nend () , st id 2 + 1 .\nbegin () , st id 2 + 1 .\nend () , st id .\nbegin ()); Và hàm truy_vấn có_thể cài_đặt như_sau : int get ( int id , int l , int r , int u , int v , int k ) // Trả_lời truy_vấn (x , y , k) if ( v lt; l r lt; u ) return 0 ; if ( u lt;= l amp;amp; r lt;= v ) // Đếm_số phần_tử gt; K bằng chặt nhị_phân return st id .\nsize () - ( upper_bound ( st id .\nbegin () , st id .\nend () , k ) - st id .\nbegin ()); int mid = ( l + r ) / 2 ; return get ( id 2 , l , mid , u , v , k ) + get ( id 2 + 1 , mid + 1 , r , u , v , k ); Một ví_dụ khác là bài Component_Tree 4 .\nỨng_dụng với cấu_trúc set Ở cấu_trúc này mỗi nút chúng_ta lưu một set , multiset , hashmap , hoặc unodered map và một_số biến khác .\nĐây là một bài_toán ví_dụ : Cho n vector a_1 , a_2 , a_3 , . . . , a_n rỗng ban_đầu .\nChúng_ta có_thể thực_hiện m truy_vấn trên những vector này : Truy_vấn A_p_k là thêm số k vào cuối vector a_p .\nTruy_vấn C l r k là xuất ra \\sum_i=lrcount(a_i , k) , với count(a_i , k) là số lần xuất_hiện của số k trong vector a_i .\nBài_toán này chúng_ta lưu lại mỗi nút của cây là một multiset s , với mỗi nút lưu_số k đúng \\sum_i=lrcount(a_i , k) lần với độ phức_tạp bộ_nhớ chỉ \\mathcalO(q\\logn) .\nVới mỗi truy_vấn C x y k chúng_ta sẽ in ra tổng của tất_cả dùng cây phân_đoạn và truy_vấn trên set trong mỗi đoạn thuộc đoạn x đến y_như truy trên truy_vấn cây phân_đoạn bình_thường .\nChúng_ta sẽ không có hàm xây cây do các vector ban_đầu đang là rỗng , nhưng chúng_ta sẽ có thêm hàm_cộng phần_tử vào như_sau : void add ( int id , int l , int r , int p , int k ) // Thực_hiện truy_vấn A_p_k s id .\ninsert ( k ); if ( l == r ) return ; int mid = ( l + r ) / 2 ; if ( p lt;= mid ) add ( id 2 , l , mid , p , k ); else add ( id 2 + 1 , mid + 1 , r , p , k ); Và một hàm cho truy_vấn 2 : int ask ( int id , int l , int r , int x , int y , int k ) // Trả_lời C x y k if ( y lt; l r lt; x ) return 0 ; if ( x lt;= l amp;amp; r lt;= y ) return s id .\ncount ( k ); int mid = ( l + r ) / 2 ; return ask ( id 2 , l , mid , x , y , k ) + ask ( id 2 + 1 , mid + 1 , r , x , y , k ); 5 .\nỨng_dụng với các cấu_trúc dữ_liệu khác Cây phân_đoạn còn có_thể có_thể sử_dụng một_cách linh_hoạt với các cấu_trúc dữ_liệu khác như ở trên .\nSử_dụng một cây phân_đoạn khác trên từng nút có_thể giúp chúng_ta truy_vấn dễ_dàng hơn trên mảng hai chiều .\nTrên đây cũng có_thể là các loại cây như Cây tiền tố(Trie) hoặc cũng có_thể là cấu_trúc Disjoint_Set .\nSau_đây mình xin giới_thiệu một loại cây khác cũng sử_dụng nhiều trong cây phân_đoạn đó chính là Cây_Fenwick (Binary Indexed_Tree) : Như_trên mỗi nút của cây sẽ là một cây Fenwick và có_thể một_số biến khác .\nDưới_đây là một bài_toán ví_dụ : Cho n vectors a_1 , a_2 , a_3 , . . . , a_n rỗng ban_đầu .\nChúng_ta cần thực_hiện hai loại truy_vấn : Truy_vấn A_p_k là thêm số k vào đằng_sau vector a_p .\nTruy_vấn C l r k là xuất ra \\sum_i=lrcount(a_i , j) với j\\le k với count(a_i , j) là số lần xuất_hiện k trong a_i .\nVới bài_toán này , ta cũng lưu lại ở một nút là một vector v chứa số k khi và chỉ khi \\sum_i=lrcount(a_i , j)\\ne 0 (độ phức_tạp bộ_nhớ sẽ là \\mathcalO(q\\logn) ) (các số theo theo thứ_tự tăng dần) Đầu_tiên , đọc và lưu các truy_vấn lại với mỗi truy_vấn loại 1 ta sẽ thêm v vào tất_cả vector có chứa phần_tử p .\nSau_đó ta tiến_hành sắp_xếp các truy_vấn theo phương_pháp Merge_Sort đã nói ở trên và dùng hàm unique để loại các phần_tử trùng .\nSau_đó chúng_ta sẽ xây_dụng ở mỗi nút một cây Fenwick có độ lớn bằng độ_dài vector .\nSau_đây là hàm thêm giá_trị : void insert ( int id , int l , int r , int p , int k ) // Thực_hiện A_p_k if ( l == r ) v id .\npush_back ( k ); return ; int mid = ( l + r ) / 2 ; if ( p lt; mid ) insert ( id 2 , l , mid , p , k ); else insert ( id 2 + 1 , mid + 1 , r , p , k ); Hàm sắp_xếp sau khi đã đọc hết các truy_vấn : void sort_ ( int id , int l , int r ) if ( l == r ) return ; int mid = ( l + r ) / 2 ; sort_ ( id 2 , l , mid ); sort_ ( id 2 + 1 , mid + 1 , r ); merge ( v 2 id .\nbegin () , v 2 id .\nend () , v 2 id + 1 .\nbegin () , v 2 id + 1 .\nend () , v id .\nbegin ()); Với mỗi truy_vấn loại 1 ta làm như_sau với mỗi nút x : for ( int i = a + 1 ; i lt; fen x .\nsize (); i += i amp; - i ) fen x i ++ ; Với tất_cả vxa=k : void update ( int id , int l , int r , int p , int k ) int a = lower_bound ( v id .\nbegin () , v id .\nend () , k ) - v id .\nbegin (); for ( int i = a + 1 ; i lt; fen id .\nsize (); i += i amp; - i ) fen id i ++ ; if ( l == r ) return ; int mid = ( l + r ) / 2 ; if ( p lt; mid ) update ( id 2 , l , mid , p , k ); else update ( id 2 + 1 , mid + 1 , r , p , k ); Còn_lại việc tính_toán truy_vấn loại 2 trở_nên dễ_dàng hơn : int ask ( int id , int l , int r , int x , int y , int k ) // Trả_lời C x y-1 k if ( y lt; l r lt; x ) return 0 ; if ( x lt;= l amp;amp; r lt;= y ) int a = lower_bound ( v id .\nbegin () , v id .\nend () , k ) - v id .\nbegin (); int ans = 0 ; for ( int i = a + 1 ; i gt; 0 ; i -= i amp; - i ) ans += fen id i ; return ans ; int mid = ( l + r ) / 2 ; return ask ( id 2 , l , mid , x , y , k ) + ask ( id 2 + 1 , mid + 1 , r , x , y , k ); 6 .\nỨng_dụng trong cây có gốc Ta có_thể thấy cây phân_đoạn là một ứng_dụng trong mảng , vì lí_do đó nếu chúng_ta có_thể đổi cây thành các mảng , ta có_thể dễ_dàng xử_lý các truy_vấn trên cây .\nĐây là tư_tưởng của Heavy_Light_Decomposition .\nBài_tập ví_dụ : 396C - On_Changing_Tree_Gọi h_v là độ_cao tương_ứng của nút v .\nTa có với mỗi nút u trong cây_con gốc v sau truy_vấn một giá_trị của nó sẽ tăng một lượng là x+(h_u-h_v)-k=x+k h_v-k h .\nKết_quả của truy_vấn 2 sẽ là \\sum_i\\in s(k_ih_v_i+x_i)-h_u\\sum_i\\in sk_i .\nVì_vậy ta chỉ_cần tính hai giá_trị là \\sum_i\\in s(k_i h_v_i+x_i) và \\sum_i\\in sk_i .\nVậy với mỗi nút ta có_thể lưu lại hai giá_trị là hkx=\\sum x +hk và sk=\\sum k (không cần lazy propagation do chúng_ta chỉ update nút đầu_tiên thỏa_việc nằm trong đoạn .\nVới truy_vấn cập_nhật : void update ( int id , int l , int r , int x , int k , int v ) if ( s v gt;= r l gt;= f v ) return ; if ( s v lt;= l amp;amp; r lt;= f v ) hkx id = ( hkx id + x ) % mod ; int a = ( 1LL h v k ) % mod ; hkx id = ( hkx id + a ) % mod ; sk id = ( sk id + k ) % mod ; return ; int mid = ( l + r ) / 2 ; update ( id 2 , l , mid , x , k , v ); update ( id 2 + 1 , mid + 1 , r , x , k , v ); Và truy_vấn : int ask ( int id , int l , int r , int v ) int a = ( 1LL h v sk id ) % mod ; int ans = ( hkx id + mod - a ) % mod ; if ( l == r ) return ans ; int mid = ( l + r ) / 2 ; if ( s v lt; mid ) return ( ans + ask ( 2 id , l , mid , v )) % mod ; return ( ans + ask ( 2 id + 1 , mid , r , v )) % mod ; 7 .\nPersistent_Segment_Trees_Persistent_Data_Structures là những cấu_trúc dữ_liệu được dùng khi chúng_ta cần có toàn_bộ lịch_sử của các thay_đổi trên 1 cấu_trúc dữ_liệu (CTDL) .\nCác bạn có_thể đọc thêm ở : Persistent_Data_Structures 8 .\nIT đoạn_thẳng Bài_toán Cho một_tập hợp chứa các đường_thẳng có dạng ax + b , mỗi đường_thẳng được biểu_diễn bằng một cặp số (a , b) .\nCần thực_hiện hai truy_vấn : Thêm một đường_thẳng vào tập_hợp .\nTrả_lời xem tại hoành_độ q , điểm nào thuộc ít_nhất một đường_thẳng trong tập có tung_độ lớn nhất .\nNói_cách_khác , đường_thẳng (a , b) nào có aq + b lớn nhất .\nĐể giải bài_toán này , hai cách phổ_biến là ứng_dụng bao lồi và sử_dụng cây Interval_Tree lưu đoạn_thẳng Bài_tập áp_dụng : VOJ - QMAX_VOJ - NKLINEUP_VOJ - GSS_VOJ - LITES_VOJ - DQUERY_VOJ - KQUERY_FREQUENT_VOJ - KQUERY2_GSS2_GSS3_MULTQ3_POSTERS_PATULJCI_New_Year_Domino_Copying_Data_DZY_Loves_Fibonacci_Numbers_FRBSUM_Đọc thêm : Cấu_trúc dữ_liệu đặc_biệt - Đoàn Mạnh_Hùng Cấu_trúc dữ_liệu đặc_biệt - Nguyễn_Minh Hiếu_Các nguồn tham_khảo : Codeforces Một_số vấn_đề đáng chú_ý trong môn Tin_học\n", "tagged": "Table/Np of_Contents/Np 0/M ./CH\nGiới_thiệu/V Ví_dụ/C Cài_đặt/V Áp_dụng/V Phân_tích/V thời_gian/N chạy/V Thao_tác/V loại/N 1/M Thao_tác/V loại/N 2/M Phân_tích/V bộ_nhớ/Np 1/M ./CH\nSegment_Tree/Np cổ_điển/A Ví_dụ/C 1/M Tóm_tắt_đề/Np Lời_giải/Np Định_lý/Np Ví_dụ/C 2/M 2/M ./CH\nLazy_Propagation/Np Tư_tưởng/N Bài_Toán/N Tóm_tắt_đề/Np Phân_tích/V Cài_đặt/V 3/M ./CH\nỨng_dụng/V với/E cấu_trúc/N mảng/N động/N Ví_dụ/C Tóm_tắt_đề/Np Phân_tích/V 4/M ./CH\nỨng_dụng/V với/E cấu_trúc/N set/N 5/M ./CH\nỨng_dụng/V với/E các/L cấu_trúc/N dữ_liệu/N khác/A 6/M ./CH\nỨng_dụng/V trong/E cây/N có/V gốc/N 7/M ./CH\nPersistent_Segment_Trees/Np 8/M ./CH\nIT/Np đoạn_thẳng/Np Bài_tập/Np áp_dụng/V :/CH Đọc/V thêm/V :/CH Các/L nguồn/N tham_khảo/V :/CH LƯU_Ý/V :/CH Segment_Tree/Np trong/E 1/M số/N tài_liệu/N Tiếng_Việt/Np còn/R được/V dịch/N là/V Interval_Tree/Np ./CH\nỞ/E bài/N viết/V này/P ,/CH mình/P sẽ/R dùng/V tên/N Segment_Tree/Np (ST)/Np -/CH tên_gọi/Np phổ_biến/V hơn/A của/E CTDL/Np này/P ./CH\nTất_cả/P hàm/Np trong/E bài/N đều/R đánh_số/Np từ/E 1/M ./CH\nCác/L nút/N của/E cây/N phân_đoạn/Np sẽ/R quản_lý/V đoạn/Nc l/Ny ,/CH r/Np Segment_Tree/Np còn/R có_một/Np cách/N cài_đặt/V khác/A sử_dụng/V ít/A bộ_nhớ/Np hơn/A (tối/Np đa/Z 2N/Np phần/N tử)/Np ,/CH cài_đặt/V ngắn/A hơn/A và/Cc chạy/V nhanh/A hơn/A ./CH\nTuy_nhiên/C theo/V cá_nhân/N mình/P không/R dễ_hiểu/Np bằng/E cách/N cài_đặt/V trong/E bài/N viết/V này/P ./CH\n0/M ./CH\nGiới_thiệu/V Segment_Tree/Np là/V một/M cấu_trúc/N dữ_liệu/N được/V sử_dụng/V rất/R nhiều/A trong/E các/L kỳ/N thi/V ,/CH đặc_biệt/A là/V trong/E những/L bài_toán/N xử_lý/V trên/E dãy_số/Np ./CH\nSegment_Tree/Np là/V một/M cây/N ./CH\nCụ_thể/A hơn/A ,/CH nó/P là/V một/M cây/N nhị_phân/Np đầy_đủ/A (mỗi/Np nút/N là/V lá/N hoặc/Cc có/V đúng/A 2/M nút/N con)/Np ,/CH với/E mỗi/L nút/N quản_lý/V một/M đoạn/Nc trên/E dãy_số/Np ./CH\nVới/E một/M dãy_số/Np gồm/V N/Ny phần_tử/N ,/CH nút/N gốc/N sẽ/R lưu_thông_tin/Np về/E đoạn/Nc 1/M ,/CH N/Ny ,/CH nút/N con/Nc trái/Nc của/E nó/P sẽ/R lưu_thông_tin/Np về/E đoạn/Nc 1/M ,/CH ⌊N/Np và/Cc nút/N con/Nc phải/V sẽ/R lưu_thông_tin/Np về/E đoạn/Nc ⌊N/Np ,/CH N/Ny ./CH\nTổng_quát/Np hơn/A :/CH nếu/C nút/N A/Ni lưu_thông_tin/Np đoạn/Nc i/M ,/CH j/Np ,/CH thì/C 2/M con/Nc của/E nó/P :/CH A1/Np và/Cc A2/Np sẽ/R lưu_thông_tin/Np của/E các/L đoạn/Nc i/M ,/CH ⌊(i+j)/Np và/Cc đoạn/Nc ⌊(i+j)/Np +/CH 1/M ,/CH j/Np ./CH\nVí_dụ/C Xét/V một/M dãy/Nc gồm/V 7/M phần_tử/N ,/CH Segment_Tree/Np sẽ/R quản_lý/V các/L đoạn/Nc như_sau/Np :/CH Cài_đặt/V Để/E cài_đặt/V ,/CH ta/P có_thể/R dùng/V một/M mảng/N 1/M chiều/N ,/CH phần_tử/N thứ/N nhất/A của/E mảng/N thể_hiện/V nút/N gốc/N ./CH\nPhần_tử/N thứ/N id/Np sẽ/R có/V 2/M con/Nc là/V 2/M id/Np (con/Np trái)/Np và/Cc 2/M id+1/Np (con/Np phải)/Np ./CH\nVới/E cách/N cài_đặt/V này/P ,/CH người_ta/P đã/R chứng_minh/V được/V bộ_nhớ/Np cần_dùng/Np cho/E ST/Np không/R quá/R 4/M N/Ny phần_tử/N ./CH\nÁp_dụng/V Để/E dễ/A hình_dung/V ,/CH ta/P lấy/V 1/M ví_dụ/C cụ_thể/A :/CH Cho/E dãy/Nc N/Ny phần_tử/N (N/Np \\le/Np 105)/Np ./CH\nBan_đầu/N mỗi/L phần_tử/N có/V giả/A trị/V 0/M ./CH\nCó_Q/Np truy_vấn/Np (Q/Np \\le/Np 105)/Np ./CH\nMỗi/L truy_vấn/Np có/V 1/M trong/E 2/M loại/N :/CH Gán/V giá_trị/N v/Nu cho/E phần_tử/N ở/E vị_trí/N i/M ./CH\nTìm/V giá_trị/N lớn/A nhất/A cho/E đoạn/Nc i/M ,/CH j/Np ./CH\nCách/N đơn_giản/A nhất_là/X dùng/V 1/M mảng/N A/Ni duy_trì/V giá_trị/N các/L phần_tử/N ./CH\nVới/E thao_tác/V 1/M thì/C ta/P gán/V Ai/P =/CH v/Nu ./CH\nVới/E thao_tác/V 2/M thì/C ta/P dùng/V 1/M vòng_lặp/Np từ/E i/M đến/E j/Np để/E tìm/V giá_trị/N lớn/A nhất/A ./CH\nRõ_ràng/A cách/N này/P có/V độ/N phức_tạp/A là/V O(NQ)/Np và/Cc không_thể/R chạy/V trong/E thời_gian/N cho_phép/V ./CH\nCách/N dùng/V Segment_Tree/Np như_sau/Np :/CH Với/E truy_vấn/Np loại/N 1/M ,/CH ta/P sẽ/R cập_nhật/V thông_tin/N của/E các/L nút/N trên/E cây/N ST/Np mà/C đoạn/Nc nó/P quản_lý_chứa/Np phần_tử/N i/M ./CH\nVới/E truy_vấn/Np loại/N 2/M ,/CH ta/P sẽ/R tìm/V tất_cả/P các/L nút/N trên/E cây/N ST/Np mà/C đoạn/Nc nó/P quản_lý/V nằm/V trong/E i/M ,/CH j/Np ,/CH rồi/C lấy/V max/Np của/E các/L nút/N này/P ./CH\nCài_đặt/V như_sau/Np :/CH //CH Truy_vấn/Np :/CH A(i)/Np =/CH v/Nu //CH Hàm_cập_nhật/Np trên/E cây/N ST/Np ,/CH cập_nhật/V cây_con/Np gốc/N id/Np quản_lý/V đọan/Np l/Ny ,/CH r/Np void/Np update/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np i/M ,/CH int/Np v/Nu )/CH if/Np (/CH i/M lt;/Np l/Ny r/Np lt;/Np i/M )/CH //CH i/M nằm/V ngoài/E đoạn/Nc l/Ny ,/CH r/Np ,/CH ta/P bỏ_qua/V nút/N i/M return/Np ;/CH //CH i/M nằm/V trong/E đoạn/Nc l/Ny ,/CH r/Np ,/CH ta/P cần/V cập_nhật/V nút/N id/Np ST/Np id/Np =/CH max/Np (/CH ST/Np id/Np ,/CH v/Nu );/CH if/Np (/CH l/Ny ==/Np r/Np )/CH //CH Đoạn/Nc chỉ/R gồm/V 1/M phần_tử/N ,/CH không/R có/V nút/N con/Nc return/Np ;/CH //CH Gọi/V đệ_quy/Np để/E xử_lý/V các/L nút/N con/Nc của/E nút/N id/Np int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH update/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH i/M ,/CH v/Nu );/CH update/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH i/M ,/CH v/Nu );/CH //CH Truy_vấn/Np :/CH tìm/V max/Np đoạn/Nc u/N ,/CH v/Nu //CH Hàm/Np tìm/V max/Np các/L phần_tử/N trên/E cây/N ST/Np nằm/V trong/E cây_con/Np gốc/N id/Np -/CH quản_lý/V đoạn/Nc l/Ny ,/CH r/Np int/Np get/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH //CH Đoạn/Nc u/N ,/CH v/Nu không/R giao/V với/E đoạn/Nc l/Ny ,/CH r/Np ,/CH ta/P bỏ_qua/V đoạn/Nc này/P return/Np -/CH INFINITY/Np ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH //CH Đoạn/Nc l/Ny ,/CH r/Np nằm/V hoàn_toàn/A trong/E đoạn/Nc u/N ,/CH v/Nu mà/C ta/P đang/R truy_vấn/Np ,/CH ta/P trả_lại/Np //CH thông_tin/N lưu/V ở/E nút/N id/Np return/Np ST/Np id/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH //CH Gọi/V đệ_quy/Np với/E các/L con/Nc của/E nút/N id/Np return/Np max/Np (/CH get/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu )/CH ,/CH get/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu ));/Np Phân_tích/V thời_gian/N chạy/V Mỗi/L thao_tác/V truy_vấn/Np trên/E cây/N ST/Np có/V độ/N phức_tạp/A O(\\logN)/Np ./CH\nĐể/E chứng_minh/V điều/N này/P ,/CH ta/P xét/V 2/M loại/N thao_tác/V trên/E cây/N ST/Np :/CH Truy_vấn/Np 1/M phần_tử/N trên/E ST/Np (giống/Np thao_tác/V update/Np ở/E trên)/Np Truy_vấn/Np nhiều/A phần_tử/N trên/E ST/Np (giống/Np thao_tác/V get/Np ở/E trên)/Np Đầu_tiên_ta/Np có_thể/R chứng_minh/V được/V :/CH Độ_cao/Np của/E cây/N ST/Np không/R quá/R O(\\logN)/Np ./CH\nTại/E mỗi/L độ/N sâu/A của/E cây/N ,/CH không/R có/V phần_tử/N nào/P nằm/V trong/E 2/M nút/N khác_nhau/Np của/E cây/N ./CH\nThao_tác/V loại/N 1/M Với/E thao_tác/V này/P ,/CH ở/E mỗi/L độ/N sâu/A của/E cây/N ,/CH ta/P chỉ/R gọi/V đệ_quy/Np các/L con/Nc của/E không/R quá/R 1/M nút/N ./CH\nPhân_tích/V đoạn/Nc code/Np trên/E ,/CH ta/P xét/V các/L trường_hợp/N :/CH Phần_tử/N cần/V xét/V không/R nằm/V trong/E đoạn/Nc l/Ny ,/CH r/Np do/E nút/N id/Np quản_lý/V ./CH\nTrường_hợp/N này/P ta/P dừng/V lại/R ,/CH không/R xét/V tiếp/V ./CH\nPhần_tử/N cần/V xét/V nằm/V trong/E đoạn/Nc l/Ny ,/CH r/Np do/E nút/N id/Np quản_lý/V ./CH\nTa/P xét/V các/L con/Nc của/E nút/N id/Np ./CH\nTuy_nhiên/C chỉ_có/Np 1/M con/Nc của/E nút/N id_chứa/Np phần_tử/N cần/V xét/V và/Cc ta/P sẽ/R phải/V xét/V tiếp/V các/L con/Nc của/E nút/N này/P ./CH\nVới/E con/Nc còn_lại/Np ,/CH ta/P sẽ/R dừng/V ngay/R mà/C không/R xét/V các/L con/Nc của/E nó/P nữa/R ./CH\nDo_đó/C độ/N phức_tạp/A của/E thao_tác/V này/P không/R quá/R O(\\logN)/Np ./CH\nThao_tác/V loại/N 2/M Với/E thao/Np này/P ,/CH ta/P cũng/R chứng_minh/V tương_tự/A ,/CH nhưng/C ở/E mỗi/L độ/N sâu/A của/E cây/N ,/CH ta/P chỉ/R gọi/V hàm/Np đệ_quy/Np với/E các/L con/Nc của/E không/R quá/R 2/M nút/N ./CH\nTa/P chứng_minh/V bằng/E phản_chứng/Np ,/CH giả_sử_ta/Np gọi/V đệ_quy/Np với/E 3/M nút/N khác_nhau/Np của/E cây/N ST/Np (đánh/Np dấu/N màu/N đỏ)/Np :/CH Trong/E trường_hợp/N này/P ,/CH rõ_ràng/A toàn_bộ/L đoạn/Nc của/E nút/N ở/E giữa/N quản_lý/V nằm/V trong/E đoạn/Nc đang/R truy_vấn/Np ./CH\nDo_đó/C ta/P không/R cần/V phải/V gọi/V đệ_quy/Np các/L con/Nc của/E nút/N ở/E giữa/N ./CH\nTừ_đó/Np suy/V ra/V vô_lý/A ,/CH nghĩa_là/V ở/E mỗi/L độ/N sâu_ta/Np chỉ/R gọi/V đệ_quy/Np với/E không/R quá/R 2/M nút/N ./CH\nPhân_tích/V bộ_nhớ/Np Ta/P xét/V 2/M trường_hợp/N :/CH N/Ny =/CH 2k/Np :/CH Cây_ST/Np đầy_đủ/A ,/CH ở/E độ/N sâu/A cuối_cùng/A có/V đúng/A 2k/Np lá/N ,/CH và/Cc các/L độ/N sâu/A thấp/A hơn/A không/R có/V nút/N lá/N nào/P (và/Np các/L nút/N này/P đều/R có/V đúng/A 2/M con)/Np ./CH\nNhư_vậy/X :/CH Tầng/N k/N :/CH có/V 2k/Np nút/N Tầng/N k-1/Np :/CH có/V 2k-1/Np nút/N ./CH ./CH ./CH\nTổng_số/N nút/N không/R quá/R 2k+1/Np ./CH\nVới_N/Np gt;/Np 2k/Np và/Cc N/Ny lt;/Np 2k+1/Np ./CH\nSố/N nút/N của/E cây/N ST/Np không/R quá/R số/N nút/N của/E cây/N ST/Np với/E N/Ny =/CH 2k+1/Np ./CH\nDo_đó/C ,/CH số/N nút/N của/E cây/N cho/E dãy/Nc N/Ny phần_tử/N ,/CH với/E N/Ny \\le/Np 2k/Np là/V không/R quá/R 2k+1/Np ,/CH giá_trị/N này/P xấp_xỉ/A 4/M N/Ny ./CH\nBằng/E thực_nghiệm/V ,/CH ta/P thấy/V dùng/V 4/M N/Ny là/V đủ/A ./CH\n1/M ./CH\nSegment_Tree/Np cổ_điển/A Tại_sao/X lại/R gọi_là/V cổ_điển/A ?/CH\nĐây/P là/V dạng/N ST/Np đơn_giản/A nhất/A ,/CH chúng_ta/P chỉ/R giải_quyết/V truy_vấn/Np update/Np một/M phần_tử/N và/Cc truy_vấn/Np đoạn/Nc ,/CH mỗi/L nút/N lưu/V một/M loại/N dữ_liệu/N cơ_bản/A như/C số_nguyên/Np ,/CH boolean/Np ,/CH ./CH ./CH ./CH\nVí_dụ/C 1/M Bài_toán/N :/CH 380C-Codeforces/Np Tóm_tắt_đề/Np Cho/E một/M dãy/Nc ngoặc/Np độ_dài/Np N/Ny (N\\le106)/Np ,/CH cho/E M/Nu truy_vấn/Np có/V dạng/N l_i/Np ,/CH r_i/Np (1\\le/Np l_i\\le/Np r_i/Np \\le/Np N)/Np ./CH\nYêu_cầu/V của/E bài_toán/N là/V với/E mỗi/L truy_vấn/Np tìm/V một/M chuỗi/N con/Nc (không/Np cần/V liên/Z tiếp)/Np của/E chuỗi/N từ/E l_i/Np đến/E r_i/Np dài/A nhất/A mà/C tạo_thành/Np dãy/Nc ngoặc/Np đúng/A ./CH\nLời_giải/Np Với/E mỗi/L nút(ví/Np dụ/V như/C nút/N id/Np ,/CH quản_lý/V đoạn/Nc l/Ny ,/CH r)/Np chúng_ta/P lưu/V ba/M biến/V nguyên/A :/CH optimal/Np :/CH Là/V kết_quả/N tối_ưu/A trong/E đoạn/Nc l/Ny ,/CH r/Np ./CH\nopen/Np :/CH Số_lượng/N dấu/N (/CH sau/E khi/N đã/R xóa/V hết/V các/L phần_tử/N thuộc/V dãy/Nc ngoặc/Np đúng/A độ_dài/Np optimal/Np trong/E đoạn/Nc ./CH\nclose/Np :/CH Số_lượng/N dấu/N )/CH sau/E khi/N đã/R xóa/V hết/V các/L phần_tử/N thuộc/V dãy/Nc ngoặc/Np đúng/A độ_dài/Np optimal/Np trong/E đoạn/Nc ./CH\nTa/P tạo/V 1/M kiểu/N dữ_liệu/N cho/E 1/M nút/N của/E cây/N ST/Np như_sau/Np :/CH struct/Np Node/Np int/Np optimal/Np ;/CH int/Np open/Np ;/CH int/Np close/Np ;/CH Node/Np (/CH int/Np opt/Np ,/CH int/Np o/Nc ,/CH int/Np c/Ni )/CH //CH Khởi/V tạo/V struct/Np Node/Np optimal/Np =/CH opt/Np ;/CH open/Np =/CH o/Nc ;/CH close/Np =/CH c/Ni ;/CH ;/CH Và/Cc ta/P khai_báo/V cây/N ST/Np như_sau/Np :/CH Node/Np st/Np MAXN/Np 4/M ;/CH Định_lý/Np Để/E tính/V thông_tin/N ở/E nút/N id/Np quản_lý/V đoạn/Nc l/Ny ,/CH r/Np ,/CH dựa/V trên/E 2/M nút/N con/Nc 2id/Np và/Cc 2id+1/Np ,/CH ta/P định_nghĩa/N 1/M thao_tác/V kết_hợp/V 2/M nút/N của/E cây/N ST/Np :/CH Node/Np operator/Np +/CH (/CH const/Np Node/Np amp;/Np left/Np ,/CH const/Np Node/Np amp;/Np right/Np )/CH Node/Np res/Np ;/CH //CH min(số/Np dấu/N \"(\"/Np thừa/V ra/V ở/E cây_con/Np trái/Nc ,/CH và/Cc số/N dấu/N \")\"/Np thừa/V ra/V ở/E cây_con/Np phải)/Np int/Np tmp/Np =/CH min/Np (/CH left/Np ./CH\nopen/Np ,/CH right/Np ./CH\nclose/Np );/CH //CH Để/E xây_dựng/V kết_quả/N tối_ưu/A ở/E nút/N id/Np ,/CH ta/P nối/V dãy/Nc ngoặc/Np tối_ưu/A ở/E 2/M con/Nc ,/CH rồi/C thêm/V //CH min(số/Np \"(\"/Np thừa/V ra/V ở/E con/Nc trái/Nc ,/CH số/N \")\"/Np thừa/V ra/V ở/E con/Nc phải)/Np ./CH\nres/Np ./CH\noptimal/Np =/CH left/Np ./CH\noptimal/Np +/CH right/Np ./CH\noptimal/Np +/CH tmp/Np ;/CH res/Np ./CH\nopen/Np =/CH left/Np ./CH\nopen/Np +/CH right/Np ./CH\nopen/Np -/CH tmp/Np ;/CH res/Np ./CH\nclose/Np =/CH left/Np ./CH\nclose/Np +/CH right/Np ./CH\nclose/Np -/CH tmp/Np ;/CH return/Np res/Np ;/CH Ban_đầu/N ta/P có_thể/R khởi/V tạo/V cây/N như_sau/Np :/CH void/Np build/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np )/CH if/Np (/CH l/Ny ==/Np r/Np )/CH //CH Đoạn/Nc l/Ny ,/CH r/Np chỉ_có/Np 1/M phần_tử/N ./CH\nif/Np (/CH s/Y l/Ny ==/Np (/CH )/CH st/Np id/Np =/CH Node/Np (/CH 0/M ,/CH 1/M ,/CH 0/M );/CH else/Np st/Np id/Np =/CH Node/Np (/CH 0/M ,/CH 0/M ,/CH 1/M );/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH build/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np );/CH build/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np );/CH st/Np id/Np =/CH st/Np id/Np 2/M +/CH st/Np id/Np 2/M +/CH 1/M ;/CH Để/E trả_lời/V truy_vấn/Np ,/CH ta/P cũng/R làm/V tương_tự/A như/C trong/E bài_toán/N cơ_bản/A :/CH Node/Np query/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH //CH Trường_hợp/N không/R giao/V nhau/N return/Np Node/Np (/CH 0/M ,/CH 0/M ,/CH 0/M );/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH //CH Trường_hợp/N l/Ny ,/CH r/Np nằm/V hoàn_toàn/A trong/E u/N ,/CH v/Nu return/Np st/Np id/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH return/Np query/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu )/CH +/CH query/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu );/CH Ví_dụ/C 2/M Bài_toán/N :/CH SPOJ-KQUERY/Np Tóm_đề/Np :/CH Cho/E một/M dãy_số/Np a_i(1\\le/Np a_i/Np \\le/Np 109)/Np có/V N(1\\le_N/Np \\le/Np 30/M ,/CH 000)/Np phần_tử/N Cho_Q(1\\le_Q/Np \\le/Np 200/M ,/CH 000)/Np truy_vấn/Np có/V dạng/N 3/M số_nguyên/Np là/V l_i/Np ,/CH r_i/Np ,/CH k_i/Np (1\\le/Np l_i\\le/Np r_i\\le/Np N/Ny ,/CH 1\\le/Np k/N \\le/Np 109)/Np ./CH\nYêu_cầu/V của/E bài_toán/N là/V đếm_số/Np lượng/N số/N a_j/Np (l_i\\le/Np j/Np \\le/Np r_i)/Np mà/C a_j\\ge/Np k/N ./CH\nGiả_sử/Np chúng_ta/P có_một/Np mảng/N b/Ni với/E b_i=1/Np nếu/C a_igt;k/Np và/Cc bằng/E 0/M nếu/C ngược_lại/X ./CH\nThì/C chúng_ta/P có_thể/R dễ_dàng/A trả_lời/V truy_vấn/Np (i/Np ,/CH j/Np ,/CH k)/Np bằng/E cách/N lấy/V tổng_từ/Np i/M đến/E j/Np ./CH\nCách/N làm/V của/E bài/N này/P là/V xử_lý/V các/L truy_vấn/Np theo/V một/M thứ_tự/N khác/A ,/CH để/E ta/P có_thể/R dễ_dàng/A tính/V được/V mảng/N b/Ni ./CH\nKĩ_năng/N này/P được/V gọi_là/V xử_lý/V offline/Np (tương/Np tự/P nếu/C ta/P trả_lời/V các/L truy_vấn/Np theo/V đúng/A thứ_tự/N trong/E input/Np ,/CH thì/C được/V gọi_là/V xử_lý/V online/Vb )/CH :/CH Sắp_xếp/V các/L truy_vấn/Np theo/V thứ_tự/N tăng/V dần/R của/E k/N ./CH\nLúc/N đầu/N mảng/N b/Ni gồm/V toàn_bộ/L các/L số/N 1/M ./CH\nVới/E mỗi/L truy_vấn/Np ,/CH ta/P xem/V trong/E mảng/N a/Ni có/V những/L phần_tử/N nào/P lớn/A hơn/A giá_trị/N k/N của/E truy_vấn/Np trước/E ,/CH và/Cc nhỏ/A hơn/A giá_trị/N k/N của/E truy_vấn/Np hiện_tại/N ,/CH rồi/C đánh_dấu/V các_vị/Np trí/Np đó/P trên/E mảng/N b/Ni thành/V 0/M ./CH\nĐể/E làm/V được_việc/Np này/P một_cách/N hiệu_quả/N ,/CH ta/P cũng/R cần/V sắp_xếp/V lại/R mảng/N a/Ni theo/V thứ_tự/N tăng/V dần/R ./CH\nTa/P tạo/V kiểu/N dữ_liệu/N cho/E truy_vấn/Np :/CH struct/Np Query/Np int/Np k/N ;/CH int/Np l/Ny ,/CH r/Np ;/CH ;/CH //CH so_sánh/V 2/M truy_vấn/Np để/E dùng/V vào/E việc/N sort/Np ./CH\nbool/Np operator/Np lt;/Np (/CH const/Np Query/Np amp;/Np a/Ni ,/CH const/Np Query/Np amp;/Np b/Ni )/CH return/Np a/Ni ./CH\nk/N lt;/Np b/Ni ./CH\nk/N ;/CH Phần/N xử_lý/V chính/T sẽ/R như_sau/Np :/CH vector/Np lt;/Np Query/Np gt;/Np queries/Np ;/CH //CH các/L truy_vấn/Np //CH Đọc/V vào/E các/L truy_vấn/Np readInput/Np ();/Np //CH Sắp_xếp/V các/L truy_vấn/Np sort/Np (/CH queries/Np ./CH\nbegin/Np ()/Np ,/CH queries/Np ./CH\nend/Np ());/Np //CH Khởi/V tạo/V mảng/N id/Np sao_cho/Np :/CH //CH aid1/Np ,/CH aid2/Np ,/CH aid3/Np là/V mảng/N a/Ni đã/R sắp_xếp/V tăng/V dần/R ./CH\n//CH Khởi/V tạo/V Segment_Tree/Np for/Np (/CH Query/Np q/Ny :/CH queries/Np )/CH while/Np (/CH a/Ni id/Np i/M lt;=/Np q/Ny ./CH\nk/N )/CH b/Ni id/Np i/M =/CH 0/M ;/CH //CH Cập_nhật/V cây/N Segment_Tree/Np ./CH\n++/Np i/M ;/CH Vậy_ta/Np có_thể/R viết/V hàm/Np xây_dựng/V cây/N như_sau/Np :/CH void/Np build/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np )/CH if/Np (/CH l/Ny ==/Np r/Np )/CH //CH Nút/N id/Np chỉ/R gồm/V 1/M phần_tử/N st/Np id/Np =/CH 1/M ;/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH build/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np );/CH build/Np (/CH id/Np 2/M ,/CH mid/Np +/CH 1/M ,/CH r/Np );/CH st/Np id/Np =/CH st/Np id/Np 2/M +/CH st/Np id/Np 2/M +/CH 1/M ;/CH Một/M hàm_cập_nhật/Np khi/N ta/P muốn/V gán/V lại/R một/M vị_trí/N bằng/E 0/M :/CH void/Np update/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N )/CH if/Np (/CH u/N lt;/Np l/Ny r/Np lt;/Np u/N )/CH //CH u/N nằm/V ngoài/E đoạn/Nc l/Ny ,/CH r/Np return/Np ;/CH if/Np (/CH l/Ny ==/Np r/Np )/CH st/Np id/Np =/CH 0/M ;/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH update/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N );/CH update/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N );/CH st/Np id/Np =/CH st/Np id/Np 2/M +/CH st/Np id/Np 2/M +/CH 1/M ;/CH Và/Cc cuối_cùng/A là/V thực_hiện/V truy_vấn/Np lấy/V tổng/N một/M đoạn/Nc :/CH int/Np get/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH //CH Đoạn/Nc l/Ny ,/CH r/Np nằm/V ngoài/E đoạn/Nc u/N ,/CH v/Nu return/Np 0/M ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH //CH Đoạn/Nc l/Ny ,/CH r/Np nằm/V hoàn_toàn/A trong/E đoạn/Nc u/N ,/CH v/Nu return/Np st/Np id/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH return/Np get/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu )/CH +/CH get/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu );/CH 2/M ./CH\nLazy_Propagation_Đây/Np là/V kĩ_thuật/N được/V sử_dụng/V trong/E ST/Np để/E giảm/V độ/N phức_tạp/A của/E ST/Np với/E các/L truy_vấn/Np cập_nhật/V đoạn/Nc ./CH\nTư_tưởng/N Giả_sử_ta/Np cần/V cập_nhật/V đoạn/Nc u/N ,/CH v/Nu ./CH\nDễ/A thấy/V ta/P không_thể_nào/R cập_nhật/V tất_cả/P các/L nút/N trên/E Segment_Tree/Np (do/Np tổng_số/N nút/N nằm/V trong/E đoạn/Nc u/N ,/CH v/Nu có_thể/R lên/V đến/E O(N))/Np ./CH\nDo_đó/C ,/CH trong/E quá_trình/N cập_nhật/V ,/CH ta/P chỉ/R thay_đổi/V giá_trị/N ở/E các/L nút/N quản_lý/V các/L đoạn/Nc to/A nhất/A nằm/V trong/E u/N ,/CH v/Nu ./CH\nVí_dụ/C với/E N/Ny =/CH 7/M ,/CH cây/N Segment/Np tree/Np như/C hình/N minh_hoạ/V ở/E đầu_bài/Np ./CH\nGiả_sử/Np bạn/N cần/V cập_nhật/V 1/M ,/CH 6/M :/CH Bạn/N chỉ/R cập_nhật/V giá_trị/N ở/E các/L nút/N quản_lý/V các/L đoạn/Nc 1/M ,/CH 4/M và/Cc 5/M ,/CH 6/M ./CH\nGiá_trị/N của/E các/L nút/N quản_lý/V các/L đoạn/Nc 1/M ,/CH 2/M ,/CH 3/M ,/CH 4/M ,/CH 1/M ,/CH 1/M ,/CH 2/M ,/CH 2/M ,/CH 5/M ,/CH 5/M ,/CH ./CH ./CH ./CH\nsẽ/R không/R đúng/A ./CH\nTa/P sẽ/R chỉ/R cập_nhật/V lại/R giá_trị/N của/E các/L nút/N này/P khi/N thật_sự/A cần_thiết/A (Do/Np đó/P kĩ_thuật/N này/P được/V gọi_là/V lazy/Np -/CH lười/A biếng)/Np ./CH\nCụ_thể/A ,/CH chúng_ta/P cùng/A xem/V bài_toán/N sau/E :/CH Bài_Toán/N VOJ/Np -/CH QMAX2/Np Tóm_tắt_đề/Np Cho/E dãy_số/Np A/Ni với/E N/Ny phần_tử/N (N/Np \\le/Np 50/M ,/CH 000)/Np ./CH\nBạn/N cần/V thực_hiện/V 2/M loại/N truy_vấn/Np :/CH Cộng/V tất_cả/P các/L số/N trong/E đoạn/Nc l/Ny ,/CH r/Np lên_giá/Np trị/V val/Np ./CH\nIn/V ra/V giá_trị/N lớn/A nhất/A của/E các/L số/N trong/E đoạn/Nc l/Ny ,/CH r/Np ./CH\nPhân_tích/V Thao_tác/V 2/M là/V thao_tác/V cơ_bản/A trên/E Segment_Tree/Np ,/CH đã/R được/V ta/P phân_tích/V ở/E bài_toán/N đầu_tiên/A ./CH\nVới/E thao_tác/V 1/M ,/CH truy_vấn/Np đoạn/Nc u/N ,/CH v/Nu ./CH\nGiả_sử_ta/Np gọi/V F(id)/Np là/V giá_trị/N lớn/A nhất/A trong/E đoạn/Nc mà/C nút/N id/Np quản_lý/V ./CH\nTrong_lúc/Np cập_nhật/V ,/CH muốn/V hàm/Np này/P thực_hiện/V với/E độ/N phức_tạp/A không/R quá/R O(\\logN)/Np ,/CH thì/C khi/N đến/E 1/M nút/N id/Np quản_lý/V đoạn/Nc l/Ny ,/CH r/Np với/E đoạn/Nc l/Ny ,/CH r/Np nằm/V hoàn_toàn/A trong/E đoạn/Nc u/N ,/CH v/Nu ,/CH thì/C ta/P không/R được/V đi_vào/Np các/L nút/N con/Nc của/E nó/P nữa/R (nếu/Np không/R độ/N phức_tạp/A sẽ/R là/V O(N)/Np do/E ta/P đi_vào/Np tất_cả/P các/L nút/N nằm/V trong/E đoạn/Nc u/N ,/CH v)/Np ./CH\nĐể/E giải_quyết/V ,/CH ta/P dùng/V kĩ_thuật/N Lazy_Propagation/Np như_sau/Np :/CH Lưu_T(id)/Np với/E ý_nghĩa/N ,/CH tất_cả/P các/L phần_tử/N trong/E đoạn/Nc l/Ny ,/CH r/Np mà/C nút/N id/Np quản_lý/V đều/R được/V cộng/V thêm/V T(id)/Np ./CH\nTrước_khi/Np ta_cập/Np nhật/N hoặc/Cc lấy/V 1/M giá_trị/N của/E 1/M nút/N id/Np nào_đó/P ,/CH ta/P phải/V đảm_bảo/V ta/P đã/R \"đẩy\"/Np giá_trị/N của/E mảng/N T/Nu ở/E tất_cả/P các/L nút/N tổ_tiên/N của/E id/Np xuống/V id/Np ./CH\nĐể/E làm/V được/V điều/N này/P ,/CH ở/E các/L hàm_get/Np và/Cc update/Np ,/CH trước_khi/Np gọi/V đệ_quy/Np xuống/V các/L con/Nc 2/M id/Np và/Cc 2/M id+1/Np ,/CH ta/P phải/V gán/V :/CH Tid2/Np +=/Np Tid_Tid2+1/Np +=/Np Tid_Tid/Np =/CH 0/M chú_ý/V ta/P cần/V phải/V thực_hiện/V thao_tác/V này/P ,/CH nếu_không/Np mỗi/L phần_tử/N của/E dãy/Nc sẽ/R bị/V cộng/V nhiều/A lần/N ,/CH do/E ta/P đẩy/V xuống/V nhiều/A lần/N ./CH\nChú_ý/V :/CH Bài_QMAX2/Np này/P có/V cách/N cài_đặt/V khác/A không/R sử_dụng/V Lazy_Propagation/Np ,/CH tuy_nhiên/C sẽ/R không/R được/V trình_bày/V ở/E đây/P ./CH\nCài_đặt/V Ta/P có/V kiểu/N dữ_liệu/N cho/E 1/M nút/N của/E ST/Np như_sau/Np :/CH struct/Np Node/Np int/Np lazy/Np ;/CH //CH giá_trị/N T/Nu trong/E phân_tích/V trên/E int/Np val/Np ;/CH //CH giá_trị/N lớn/A nhất/A ./CH\nnodes/Np MAXN/Np 4/M ;/CH Hàm/Np \"đẩy\"/Np giá_trị/N T/Nu xuống/V các/L con/Nc :/CH void/Np down/Np (/CH int/Np id/Np )/CH int/Np t/Nu =/CH nodes/Np id/Np ./CH\nlazy/Np ;/CH nodes/Np id/Np 2/M ./CH\nlazy/Np +=/Np t/Nu ;/CH nodes/Np id/Np 2/M ./CH\nval/Np +=/Np t/Nu ;/CH nodes/Np id/Np 2/M +/CH 1/M ./CH\nlazy/Np +=/Np t/Nu ;/CH nodes/Np id/Np 2/M +/CH 1/M ./CH\nval/Np +=/Np t/Nu ;/CH nodes/Np id/Np ./CH\nlazy/Np =/CH 0/M ;/CH Hàm_cập_nhật/Np :/CH void/Np update/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu ,/CH int/Np val/Np )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH return/Np ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH //CH Khi/N cài_đặt/V ,/CH ta/P LUÔN/R ĐẢM_BẢO/V giá_trị/N của/E nút/N được/V cập_nhật/V ĐỒNG_THỜI/R với/E //CH giá_trị/N lazy/Np propagation/Np ./CH\nNhư_vậy/X sẽ/R tránh/V sai_sót/N ./CH\nnodes/Np id/Np ./CH\nval/Np +=/Np val/Np ;/CH nodes/Np id/Np ./CH\nlazy/Np +=/Np val/Np ;/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH down/Np (/CH id/Np );/CH //CH đẩy/V giá_trị/N lazy/Np propagation/Np xuống/V các/L con/Nc update/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu ,/CH val/Np );/CH update/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu ,/CH val/Np );/CH nodes/Np id/Np ./CH\nval/Np =/CH max/Np (/CH nodes/Np id/Np 2/M ./CH\nval/Np ,/CH nodes/Np id/Np 2/M +/CH 1/M ./CH\nval/Np );/CH Hàm/Np lấy/V giá_trị/N lớn/A nhất/A :/CH int/Np get/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu )/CH if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH return/Np -/CH INFINITY/Np ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH return/Np nodes/Np id/Np ./CH\nval/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH down/Np (/CH id/Np );/CH //CH đẩy/V giá_trị/N lazy/Np propagation/Np xuống/V các/L con/Nc return/Np max/Np (/CH get/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu )/CH ,/CH get/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu ));/Np //CH Trong/E các/L bài_toán/N tổng_quát/Np ,/CH giá_trị/N ở/E nút/N id/Np có_thể/R bị/V thay_đổi/V (do/Np ta/P đẩy/V lazy/Np propagation/Np //CH xuống/V các/L con)/Np ./CH\nKhi/N đó/P ,/CH ta/P cần/V cập_nhật/V lại/R thông_tin/N của/E nút/N id/Np dựa/V trên/E thông_tin/N của/E các/L con/Nc ./CH\nĐến/E đây/P các/L bạn/N đã/R nắm/V được/V kiến_thức/N cơ_bản/A về/E Segment_Tree/Np ./CH\nNhững/L phần/N tiếp_theo/V nói/V về/E các/L kiến_thức/N nâng_cao/Np -/CH các/L mở_rộng/V của/E ST/Np ./CH\nBạn/N nên/C làm/V nhiều/A bài/N luyện_tập/V (tham/Np khảo/Np ở/E cuối/N bài)/Np trước_khi/Np nghiên_cứu/V tiếp/V ./CH\n3/M ./CH\nỨng_dụng/V với/E cấu_trúc/N mảng/N động/N Trong/E loại/N bài_toán/N này/P với/E mỗi/L nút/N của/E cây_ta/Np lưu/V lại/R một/M vector/Np và/Cc một_số/L biến/V khác/A ./CH\nVí_dụ/C KQUERY2/Np ./CH\nTóm_tắt_đề/Np Cho/E dãy/Nc A/Ni với/E N/Ny phần_tử/N ./CH\nCần/V trả_lời/V Q/Ny truy_vấn/Np ./CH\nCó/V 2/M loại/N truy_vấn/Np :/CH Cập_nhật/V :/CH Gán/V A_i/Np =/CH v/Nu Truy_vấn/Np :/CH đếm_số/Np phần_tử/N lớn/A hơn/A k/N trong/E đoạn/Nc l/Ny ,/CH r/Np ./CH\nGiới_hạn/V :/CH N/Ny \\le/Np 30/M ,/CH 000/Np A_i/Np ,/CH v/Nu \\le/Np 10/M ,/CH 000/Np Q/Ny \\le/Np 200/M ,/CH 000/Np Bài/N này/P tương_đối/A giống/N với/E bài/N KQUERY/Np đã/R phân_tích/V ở/E trên/E ,/CH tuy_nhiên/C vì/E có/V thao_tác/V cập_nhật/V ,/CH nên/C ta/P buộc/V phải/V xử_lý/V online/Vb ./CH\nPhân_tích/V Có/V \\logN/Np nút/N mà/C ta/P cần/V xét/V khi/N trả_lời/V truy_vấn/Np của/E đoạn/Nc u/N ,/CH v/Nu ./CH\nNếu/C trên/E mỗi/L nút/N chúng_ta/P có_thể/R lưu/V lại/R danh_sách/N các/L phần_tử/N đó/P theo/V thứ_tự/N tăng/V dần/R ,/CH ta/P có_thể/R tìm_ra/Np kết_quả/N ở/E mỗi/L nút/N bằng/E tìm_kiếm/V nhị_phân/Np ./CH\nVì_thế/C với/E mỗi/L nút/N ta/P lưu/V lại/R một/M vector/Np chứa/V các/L phần_tử/N từ/E l/Ny đến/E r/Np theo/V thứ_tự/N tăng/V dần/R ./CH\nĐiều/N này/P có_thể/R được/V thực_hiện/V với/E bộ/N phức_tạp/A bộ_nhớ/Np là/V \\mathcalO(N\\logN)/Np do/E mỗi/L phần_tử/N có_thể/R ở/E tối_đa/A \\mathcalO(\\logN)/Np nút/N (độ/Np sâu/A của/E cây/N không/R quá/R \\mathcalO(\\logN))/Np ./CH\nỞ/E mỗi/L nút/N cha/N có/V ta/P có_thể/R gộp/V hai/M nút/N con/Nc vào/E nút/N cha/N bằng/E phương_pháp/N giống_như/Np Merge_Sort/Np (lưu/Np lại/R hai/M biến/V chạy/V và/Cc so_sánh/V lần_lượt/R từng/R phần_tử/N ở/E hai/M mảng)/Np để/E có_thể/R xây_dựng/V cây/N trong/E \\mathcalO(N\\logN)/Np ./CH\nHàm/Np xây/V cây/N có_thể/R được/V như_sau/Np :/CH void/Np build/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np )/CH if/Np (/CH l/Ny ==/Np r/Np )/CH //CH Đoạn/Nc gồm/V 1/M phần_tử/N ./CH\nTa/P dễ_dàng/A khởi/V tạo/V nút/N trên/E ST/Np ./CH\nst/Np id/Np ./CH\npush_back/Np (/CH a/Ni l/Ny );/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH build/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np );/CH build/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np );/CH merge/Np (/CH st/Np id/Np 2/M ./CH\nbegin/Np ()/Np ,/CH st/Np id/Np 2/M ./CH\nend/Np ()/Np ,/CH st/Np id/Np 2/M +/CH 1/M ./CH\nbegin/Np ()/Np ,/CH st/Np id/Np 2/M +/CH 1/M ./CH\nend/Np ()/Np ,/CH st/Np id/Np ./CH\nbegin/Np ());/Np Và/Cc hàm/Np truy_vấn/Np có_thể/R cài_đặt/V như_sau/Np :/CH int/Np get/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np u/N ,/CH int/Np v/Nu ,/CH int/Np k/N )/CH //CH Trả_lời/V truy_vấn/Np (x/Np ,/CH y/N ,/CH k)/Np if/Np (/CH v/Nu lt;/Np l/Ny r/Np lt;/Np u/N )/CH return/Np 0/M ;/CH if/Np (/CH u/N lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np v/Nu )/CH //CH Đếm_số/Np phần_tử/N gt;/Np K/N bằng/E chặt/A nhị_phân/Np return/Np st/Np id/Np ./CH\nsize/Nb ()/Np -/CH (/CH upper_bound/Np (/CH st/Np id/Np ./CH\nbegin/Np ()/Np ,/CH st/Np id/Np ./CH\nend/Np ()/Np ,/CH k/N )/CH -/CH st/Np id/Np ./CH\nbegin/Np ());/Np int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH return/Np get/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH u/N ,/CH v/Nu ,/CH k/N )/CH +/CH get/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH u/N ,/CH v/Nu ,/CH k/N );/CH Một/M ví_dụ/C khác/A là/V bài/N Component_Tree/Np 4/M ./CH\nỨng_dụng/V với/E cấu_trúc/N set/N Ở/E cấu_trúc/N này/P mỗi/L nút/N chúng_ta/P lưu/V một/M set/N ,/CH multiset/Np ,/CH hashmap/Np ,/CH hoặc/Cc unodered/Np map/Np và/Cc một_số/L biến/V khác/A ./CH\nĐây/P là/V một/M bài_toán/N ví_dụ/C :/CH Cho/E n/Ny vector/Np a_1/Np ,/CH a_2/Np ,/CH a_3/Np ,/CH ./CH ./CH ./CH ,/CH a_n/Np rỗng/A ban_đầu/N ./CH\nChúng_ta/P có_thể/R thực_hiện/V m/Nu truy_vấn/Np trên/E những/L vector/Np này/P :/CH Truy_vấn/Np A_p_k/Np là/V thêm/V số/N k/N vào/E cuối/N vector/Np a_p/Np ./CH\nTruy_vấn/Np C/Ni l/Ny r/Np k/N là/V xuất/V ra/V \\sum_i=lrcount(a_i/Np ,/CH k)/Np ,/CH với/E count(a_i/Np ,/CH k)/Np là/V số/N lần/N xuất_hiện/V của/E số/N k/N trong/E vector/Np a_i/Np ./CH\nBài_toán/N này/P chúng_ta/P lưu/V lại/R mỗi/L nút/N của/E cây/N là/V một/M multiset/Np s/Y ,/CH với/E mỗi/L nút/N lưu_số/Np k/N đúng/A \\sum_i=lrcount(a_i/Np ,/CH k)/Np lần/N với/E độ/N phức_tạp/A bộ_nhớ/Np chỉ/R \\mathcalO(q\\logn)/Np ./CH\nVới/E mỗi/L truy_vấn/Np C/Ni x/CH y/N k/N chúng_ta/P sẽ/R in/V ra/V tổng/N của/E tất_cả/P dùng/V cây/N phân_đoạn/Np và/Cc truy_vấn/Np trên/E set/N trong/E mỗi/L đoạn/Nc thuộc/V đoạn/Nc x/CH đến/E y_như/A truy/V trên/E truy_vấn/Np cây/N phân_đoạn/Np bình_thường/A ./CH\nChúng_ta/P sẽ/R không/R có/V hàm/Np xây/V cây/N do/E các/L vector/Np ban_đầu/N đang/R là/V rỗng/A ,/CH nhưng/C chúng_ta/P sẽ/R có/V thêm/V hàm_cộng/Np phần_tử/N vào/E như_sau/Np :/CH void/Np add/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np p/Ny ,/CH int/Np k/N )/CH //CH Thực_hiện/V truy_vấn/Np A_p_k/Np s/Y id/Np ./CH\ninsert/Np (/CH k/N );/CH if/Np (/CH l/Ny ==/Np r/Np )/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH if/Np (/CH p/Ny lt;=/Np mid/Np )/CH add/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH p/Ny ,/CH k/N );/CH else/Np add/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH p/Ny ,/CH k/N );/CH Và/Cc một/M hàm/Np cho/E truy_vấn/Np 2/M :/CH int/Np ask/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np x/CH ,/CH int/Np y/N ,/CH int/Np k/N )/CH //CH Trả_lời/V C/Ni x/CH y/N k/N if/Np (/CH y/N lt;/Np l/Ny r/Np lt;/Np x/CH )/CH return/Np 0/M ;/CH if/Np (/CH x/CH lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np y/N )/CH return/Np s/Y id/Np ./CH\ncount/Np (/CH k/N );/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH return/Np ask/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH x/CH ,/CH y/N ,/CH k/N )/CH +/CH ask/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH x/CH ,/CH y/N ,/CH k/N );/CH 5/M ./CH\nỨng_dụng/V với/E các/L cấu_trúc/N dữ_liệu/N khác/A Cây/N phân_đoạn/Np còn/R có_thể/R có_thể/R sử_dụng/V một_cách/N linh_hoạt/A với/E các/L cấu_trúc/N dữ_liệu/N khác/A như/C ở/E trên/E ./CH\nSử_dụng/V một/M cây/N phân_đoạn/Np khác/A trên/E từng/R nút/N có_thể/R giúp/V chúng_ta/P truy_vấn/Np dễ_dàng/A hơn/A trên/E mảng/N hai/M chiều/N ./CH\nTrên/E đây/P cũng/R có_thể/R là/V các/L loại/N cây/N như/C Cây/N tiền/N tố(Trie)/Np hoặc/Cc cũng/R có_thể/R là/V cấu_trúc/N Disjoint_Set/Np ./CH\nSau_đây/Np mình/P xin/V giới_thiệu/V một/M loại/N cây/N khác/A cũng/R sử_dụng/V nhiều/A trong/E cây/N phân_đoạn/Np đó/P chính/T là/V Cây_Fenwick/Np (Binary/Np Indexed_Tree)/Np :/CH Như_trên/Np mỗi/L nút/N của/E cây/N sẽ/R là/V một/M cây/N Fenwick/Np và/Cc có_thể/R một_số/L biến/V khác/A ./CH\nDưới_đây/Np là/V một/M bài_toán/N ví_dụ/C :/CH Cho/E n/Ny vectors/Np a_1/Np ,/CH a_2/Np ,/CH a_3/Np ,/CH ./CH ./CH ./CH ,/CH a_n/Np rỗng/A ban_đầu/N ./CH\nChúng_ta/P cần/V thực_hiện/V hai/M loại/N truy_vấn/Np :/CH Truy_vấn/Np A_p_k/Np là/V thêm/V số/N k/N vào/E đằng_sau/Np vector/Np a_p/Np ./CH\nTruy_vấn/Np C/Ni l/Ny r/Np k/N là/V xuất/V ra/V \\sum_i=lrcount(a_i/Np ,/CH j)/Np với/E j\\le/Np k/N với/E count(a_i/Np ,/CH j)/Np là/V số/N lần/N xuất_hiện/V k/N trong/E a_i/Np ./CH\nVới/E bài_toán/N này/P ,/CH ta/P cũng/R lưu/V lại/R ở/E một/M nút/N là/V một/M vector/Np v/Nu chứa/V số/N k/N khi/N và/Cc chỉ/R khi/N \\sum_i=lrcount(a_i/Np ,/CH j)\\ne/Np 0/M (độ/Np phức_tạp/A bộ_nhớ/Np sẽ/R là/V \\mathcalO(q\\logn)/Np )/CH (các/Np số/N theo/V theo/V thứ_tự/N tăng/V dần)/Np Đầu_tiên/A ,/CH đọc/V và/Cc lưu/V các/L truy_vấn/Np lại/R với/E mỗi/L truy_vấn/Np loại/N 1/M ta/P sẽ/R thêm/V v/Nu vào/E tất_cả/P vector/Np có/V chứa/V phần_tử/N p/Ny ./CH\nSau_đó/Np ta/P tiến_hành/V sắp_xếp/V các/L truy_vấn/Np theo/V phương_pháp/N Merge_Sort/Np đã/R nói/V ở/E trên/E và/Cc dùng/V hàm/Np unique/Np để/E loại/N các/L phần_tử/N trùng/V ./CH\nSau_đó/Np chúng_ta/P sẽ/R xây_dụng/Np ở/E mỗi/L nút/N một/M cây/N Fenwick/Np có/V độ/N lớn/A bằng/E độ_dài/Np vector/Np ./CH\nSau_đây/Np là/V hàm/Np thêm/V giá_trị/N :/CH void/Np insert/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np p/Ny ,/CH int/Np k/N )/CH //CH Thực_hiện/V A_p_k/Np if/Np (/CH l/Ny ==/Np r/Np )/CH v/Nu id/Np ./CH\npush_back/Np (/CH k/N );/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH if/Np (/CH p/Ny lt;/Np mid/Np )/CH insert/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH p/Ny ,/CH k/N );/CH else/Np insert/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH p/Ny ,/CH k/N );/CH Hàm/Np sắp_xếp/V sau/E khi/N đã/R đọc/V hết/V các/L truy_vấn/Np :/CH void/Np sort_/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np )/CH if/Np (/CH l/Ny ==/Np r/Np )/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH sort_/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np );/CH sort_/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np );/CH merge/Np (/CH v/Nu 2/M id/Np ./CH\nbegin/Np ()/Np ,/CH v/Nu 2/M id/Np ./CH\nend/Np ()/Np ,/CH v/Nu 2/M id/Np +/CH 1/M ./CH\nbegin/Np ()/Np ,/CH v/Nu 2/M id/Np +/CH 1/M ./CH\nend/Np ()/Np ,/CH v/Nu id/Np ./CH\nbegin/Np ());/Np Với/E mỗi/L truy_vấn/Np loại/N 1/M ta/P làm/V như_sau/Np với/E mỗi/L nút/N x/CH :/CH for/Np (/CH int/Np i/M =/CH a/Ni +/CH 1/M ;/CH i/M lt;/Np fen/Np x/CH ./CH\nsize/Nb ();/Np i/M +=/Np i/M amp;/Np -/CH i/M )/CH fen/Np x/CH i/M ++/Np ;/CH Với/E tất_cả/P vxa=k/Np :/CH void/Np update/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np p/Ny ,/CH int/Np k/N )/CH int/Np a/Ni =/CH lower_bound/Np (/CH v/Nu id/Np ./CH\nbegin/Np ()/Np ,/CH v/Nu id/Np ./CH\nend/Np ()/Np ,/CH k/N )/CH -/CH v/Nu id/Np ./CH\nbegin/Np ();/Np for/Np (/CH int/Np i/M =/CH a/Ni +/CH 1/M ;/CH i/M lt;/Np fen/Np id/Np ./CH\nsize/Nb ();/Np i/M +=/Np i/M amp;/Np -/CH i/M )/CH fen/Np id/Np i/M ++/Np ;/CH if/Np (/CH l/Ny ==/Np r/Np )/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH if/Np (/CH p/Ny lt;/Np mid/Np )/CH update/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH p/Ny ,/CH k/N );/CH else/Np update/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH p/Ny ,/CH k/N );/CH Còn_lại/Np việc/N tính_toán/V truy_vấn/Np loại/N 2/M trở_nên/V dễ_dàng/A hơn/A :/CH int/Np ask/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np x/CH ,/CH int/Np y/N ,/CH int/Np k/N )/CH //CH Trả_lời/V C/Ni x/CH y-1/Np k/N if/Np (/CH y/N lt;/Np l/Ny r/Np lt;/Np x/CH )/CH return/Np 0/M ;/CH if/Np (/CH x/CH lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np y/N )/CH int/Np a/Ni =/CH lower_bound/Np (/CH v/Nu id/Np ./CH\nbegin/Np ()/Np ,/CH v/Nu id/Np ./CH\nend/Np ()/Np ,/CH k/N )/CH -/CH v/Nu id/Np ./CH\nbegin/Np ();/Np int/Np ans/Np =/CH 0/M ;/CH for/Np (/CH int/Np i/M =/CH a/Ni +/CH 1/M ;/CH i/M gt;/Np 0/M ;/CH i/M -=/Np i/M amp;/Np -/CH i/M )/CH ans/Np +=/Np fen/Np id/Np i/M ;/CH return/Np ans/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH return/Np ask/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH x/CH ,/CH y/N ,/CH k/N )/CH +/CH ask/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH x/CH ,/CH y/N ,/CH k/N );/CH 6/M ./CH\nỨng_dụng/V trong/E cây/N có/V gốc/N Ta/P có_thể/R thấy/V cây/N phân_đoạn/Np là/V một/M ứng_dụng/V trong/E mảng/N ,/CH vì/E lí_do/N đó/P nếu/C chúng_ta/P có_thể/R đổi/V cây/N thành/V các/L mảng/N ,/CH ta/P có_thể/R dễ_dàng/A xử_lý/V các/L truy_vấn/Np trên/E cây/N ./CH\nĐây/P là/V tư_tưởng/N của/E Heavy_Light_Decomposition/Np ./CH\nBài_tập/Np ví_dụ/C :/CH 396C/Np -/CH On_Changing_Tree_Gọi/Np h_v/Np là/V độ_cao/Np tương_ứng/V của/E nút/N v/Nu ./CH\nTa/P có/V với/E mỗi/L nút/N u/N trong/E cây_con/Np gốc/N v/Nu sau/E truy_vấn/Np một/M giá_trị/N của/E nó/P sẽ/R tăng/V một/M lượng/N là/V x+(h_u-h_v)-k=x+k/Np h_v-k/Np h/Ny ./CH\nKết_quả/N của/E truy_vấn/Np 2/M sẽ/R là/V \\sum_i\\in/Np s(k_ih_v_i+x_i)-h_u\\sum_i\\in/Np sk_i/Np ./CH\nVì_vậy/C ta/P chỉ_cần/Np tính/V hai/M giá_trị/N là/V \\sum_i\\in/Np s(k_i/Np h_v_i+x_i)/Np và/Cc \\sum_i\\in/Np sk_i/Np ./CH\nVậy/P với/E mỗi/L nút/N ta/P có_thể/R lưu/V lại/R hai/M giá_trị/N là/V hkx=\\sum/Np x/CH +hk/Np và/Cc sk=\\sum/Np k/N (không/Np cần/V lazy/Np propagation/Np do/E chúng_ta/P chỉ/R update/Np nút/N đầu_tiên/A thỏa_việc/Np nằm/V trong/E đoạn/Nc ./CH\nVới/E truy_vấn/Np cập_nhật/V :/CH void/Np update/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np x/CH ,/CH int/Np k/N ,/CH int/Np v/Nu )/CH if/Np (/CH s/Y v/Nu gt;=/Np r/Np l/Ny gt;=/Np f/Np v/Nu )/CH return/Np ;/CH if/Np (/CH s/Y v/Nu lt;=/Np l/Ny amp;amp;/Np r/Np lt;=/Np f/Np v/Nu )/CH hkx/Np id/Np =/CH (/CH hkx/Np id/Np +/CH x/CH )/CH %/CH mod/Np ;/CH int/Np a/Ni =/CH (/CH 1LL/Np h/Ny v/Nu k/N )/CH %/CH mod/Np ;/CH hkx/Np id/Np =/CH (/CH hkx/Np id/Np +/CH a/Ni )/CH %/CH mod/Np ;/CH sk/Np id/Np =/CH (/CH sk/Np id/Np +/CH k/N )/CH %/CH mod/Np ;/CH return/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH update/Np (/CH id/Np 2/M ,/CH l/Ny ,/CH mid/Np ,/CH x/CH ,/CH k/N ,/CH v/Nu );/CH update/Np (/CH id/Np 2/M +/CH 1/M ,/CH mid/Np +/CH 1/M ,/CH r/Np ,/CH x/CH ,/CH k/N ,/CH v/Nu );/CH Và/Cc truy_vấn/Np :/CH int/Np ask/Np (/CH int/Np id/Np ,/CH int/Np l/Ny ,/CH int/Np r/Np ,/CH int/Np v/Nu )/CH int/Np a/Ni =/CH (/CH 1LL/Np h/Ny v/Nu sk/Np id/Np )/CH %/CH mod/Np ;/CH int/Np ans/Np =/CH (/CH hkx/Np id/Np +/CH mod/Np -/CH a/Ni )/CH %/CH mod/Np ;/CH if/Np (/CH l/Ny ==/Np r/Np )/CH return/Np ans/Np ;/CH int/Np mid/Np =/CH (/CH l/Ny +/CH r/Np )/CH //CH 2/M ;/CH if/Np (/CH s/Y v/Nu lt;/Np mid/Np )/CH return/Np (/CH ans/Np +/CH ask/Np (/CH 2/M id/Np ,/CH l/Ny ,/CH mid/Np ,/CH v/Nu ))/Np %/CH mod/Np ;/CH return/Np (/CH ans/Np +/CH ask/Np (/CH 2/M id/Np +/CH 1/M ,/CH mid/Np ,/CH r/Np ,/CH v/Nu ))/Np %/CH mod/Np ;/CH 7/M ./CH\nPersistent_Segment_Trees_Persistent_Data_Structures/Np là/V những/L cấu_trúc/N dữ_liệu/N được/V dùng/V khi/N chúng_ta/P cần/V có/V toàn_bộ/L lịch_sử/N của/E các/L thay_đổi/V trên/E 1/M cấu_trúc/N dữ_liệu/N (CTDL)/Np ./CH\nCác/L bạn/N có_thể/R đọc/V thêm/V ở/E :/CH Persistent_Data_Structures/Np 8/M ./CH\nIT/Np đoạn_thẳng/Np Bài_toán/N Cho/E một_tập/Np hợp/V chứa/V các/L đường_thẳng/N có/V dạng/N ax/Ny +/CH b/Ni ,/CH mỗi/L đường_thẳng/N được/V biểu_diễn/V bằng/E một/M cặp/N số/N (a/Np ,/CH b)/Np ./CH\nCần/V thực_hiện/V hai/M truy_vấn/Np :/CH Thêm/V một/M đường_thẳng/N vào/E tập_hợp/N ./CH\nTrả_lời/V xem/V tại/E hoành_độ/Np q/Ny ,/CH điểm/N nào/P thuộc/V ít_nhất/A một/M đường_thẳng/N trong/E tập/V có/V tung_độ/Np lớn/A nhất/A ./CH\nNói_cách_khác/Np ,/CH đường_thẳng/N (a/Np ,/CH b)/Np nào/P có/V aq/Np +/CH b/Ni lớn/A nhất/A ./CH\nĐể/E giải/N bài_toán/N này/P ,/CH hai/M cách/N phổ_biến/V là/V ứng_dụng/V bao/N lồi/Np và/Cc sử_dụng/V cây/N Interval_Tree/Np lưu/V đoạn_thẳng/Np Bài_tập/Np áp_dụng/V :/CH VOJ/Np -/CH QMAX_VOJ/Np -/CH NKLINEUP_VOJ/Np -/CH GSS_VOJ/Np -/CH LITES_VOJ/Np -/CH DQUERY_VOJ/Np -/CH KQUERY_FREQUENT_VOJ/Np -/CH KQUERY2_GSS2_GSS3_MULTQ3_POSTERS_PATULJCI_New_Year_Domino_Copying_Data_DZY_Loves_Fibonacci_Numbers_FRBSUM_Đọc/Np thêm/V :/CH Cấu_trúc/N dữ_liệu/N đặc_biệt/A -/CH Đoàn/Nc Mạnh_Hùng/Np Cấu_trúc/N dữ_liệu/N đặc_biệt/A -/CH Nguyễn_Minh/Np Hiếu_Các/Np nguồn/N tham_khảo/V :/CH Codeforces/Np Một_số/L vấn_đề/N đáng/V chú_ý/V trong/E môn/N Tin_học/N\n", "title": "Tất tần tật về Cây Phân Đoạn (Segment Tree)\n", "link": "http://vnoi.info/wiki/algo/data-structures/segment-tree-extend\n"}