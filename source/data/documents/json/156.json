{"content": "Tư_tưởng Bảng_băm là một CTDL thường được sử_dụng như một từ_điển : mỗi phần_tử trong bảng_băm là một cặp (khóa , giá trị) .\nNếu so_sánh với mảng , khóa được xem như chỉ_số của mảng , còn giá_trị giống_như giá_trị mà ta lưu tại chỉ_số tương_ứng .\nBảng_băm không như các loại_từ điển thông_thường - ta có_thể tìm được_giá trị thông_qua khóa của nó .\nKhông may , không_phải tất_cả các kiểu dữ_liệu đều có_thể sắp_xếp vào một từ_điển đơn_giản .\nĐây chính là lúc mà quá_trình băm (hash) ra_đời .\nHash là quá_trình khởi tạo một giá_trị khóa (thường là 32 bit hoặc 64 bit) từ một phần dữ_liệu .\nNó có_thể là n bit đầu_tiên của dữ_liệu , n bit cuối_cùng , giá_trị mod cho một_số nguyên_tố nào_đó .\nDựa theo giá_trị hash , dữ_liệu được chia vào các bucket : Giải_thích hình minh_họa : Ta cần lưu_số điện_thoại của 3 người : John_Smith : 521-1234 Lisa_Smith : 521-8976 Sandra_Dee : 521-9655 Giá_trị Hash của 3 người này lần_lượt là : 1 , 2 và 14 .\nSau khi tính được_giá trị Hash của 3 người , ta lưu vào các bucket tương_ứng là 1 , 2 và 14 .\nNếu các kết_quả của hàm hash được phân_bố đều , các bucket sẽ có kích_thước xấp_xỉ nhau .\nGiả_sử số bucket đủ lớn , mỗi buckets sẽ chỉ_có một_vài phần_tử trong chúng .\nĐiều này làm_cho việc tìm_kiếm rất hiệu_quả .\nĐộ phức_tạp Gọi : n là số phần_tử ta cần lưu trong Hash table k là số bucket Giá_trị n/k được gọi_là load factor .\nKhi load factor nhỏ (xấp xỉ 1) , và giá_trị của hàm Hash phân_bố đều , độ phức_tạp của các thao_tác trên Hash table là \\mathcalO(1) .\nHash collision Separate chaining Trường_hợp một hash bucket chứa nhiều hơn một giá_trị ta gọi đó là Hash collision (va chạm) .\nViệc xử_lý hash collision rất quan_trọng đối_với độ hiệu_quả của bảng_băm .\nMột trong những phương_pháp đơn_giản nhất_là cài_đặt các danh_sách liên_kết ở các bucket .\nKĩ_thuật này được gọi_là Separate chaining : Giải_thích hình minh_họa : Mỗi bucket là 1 danh_sách liên_kết John_Smith và Sandra_Dee cùng có_giá trị hàm hash là 152 , nên ở bucket 152 , ta có 1 danh_sách liên_kết chứa 2 phần_tử .\nOpen_Addressing Tư_tưởng của Open_Addressing là , khi xảy_ra Hash collision , ta lưu vào một vị_trí tiếp_theo trong bảng_băm .\nVí_dụ : Trong hình minh_họa : John_Smith và Sandra_Dee đều có_giá trị Hash là 152 .\nVì ta đã lưu John_Smith vào bucket 152 , nên ta buộc phải lưu Sandra_Dee vào bucket 153 .\nTed_Baker có_giá trị Hash là 153 , nhưng lúc_này bucket 153 đã lưu_thông_tin của Sandra_Dee , nên ta phải lưu giá_trị của Ted_Baker vào bucket 154 .\nChú_ý : Để cài_đặt được cách này , Load factor phải nhỏ hơn 1 .\nKhi tìm_kiếm 1 phần_tử , ta phải kiểm_tra tất_cả các bucket bắt_đầu_từ bucket của giá_trị Hash , đến khi bucket trống (ví dụ ta tìm Sandra_Dee thì_phải tìm bucket 152 , 153; tìm Ted_Baker thì_phải tìm bucket 152 , 153 , 154 .\nNếu ta tìm 1 người khác có_giá trị Hash là 152 , thì_phải tìm cả bucket 152 , 153 , 154 và 155 (chỉ khi bucket 155 trống , ta mới chắc_chắn người đó không có trong Hash table) .\nCài_đặt Dưới_đây là cài_đặt Hash table đơn_giản , hỗ_trợ thao_tác thêm và tìm_kiếm .\nHash table này sử_dụng separate chaining , và dùng vector thay cho linked list để đơn_giản .\nconst int P = 1e6 + 3 ; struct HashTable vector lt; pair lt; int , int gt; gt; h P ; public : void insert ( int key , int value ) int hkey = getHash ( key ); for ( auto p : h hkey ) if ( p .\nfirst == key ) // key da_ton tai trong Hash table , ta bo_qua return ; // Them (key , value) vao hash table h hkey .\nemplace_back ( key , value ); int find ( int key ) int hkey = getHash ( key ); for ( auto p : h hkey ) if ( p .\nfirst == key ) // ton tai key trong Hash table , return value return p .\nvalue ; // Khong tim thay return 0 ; private : int getHash ( int key ) // Cho 1 key , tra lai Hash value la key % P return key % P ; ; Kết_luận Trong phát_triển ứng_dụng , bảng hash thuận_tiện để lưu_trữ dữ_liệu tham_khảo , chẳng_hạn như chữ_viết tắt tên đầy_đủ của các tổ_chức .\nTrong giải_quyết bài_toán , bảng hash thật_sự hữu_ích để tiếp_cận hướng giải_quyết chia_để_trị cho bài_toán cái túi (knapsack-type) .\nGiả_sử , chúng_ta được yêu_cầu tìm một_số lượng ống nhỏ nhất để xây_dựng một đường_ống với chiều_dài cố_định và chúng_ta có 38 ống .\nBằng cách chia thành hai tập – 19 và tính_toán tất_cả trường_hợp ghép ống có_thể ở mỗi tập , chúng_ta tạo ra một bảng hash kết_nối giữa độ_dài mà các tổ_hợp ống tạo_thành với số_lượng ống ít_nhất cần_dùng .\nSau_đó , với mỗi tổ_hợp ống được xây_dựng trong một_tập , chúng_ta có_thể tra_cứu liệu có tồn_tại đường_ống với độ_dài phù_hợp ở tập bên_kia để cả hai ống tạo nên một đường_ống với độ_dài yêu_cầu với số ống là ít_nhất .\nCác tài_liệu tham_khảo : Topcoder_Wikipedia\n", "tagged": "Tư_tưởng/N Bảng_băm/Np là/V một/M CTDL/Np thường/R được/V sử_dụng/V như/C một/M từ_điển/Np :/CH mỗi/L phần_tử/N trong/E bảng_băm/Np là/V một/M cặp/N (khóa/Np ,/CH giá/N trị)/Np ./CH\nNếu/C so_sánh/V với/E mảng/N ,/CH khóa/N được/V xem/V như/C chỉ_số/N của/E mảng/N ,/CH còn/R giá_trị/N giống_như/Np giá_trị/N mà/C ta/P lưu/V tại/E chỉ_số/N tương_ứng/V ./CH\nBảng_băm/Np không/R như/C các/L loại_từ/Np điển/Np thông_thường/A -/CH ta/P có_thể/R tìm/V được_giá/Np trị/V thông_qua/V khóa/N của/E nó/P ./CH\nKhông/R may/A ,/CH không_phải/Np tất_cả/P các/L kiểu/N dữ_liệu/N đều/R có_thể/R sắp_xếp/V vào/E một/M từ_điển/Np đơn_giản/A ./CH\nĐây/P chính/T là/V lúc/N mà/C quá_trình/N băm/Np (hash)/Np ra_đời/V ./CH\nHash/Np là/V quá_trình/N khởi/V tạo/V một/M giá_trị/N khóa/N (thường/Np là/V 32/M bit/Np hoặc/Cc 64/M bit)/Np từ/E một/M phần/N dữ_liệu/N ./CH\nNó/P có_thể/R là/V n/Ny bit/Np đầu_tiên/A của/E dữ_liệu/N ,/CH n/Ny bit/Np cuối_cùng/A ,/CH giá_trị/N mod/Np cho/E một_số/L nguyên_tố/N nào_đó/P ./CH\nDựa/V theo/V giá_trị/N hash/Np ,/CH dữ_liệu/N được/V chia/V vào/E các/L bucket/Np :/CH Giải_thích/V hình/N minh_họa/V :/CH Ta/P cần/V lưu_số/Np điện_thoại/N của/E 3/M người/N :/CH John_Smith/Np :/CH 521-1234/Np Lisa_Smith/Np :/CH 521-8976/Np Sandra_Dee/Np :/CH 521-9655/Np Giá_trị/N Hash/Np của/E 3/M người/N này/P lần_lượt/R là/V :/CH 1/M ,/CH 2/M và/Cc 14/M ./CH\nSau/E khi/N tính/V được_giá/Np trị/V Hash/Np của/E 3/M người/N ,/CH ta/P lưu/V vào/E các/L bucket/Np tương_ứng/V là/V 1/M ,/CH 2/M và/Cc 14/M ./CH\nNếu/C các/L kết_quả/N của/E hàm/Np hash/Np được/V phân_bố/V đều/R ,/CH các/L bucket/Np sẽ/R có/V kích_thước/N xấp_xỉ/A nhau/N ./CH\nGiả_sử/Np số/N bucket/Np đủ/A lớn/A ,/CH mỗi/L buckets/Np sẽ/R chỉ_có/Np một_vài/L phần_tử/N trong/E chúng/P ./CH\nĐiều/N này/P làm_cho/Np việc/N tìm_kiếm/V rất/R hiệu_quả/N ./CH\nĐộ/N phức_tạp/A Gọi/V :/CH n/Ny là/V số/N phần_tử/N ta/P cần/V lưu/V trong/E Hash/Np table/Np k/N là/V số/N bucket/Np Giá_trị/N n/Ny được/V gọi_là/V load/Np factor/Np ./CH\nKhi/N load/Np factor/Np nhỏ/A (xấp/Np xỉ/Np 1)/Np ,/CH và/Cc giá_trị/N của/E hàm/Np Hash/Np phân_bố/V đều/R ,/CH độ/N phức_tạp/A của/E các/L thao_tác/V trên/E Hash/Np table/Np là/V \\mathcalO(1)/Np ./CH\nHash/Np collision/Np Separate/Np chaining/Np Trường_hợp/N một/M hash/Np bucket/Np chứa/V nhiều/A hơn/A một/M giá_trị/N ta/P gọi/V đó/P là/V Hash/Np collision/Np (va/Np chạm)/Np ./CH\nViệc/N xử_lý/V hash/Np collision/Np rất/R quan_trọng/A đối_với/E độ/N hiệu_quả/N của/E bảng_băm/Np ./CH\nMột/M trong/E những/L phương_pháp/N đơn_giản/A nhất_là/X cài_đặt/V các/L danh_sách/N liên_kết/V ở/E các/L bucket/Np ./CH\nKĩ_thuật/N này/P được/V gọi_là/V Separate/Np chaining/Np :/CH Giải_thích/V hình/N minh_họa/V :/CH Mỗi/L bucket/Np là/V 1/M danh_sách/N liên_kết/V John_Smith/Np và/Cc Sandra_Dee/Np cùng/A có_giá/Np trị/V hàm/Np hash/Np là/V 152/Np ,/CH nên/C ở/E bucket/Np 152/Np ,/CH ta/P có/V 1/M danh_sách/N liên_kết/V chứa/V 2/M phần_tử/N ./CH\nOpen_Addressing/Np Tư_tưởng/N của/E Open_Addressing/Np là/V ,/CH khi/N xảy_ra/Np Hash/Np collision/Np ,/CH ta/P lưu/V vào/E một/M vị_trí/N tiếp_theo/V trong/E bảng_băm/Np ./CH\nVí_dụ/C :/CH Trong/E hình/N minh_họa/V :/CH John_Smith/Np và/Cc Sandra_Dee/Np đều/R có_giá/Np trị/V Hash/Np là/V 152/Np ./CH\nVì/E ta/P đã/R lưu/V John_Smith/Np vào/E bucket/Np 152/Np ,/CH nên/C ta/P buộc/V phải/V lưu/V Sandra_Dee/Np vào/E bucket/Np 153/Np ./CH\nTed_Baker/Np có_giá/Np trị/V Hash/Np là/V 153/Np ,/CH nhưng/C lúc_này/Np bucket/Np 153/Np đã/R lưu_thông_tin/Np của/E Sandra_Dee/Np ,/CH nên/C ta/P phải/V lưu/V giá_trị/N của/E Ted_Baker/Np vào/E bucket/Np 154/M ./CH\nChú_ý/V :/CH Để/E cài_đặt/V được/V cách/N này/P ,/CH Load/Np factor/Np phải/V nhỏ/A hơn/A 1/M ./CH\nKhi/N tìm_kiếm/V 1/M phần_tử/N ,/CH ta/P phải/V kiểm_tra/V tất_cả/P các/L bucket/Np bắt_đầu_từ/Np bucket/Np của/E giá_trị/N Hash/Np ,/CH đến/E khi/N bucket/Np trống/A (ví/Np dụ/V ta/P tìm/V Sandra_Dee/Np thì_phải/N tìm/V bucket/Np 152/Np ,/CH 153;/Np tìm/V Ted_Baker/Np thì_phải/N tìm/V bucket/Np 152/Np ,/CH 153/Np ,/CH 154/M ./CH\nNếu/C ta/P tìm/V 1/M người/N khác/A có_giá/Np trị/V Hash/Np là/V 152/Np ,/CH thì_phải/N tìm/V cả/P bucket/Np 152/Np ,/CH 153/Np ,/CH 154/M và/Cc 155/Np (chỉ/Np khi/N bucket/Np 155/Np trống/A ,/CH ta/P mới/R chắc_chắn/A người/N đó/P không/R có/V trong/E Hash/Np table)/Np ./CH\nCài_đặt/V Dưới_đây/Np là/V cài_đặt/V Hash/Np table/Np đơn_giản/A ,/CH hỗ_trợ/V thao_tác/V thêm/V và/Cc tìm_kiếm/V ./CH\nHash/Np table/Np này/P sử_dụng/V separate/Np chaining/Np ,/CH và/Cc dùng/V vector/Np thay/V cho/E linked/Np list/Np để/E đơn_giản/A ./CH\nconst/Np int/Np P/Ny =/CH 1e6/Np +/CH 3/M ;/CH struct/Np HashTable/Np vector/Np lt;/Np pair/Np lt;/Np int/Np ,/CH int/Np gt;/Np gt;/Np h/Ny P/Ny ;/CH public/Np :/CH void/Np insert/Np (/CH int/Np key/Np ,/CH int/Np value/Np )/CH int/Np hkey/Np =/CH getHash/Np (/CH key/Np );/CH for/Np (/CH auto/Np p/Ny :/CH h/Ny hkey/Np )/CH if/Np (/CH p/Ny ./CH\nfirst/Np ==/Np key/Np )/CH //CH key/Np da_ton/Np tai/N trong/E Hash/Np table/Np ,/CH ta/P bo_qua/Np return/Np ;/CH //CH Them/Np (key/Np ,/CH value)/Np vao/Np hash/Np table/Np h/Ny hkey/Np ./CH\nemplace_back/Np (/CH key/Np ,/CH value/Np );/CH int/Np find/Np (/CH int/Np key/Np )/CH int/Np hkey/Np =/CH getHash/Np (/CH key/Np );/CH for/Np (/CH auto/Np p/Ny :/CH h/Ny hkey/Np )/CH if/Np (/CH p/Ny ./CH\nfirst/Np ==/Np key/Np )/CH //CH ton/Np tai/N key/Np trong/E Hash/Np table/Np ,/CH return/Np value/Np return/Np p/Ny ./CH\nvalue/Np ;/CH //CH Khong/Np tim/N thay/V return/Np 0/M ;/CH private/Np :/CH int/Np getHash/Np (/CH int/Np key/Np )/CH //CH Cho/E 1/M key/Np ,/CH tra/V lai/A Hash/Np value/Np la/V key/Np %/CH P/Ny return/Np key/Np %/CH P/Ny ;/CH ;/CH Kết_luận/V Trong/E phát_triển/V ứng_dụng/V ,/CH bảng/N hash/Np thuận_tiện/N để/E lưu_trữ/Np dữ_liệu/N tham_khảo/V ,/CH chẳng_hạn/X như/C chữ_viết/Np tắt/V tên/N đầy_đủ/A của/E các/L tổ_chức/V ./CH\nTrong/E giải_quyết/V bài_toán/N ,/CH bảng/N hash/Np thật_sự/A hữu_ích/A để/E tiếp_cận/V hướng/N giải_quyết/V chia_để_trị/Np cho/E bài_toán/N cái/Nc túi/N (knapsack-type)/Np ./CH\nGiả_sử/Np ,/CH chúng_ta/P được/V yêu_cầu/V tìm/V một_số/L lượng/N ống/N nhỏ/A nhất/A để/E xây_dựng/V một/M đường_ống/N với/E chiều_dài/N cố_định/A và/Cc chúng_ta/P có/V 38/M ống/N ./CH\nBằng/E cách/N chia/V thành/V hai/M tập/V –/CH 19/M và/Cc tính_toán/V tất_cả/P trường_hợp/N ghép/V ống/N có_thể/R ở/E mỗi/L tập/V ,/CH chúng_ta/P tạo/V ra/V một/M bảng/N hash/Np kết_nối/Np giữa/N độ_dài/Np mà/C các/L tổ_hợp/N ống/N tạo_thành/Np với/E số_lượng/N ống/N ít_nhất/A cần_dùng/Np ./CH\nSau_đó/Np ,/CH với/E mỗi/L tổ_hợp/N ống/N được/V xây_dựng/V trong/E một_tập/Np ,/CH chúng_ta/P có_thể/R tra_cứu/Np liệu/V có/V tồn_tại/V đường_ống/N với/E độ_dài/Np phù_hợp/V ở/E tập/V bên_kia/Np để/E cả/P hai/M ống/N tạo/V nên/C một/M đường_ống/N với/E độ_dài/Np yêu_cầu/V với/E số/N ống/N là/V ít_nhất/A ./CH\nCác/L tài_liệu/N tham_khảo/V :/CH Topcoder_Wikipedia/Np\n", "title": "Bảng băm (Hash Table)\n", "link": "http://vnoi.info/wiki/algo/data-structures/hash-table\n"}