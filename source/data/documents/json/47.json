{"content": "Nguồn : Topcoder_Table of_Contents Các định_nghĩa Bài_toán Range_Minimum_Query (RMQ) Bài_toán Lowest_Common_Ancestor (LCA) Bài_toán RMQ Thuật_toán lt; O(1) , O(N) gt; Thuật_toán lt; O(N2) , O(1) gt; Thuật_toán lt; O(N) , O(\\sqrt_N) gt; Sparse_Table (ST) Cây phân_đoạn (segment tree , interval tree , range tree) Bài_toán LCA Thuật_toán lt; O(N) , O(N) gt; Thuật_toán lt; O(N) , O(\\sqrt_N) gt; Thuật_toán lt; O(NlogN) , O(logN) gt; Từ_LCA đến RMQ_Từ_RMQ đến LCA Thuật_toán lt; O(N) , O(1) gt; cho bài_toán RMQ thu_hẹp Một_số bài để luyện_tập Trong bài viết này , tác_giả sẽ giới_thiệu với bạn 2 bài_toán cơ_bản : Bài_toán RMQ và bài_toán LCA , cũng_như mối liên_hệ giữa 2 bài_toán này .\nCác định_nghĩa Gỉa sử thuật_toán có thời_gian tiền xử_lý là f(n) và thời_gian trả_lời 1 truy_vấn là g(n) .\nTa ký_hiệu độ phức_tạp tổng_quát của thuật_toán là lt; f(n) , g(n) gt; .\nTrong bài này , khi viết \\logN , chúng_ta hiểu là log cơ_số 2 của N .\nBài_toán Range_Minimum_Query (RMQ) Cho mảng A0 , N-1 .\nBạn cần trả_lời Q truy_vấn .\nMỗi truy_vấn gồm 2 số i , j và bạn cần đưa_ra vị_trí của phần_tử có_giá trị nhỏ nhất trong đoạn từ i đến j của mảng A , ký_hiệu là RMQ_A(i , j) .\nBài_toán Lowest_Common_Ancestor (LCA) Cho cây có gốc T .\nBạn cần trả_lời Q truy_vấn .\nMỗi truy_vấn gồm 2 số u , v và bạn cần tìm nút xa gốc nhất mà là tổ_tiên của cả 2 nút u và v , ký_hiệu là LCA_T(u , v) .\nBài_toán RMQ Thuật_toán lt; O(1) , O(N) gt; Thuật_toán hiển_nhiên nhất cho bài RMQ là ta không cần tiền xử_lý gì cả .\nVới mỗi truy_vấn , ta xét lần_lượt từng phần_tử từ i đến j để tìm phần_tử nhỏ nhất .\nHiển_nhiên , độ phức_tạp thuật_toán này là lt; O(1) , O(N) gt; .\nThuật_toán lt; O(N2) , O(1) gt; Lưu giá_trị của RMQ_A(i , j) trong một bảng M0 , N-10 , N-1 .\nThuật_toán sẽ có độ phức_tạp lt; O(N3) , O(1) gt; .\nTuy_nhiên ta có_thể sử_dụng quy_hoạch_động để giảm độ phức_tạp xuống lt; O(N2) , O(1) gt; như_sau : for i = 0 . .\nN-1_Mii = i; for i = 0 . .\nN-1 for j = i+1 . .\nN-1 if (AMij - 1 lt; Aj)_Mij = Mij - 1; else Mij = j; Có_thể thấy thuật_toán này khá chậm và tốn bộ_nhớ O(N2) nên sẽ không hữu_ích với những dữ_liệu lớn hơn .\nThuật_toán lt; O(N) , O(\\sqrt_N) gt; Ta có_thể chia mảng thành \\sqrt N phần .\nTa sử_dụng một mảng M0 , \\sqrt N để lưu giá_trị mỗi phần .\nM có_thể dễ_dàng tính được trong O(N) : Để tính RMQ_A(i , j) , chúng_ta xét giá_trị M của \\sqrt N phần nằm trong đoạn i , j , và những phần_tử ở đầu và cuối đoạn i , j là giao giữa các phần .\nVí_dụ , để tính RMQ_A(2 , 7) ta chỉ_cần so_sánh A2 , AM1 , A6 và A7 .\nDễ thấy thuật_toán không sử_dụng quá 3\\sqrt N phép_toán cho mỗi truy_vấn .\nSparse_Table (ST) Đây là một hướng tiếp_cận tốt hơn để tiền xử_lý RMQ cho các đoạn con có độ_dài 2k , sử_dụng quy_hoạch_động .\nTa sử_dụng mảng M0 , N-10 , logN với Mij là chỉ_số của phần_tử có_giá trị nhỏ nhất trong đoạn có độ_dài 2j và bắt_đầu ở i .\nVí_dụ : Để tính Mij , ta xét M của 2 nửa đầu và nửa cuối của đoạn , mỗi phần sẽ có độ_dài 2j-1 : void process2 ( int M_MAXN_LOGMAXN , int A_MAXN , int N ) int i , j ; // Khởi tạo M với các khoảng độ_dài 1 for ( i = 0 ; i lt; N ; i ++ ) M i 0 = i ; // Tính_M với các khoảng dài 2j for ( j = 1 ; 1 lt;lt; j lt;= N ; j ++ ) for ( i = 0 ; i + ( 1 lt;lt; j ) - 1 lt; N ; i ++ ) if ( A_M i j - 1 lt; A_M i + ( 1 lt;lt; ( j - 1 )) j - 1 ) M i j = M i j - 1 ; else M i j = M i + ( 1 lt;lt; ( j - 1 )) j - 1 ; Để tính RMQ_A(i , j) ta dựa vào 2 đoạn con độ_dài 2k phủ hết i , j , với k= \\lfloor log(j-i+1) \\rfloor : Độ phức_tạp tổng_quát của thuật_toán này là lt; O(NlogN) , O(1) gt; Cây phân_đoạn (segment tree , interval tree , range tree) Ta biểu_diễn cây bằng một mảng M1 , 22logN+1 với Mi là vị_trí có_giá trị nhỏ nhất trong đoạn mà nút i quản_lý .\nKhởi tạo : void initialize ( intnode , int b , int e , int M_MAXIND , int A_MAXN , int N ) if ( b == e ) M node = b ; else // Khởi tạo nút con trái và nút con phải initialize ( 2 node , b , ( b + e ) / 2 , M , A , N ); initialize ( 2 node + 1 , ( b + e ) / 2 + 1 , e , M , A , N ); // Tính giá_trị nhỏ nhất dựa trên 2 nút con if ( A_M 2 node lt;= A_M 2 node + 1 ) M node = M 2 node ; else M node = M 2 node + 1 ; Truy_vấn : int query ( int node , int b , int e , int M_MAXIND , int A_MAXN , int i , int j ) int p1 , p2 ; // Đoạn cần tính không giao với đoạn của nút hiện_tại // --gt; return -1 if ( i gt; e j lt; b ) return - 1 ; // Đoạn cần tính nằm trong hoàn_toàn trong đoạn của nút hiện_tại // --gt; return Mnode if ( b gt;= i amp;amp; e lt;= j ) return M node ; // Tìm giá_trị nhỏ nhất trong 2 cây_con trái và cây_con phải p1 = query ( 2 node , b , ( b + e ) / 2 , M , A , i , j ); p2 = query ( 2 node + 1 , ( b + e ) / 2 + 1 , e , M , A , i , j ); // Tìm giá_trị nhỏ nhất trong các cây_con if ( p1 == - 1 ) return M node = p2 ; if ( p2 == - 1 ) return M node = p1 ; if ( A p1 lt;= A p2 ) return M node = p1 ; return M node = p2 ; Mỗi truy_vấn sẽ được thực_hiện trong O(logN) và thuật_toán có độ phức_tạp tổng_quát là lt; O(N) , O(logN) gt; Bài_toán LCA Thuật_toán lt; O(N) , O(N) gt; Thuật_toán đơn_giản nhất như_sau : Đặt h(u) là độ_cao của đỉnh u .\nĐể trả_lời truy_vấn u , v .\nKhông làm mất tính tổng_quát , giả_sử h(u) gt; h(v) .\nTa đi từ u đến u , với u là tổ_tiên của u và h(u) = h(v) .\nTa đồng_thời đi từ u và v lên cha của nó , đến khi 2 đỉnh này trùng nhau (lúc đó cả 2 đỉnh đều ở LCA) .\nVí_dụ : Ta cần tìm LCA của u và v .\nBan_đầu h(u) gt; h(v) .\nTa đi từ u đến tổ_tiên của u mà có h(u) = h(v) : Đi từ u lên u4 lên u3 .\nSau_đó đồng_thời đi từ u và v lên cha của nó đến khi 2 đỉnh bằng_nhau : u = u2 , v = v2 u = u1 , v = v1 u = v = lca function LCA(u , v) : if h(u) lt; h(v) : swap(u , v) while h(u) gt; h(v) : u = parent(u) while u ! = v : u = parent(u) v = parent(v) return u Thuật_toán lt; O(N) , O(\\sqrt_N) gt; Ý_tưởng chia input thành các phần bằng_nhau như trong bài_toán RMQ cũng có_thể được sử_dụng với LCA .\nChúng_ta sẽ chia cây thành \\sqrt H phần , với H là chiều_cao cây .\nPhần đầu bao_gồm các tầng từ 0 đến \\sqrt H-1 , phần 2 sẽ gồm các tầng từ \\sqrt H đến 2\\sqrt H-1 , . . . : Giờ với mỗi nút chúng_ta có_thể biết được nút tổ_tiên ở phần ngay trên nó .\nTa sẽ tính giá_trị này sử_dụng mảng P1 , MAXN : Ta có_thể tính P bằng DFS (Ti là cha của i , nr=\\sqrt H và Li là tầng của nút i) void dfs ( int node , int T_MAXN , int N , int P_MAXN , int L_MAXN , int nr ) int k ; // Nếu nút ở phần đầu_tiên , thì Pnode = 1 // Nếu nút ở đầu của 1 phần , thì Pnode = Tnode // Trường_hợp còn_lại , Pnode = PTnode if ( L node lt; nr ) P node = 1 ; else if ( ! ( L node % nr )) P node = T node ; else P node = P_T node ; // DFS xuống các con for each_son k of node dfs ( k , T , N , P , L , nr ); Truy_vấn : int LCA ( int T_MAXN , int P_MAXN , int L_MAXN , int x , int y ) // Nếu còn nút ở phần tiếp_theo không_phải là tổ_tiên của cả x và y , // ta nhảy lên phần tiếp_theo .\nĐoạn này cũng tương_tự như thuật_toán // lt;O(1) , O(N)gt; nhưng thay_vì nhảy từng nút , ta nhảy từng đoạn .\nwhile ( P x ! = P y ) if ( L x gt; L y ) x = P x ; else y = P y ; // Giờ x và y ở cùng phần .\nTa tìm LCA giống_như thuật lt;O(1) , O(N)gt; while ( x ! = y ) if ( L x gt; L y ) x = T x ; else y = T y ; return x ; Hàm này sử_dụng tối_đa 2\\sqrt H phép_toán .\nVới cách tiếp_cận này chúng_ta có thuật_toán lt; O(N) , O(\\sqrt_H) gt; , trong trường_hợp tệ nhất_thì N=H nên độ phức_tạp tổng_quát của thuật_toán là lt; O(N) , O(\\sqrt_N) gt; .\nThuật_toán lt; O(NlogN) , O(logN) gt; Ứng_dụng Sparse_Table chúng_ta có_một thuật_toán nhanh hơn .\nĐầu_tiên chúng_ta tính một bảng P1 , N1 , logN với Pij là tổ_tiên thứ 2j của i : Code : void process3 ( int N , int T_MAXN , int P_MAXN_LOGMAXN ) int i , j ; // Khởi tạo for ( i = 0 ; i lt; N ; i ++ ) for ( j = 0 ; 1 lt;lt; j lt; N ; j ++ ) P i j = - 1 ; // Khởi tạo cha thứ 20 = 1 của mỗi nút for ( i = 0 ; i lt; N ; i ++ ) P i 0 = T i ; // Quy_hoạch_động for ( j = 1 ; 1 lt;lt; j lt; N ; j ++ ) for ( i = 0 ; i lt; N ; i ++ ) if ( P i j - 1 ! = - 1 ) P i j = P_P i j - 1 j - 1 ; Bước khởi tạo này tốn O(NlogN) bộ_nhớ lẫn thời_gian .\nCách tìm LCA giống_hệt như thuật_toán , nhưng để tăng_tốc , thay_vì nhảy lên cha ở mỗi bước , thì ta dùng mảng P để nhảy , từ_đó thu được độ phức_tạp O(logN) cho mỗi bước .\nCụ_thể : Gọi h(u) là độ_cao của nút u .\nĐể tính LCA(u , v) , giả_sử h(u) gt; h(v) , đầu_tiên_ta tìm u là tổ_tiên của u và có h(u) = h(v) : Rõ_ràng , ta cần nhảy từ u lên cha thứ h(u) - h(v) .\nTa chuyển h(u) - h(v) sang hệ 2 .\nDuyệt j từ log(h(u)) xuống 0 , nếu tổ_tiên thứ 2j của u không cao hơn v thì ta cho p nhảy lên tổ_tiên thứ 2j của nó .\nSau khi u và v đã ở cùng tầng , ta sẽ tính LCA(u , v) : cũng_như trên , ta sẽ duyệt j từ log(h(u)) xuống 0 , nếu tổ_tiên thứ 2j của u và v khác_nhau thì chắc_chắn LCA(u , v) sẽ ở cao hơn , khi đó ta sẽ cho cả u và v nhảy lên tổ_tiên thứ 2j của nó .\nCuối_cùng thì u và v sẽ có cùng cha , vậy_nên khi đó LCA(u , v) = Tu = Tv . Code : function LCA(N , PMAXNMAXLOGN , TMAXN , hMAXN , u , v) : if h(u) lt; h(v) : // Đổi u và v swap(u , v) log = log2( h(u) ) // Tìm tổ_tiên u của u sao_cho h(u) = h(v) for i = log . .\n0 : if h(u) - 2i gt;= h(v) : u = Pui if u == v : return u // Tính_LCA(u , v) : for i = log . .\n0 : if Pui ! = -1 and Pui ! = Pvi : u = Pui v = Pvi return Tu;_Mỗi lần gọi hàm này chỉ tốn tối_đa 2logH phép_toán .\nTrong trường_hợp tệ nhất_thì H=N nên độ phức_tạp tổng_quát của thuật_toán này là lt; O(NlogN) , O(logN) gt; .\nBài_toán LCA còn có nhiều cách giải thú_vị khác .\nCác bạn có_thể tham_khảo thêm trong bài viết này .\nTừ_LCA đến RMQ_Ta có_thể biến_đổi bài_toán LCA thành bài_toán RMQ trong thời_gian tuyến_tính , do_đó mà mọi thuật_toán để giải bài_toán RMQ đều có_thể sử_dụng để giải bài_toán LCA .\nHãy cùng xét ví_dụ sau : Để_ý rằng LCA_T(u , v) là nút gần gốc nhất xuất_hiện giữa lúc thăm u và v trong phép duyệt DFS .\nVì_thế ta có_thể xét tất_cả các phần_tử giữa các cặp_chỉ số bất_kì của u và v trong dãy Euler_Tour và tìm nút cao nhất .\nTa xây_dựng 3 mảng : E1 , 2N-1 : dãy thứ_tự thăm của các nút trên đường_đi Euler , Ei là nút được thăm thứ i trên đường_đi .\nL1 , 2N-1 : tầng của các nút , Li là tầng của nút Ei_H1 , N : Hi là vị_trí xuất_hiện đầu_tiên của nút i trên Euler_Tour_Gỉa sử Hult;Hv . Dễ thấy việc cần làm lúc_này là tìm nút có L nhỏ nhất trên EHu . . Hv . Do_đó LCA_T(u , v)=ERMQ_L(Hu , Hv)) .\nVí_dụ : Cũng dễ thấy là mỗi 2 phần_tử liên_tiếp trong L đều hơn kém nhau đúng 1 đơn_vị .\nTừ_RMQ đến LCA_Một cây Cartesian của một dãy A0 , N-1 là một cây nhị_phân C(A) có gốc là phần_tử nhỏ nhất trong A và có_vị trí i .\nCây_con trái của C(A) là cây Cartesian của A0 , i-1 nếu igt;0 , ngược_lại thì không có .\nCây_con phải của C(A) là cây Cartesian của Ai+1 , N-1 .\nDễ thấy rằng RMQ_A(i , j)=LCA_C(i , j) .\nBây_giờ việc cần làm chỉ còn là tính C(A) trong thời_gian tuyến_tính .\nChúng_ta sẽ sử_dụng một cái stack .\nBan_đầu stack rỗng .\nTa lần_lượt đẩy các phần_tử của A vào stack .\nTại bước thứ i , Ai sẽ được đẩy vào ngay cạnh phần_tử cuối_cùng không lớn hơn Ai trong stack , các phần_tử lớn hơn Ai bị loại khỏi stack .\nPhần_tử trong stack ở vị_trí của Ai trước_khi chèn Ai vào sẽ là con trái của i , còn i sẽ là con phải của phần_tử trước nó trong stack .\nỞ mỗi bước thì phần_tử đầu_tiên trong stack sẽ là gốc của cây Cartesian .\nVí_dụ đối_với cây ở trên : Bước_Stack_Sự hình_thành cây 0 0 0 là nút duy_nhất trong cây 1 0 1 1 được đẩy vào cuối stack .\nGiờ 1 là con phải của 0 2 0 2 A2 lt; A1) .\nLúc_này 2 là con phải của 0 và con trái của 2 là 1 3 3 A3 hiện đang là phần_tử nhỏ nhất cho_nên mọi phần_tử của stack bị lấy ra ra và 3 trở_thành gốc cây .\nCon trái của 3 là 0 4 3 4 4 được thêm vào cạnh 3 và con phải của 3 là 4 5 3 4 5 5 được thêm vào cạnh 4 , con phải của 4 là 5 6 3 4 5 6 6 được thêm vào cạnh 5 , con phải của 5 là 6 7 3 4 5 6 7 7 được thêm vào cạnh 6 , con phải của 6 là 7 8 3 8 8 được thêm vào cạnh 3 , các phần_tử lớn hơn bị loại_bỏ .\n8 giờ là con phải của 3 và con trái của 8 là 4 9 3 8 9 9 được thêm vào cạnh 8 , con phải của 8 là 9 Vì mỗi phần_tử của A đều chỉ đẩy vào và lấy ra 1 lần nên độ phức_tạp thuật_toán là O(N) .\nvoid computeTree ( int A_MAXN , int N , int T_MAXN ) int st MAXN , i , k , top = - 1 ; // Bắt_đầu với stack rỗng // Ở bước thứ i ta đẩy i và stack for ( i = 0 ; i lt; N ; i ++ ) //Tìm vị_trí của phần_tử đầu_tiên nhỏ hơn hoặc bằng Ai trong stack k = top ; while ( k gt;= 0 amp;amp; A st k gt; A i ) k -- ; // Chỉnh_sửa cây theo mô_tả ở trên if ( k ! = - 1 ) T i = st k ; if ( k lt; top ) T st k + 1 = i ; // Đẩy i vào stack rồi xóa các phần_tử lớn hơn Ai st ++ k = i ; top = k ; // Phần_tử đầu_tiên trong stack là gốc cây nên nó không có cha T st 0 = - 1 ; Thuật_toán lt; O(N) , O(1) gt; cho bài_toán RMQ thu_hẹp Bài_toán RMQ phát_sinh khi giải bài_toán LCA chỉ là trường_hợp đặc_biệt của bài_toán RMQ tổng_quát , do ta có_điều kiện Ai-Ai-1=1 với mọi i\\in1 , N-1 (lý do là 2 phần_tử liên_tiếp có quan_hệ cha con với nhau) .\nTa gọi bài_toán RMQ này là bài_toán RMQ thu_hẹp .\nTrong 1 số tài_liệu còn được gọi_là bài_toán \\pm 1 RMQ .\nTrong mục này , ta sẽ nghiên_cứu một thuật_toán có độ phức_tạp tốt hơn cho bài_toán RMQ thu_hẹp .\nHãy biến_đổi A thành một dãy nhị_phân có N-1 phần_tử , với Bi=Ai-Ai-1 .\nNhư_vậy Ai=A0+B1+ . . +Bi và Bi chỉ nhận giá_trị 1 hoặc -1 .\nChúng_ta chia A thành các block kích_thước l=log(N)/2 .\nGọi_Mi là giá_trị nhỏ nhất trong block thứ i và Di là vị_trí của giá_trị nhỏ nhất này trong A .\nCả_M và D đều có N/l phần_tử .\nTính_Sparse_Table cho M , tốn O(N/llog(N/l))=O(N) về bộ_nhớ và thời_gian .\nDùng sparse table cho mảng M , ta tính được_giá trị nhỏ nhất của 1 vài block trong O(1) .\nNhưng ta vẫn cần tính RMQ giữa 2 vị_trí bất_kì trong cùng một block .\nĐể làm được điều này , nhận_thấy B là một dãy nhị_phân , mà mỗi block có l phần_tử .\nVì số_lượng dãy nhị_phân_độ dài l là 2l=\\sqrt N là một_số khá nhỏ nên chúng_ta có_thể tính được mảng P\\sqrt(N)ll , với P(b , i , j) là giá_trị nhỏ nhất trong các bit từ i đến j của dãy nhị_phân b .\nDễ_dàng khởi tạo P bằng quy_hoạch_động trong cả thời_gian và bộ_nhớ O(\\sqrt_Nl2) .\nChú_ý rằng , ta cũng cần biết giá_trị b trong O(1) với mỗi block của mảng A .\nDo_đó , ta cần khởi tạo mảng T với N/l phần_tử , mỗi phần_tử cho_biết giá_trị b của block tương_ứng .\nKết_hợp mảng T , P với Sparse table cho mảng M , ta có_thể trả_lời truy_vấn RMQ_A(i , j) trong O(1) .\nTa có 2 trường_hợp : i và j thuộc cùng block .\nTa dùng mảng T để biết dãy nhị_phân b ở block chứa i và j .\nTính u và v là vị_trí của i và j trong block .\nKết_quả chính là P(b , u , v) .\ni và j thuộc 2 block khác_nhau : kết_quả sẽ là giá_trị nhỏ nhất của 3 giá_trị : Giá_trị nhỏ nhất của các phần_tử trong block chứa i và nằm bên phải i : Dùng mảng T để biết được_giá trị của dãy nhị_phân của block chứa i là b .\nTính chỉ_số của i trong block chứa i là u .\nKết_quả chính là P(b , i , l) .\nGiá_trị nhỏ nhất của các phần_tử trong block chứa j và nằm bên trái j : làm tương_tự trường_hợp trên Giá_trị nhỏ nhất của các phần_tử thuộc các block nằm giữa block chứa i và block chứa j .\nDùng_Sparse table cho M , ta dễ_dàng tính được_giá trị này trong O(1) .\nMột_số bài để luyện_tập CF 278 Div 1 - B_Bayan 2015 Contest_Warm_Up - D_Hello 2015 (Div . 1) - A_LCA_QTREE2_HBTLCA_UPGRANET_VOTREE_SRM 310 - Floating_Median_Lorenzo_Von_Matterhorn http : //acm . pku . edu . cn/JudgeOnline/problem ? id=1986 http : //acm . pku . edu . cn/JudgeOnline/problem ? id=2374 http : //acmicpc-live-archive . uva . es/nuevoportal/data/problem . php ? p=2045 http : //acm . pku . edu . cn/JudgeOnline/problem ? id=2763 http : //acm . uva . es/p/v109/10938 . html http : //acm . sgu . ru/problem . php ? contest=0amp;problem=155\n", "tagged": "Nguồn/N :/CH Topcoder_Table/Np of_Contents/Np Các/L định_nghĩa/N Bài_toán/N Range_Minimum_Query/Np (RMQ)/Np Bài_toán/N Lowest_Common_Ancestor/Np (LCA)/Np Bài_toán/N RMQ/Np Thuật_toán/N lt;/Np O(1)/Np ,/CH O(N)/Np gt;/Np Thuật_toán/N lt;/Np O(N2)/Np ,/CH O(1)/Np gt;/Np Thuật_toán/N lt;/Np O(N)/Np ,/CH O(\\sqrt_N)/Np gt;/Np Sparse_Table/Np (ST)/Np Cây/N phân_đoạn/Np (segment/Np tree/Np ,/CH interval/Np tree/Np ,/CH range/Np tree)/Np Bài_toán/N LCA/Np Thuật_toán/N lt;/Np O(N)/Np ,/CH O(N)/Np gt;/Np Thuật_toán/N lt;/Np O(N)/Np ,/CH O(\\sqrt_N)/Np gt;/Np Thuật_toán/N lt;/Np O(NlogN)/Np ,/CH O(logN)/Np gt;/Np Từ_LCA/Np đến/E RMQ_Từ_RMQ/Np đến/E LCA/Np Thuật_toán/N lt;/Np O(N)/Np ,/CH O(1)/Np gt;/Np cho/E bài_toán/N RMQ/Np thu_hẹp/V Một_số/L bài/N để/E luyện_tập/V Trong/E bài/N viết/V này/P ,/CH tác_giả/N sẽ/R giới_thiệu/V với/E bạn/N 2/M bài_toán/N cơ_bản/A :/CH Bài_toán/N RMQ/Np và/Cc bài_toán/N LCA/Np ,/CH cũng_như/C mối/N liên_hệ/V giữa/N 2/M bài_toán/N này/P ./CH\nCác/L định_nghĩa/N Gỉa/Np sử/Np thuật_toán/N có/V thời_gian/N tiền/N xử_lý/V là/V f(n)/Np và/Cc thời_gian/N trả_lời/V 1/M truy_vấn/Np là/V g(n)/Np ./CH\nTa/P ký_hiệu/Np độ/N phức_tạp/A tổng_quát/Np của/E thuật_toán/N là/V lt;/Np f(n)/Np ,/CH g(n)/Np gt;/Np ./CH\nTrong/E bài/N này/P ,/CH khi/N viết/V \\logN/Np ,/CH chúng_ta/P hiểu/V là/V log/Np cơ_số/N 2/M của/E N/Ny ./CH\nBài_toán/N Range_Minimum_Query/Np (RMQ)/Np Cho/E mảng/N A0/Np ,/CH N-1/Np ./CH\nBạn/N cần/V trả_lời/V Q/Ny truy_vấn/Np ./CH\nMỗi/L truy_vấn/Np gồm/V 2/M số/N i/M ,/CH j/Np và/Cc bạn/N cần/V đưa_ra/Np vị_trí/N của/E phần_tử/N có_giá/Np trị/V nhỏ/A nhất/A trong/E đoạn/Nc từ/E i/M đến/E j/Np của/E mảng/N A/Ni ,/CH ký_hiệu/Np là/V RMQ_A(i/Np ,/CH j)/Np ./CH\nBài_toán/N Lowest_Common_Ancestor/Np (LCA)/Np Cho/E cây/N có/V gốc/N T/Nu ./CH\nBạn/N cần/V trả_lời/V Q/Ny truy_vấn/Np ./CH\nMỗi/L truy_vấn/Np gồm/V 2/M số/N u/N ,/CH v/Nu và/Cc bạn/N cần/V tìm/V nút/N xa/A gốc/N nhất/A mà/C là/V tổ_tiên/N của/E cả/P 2/M nút/N u/N và/Cc v/Nu ,/CH ký_hiệu/Np là/V LCA_T(u/Np ,/CH v)/Np ./CH\nBài_toán/N RMQ/Np Thuật_toán/N lt;/Np O(1)/Np ,/CH O(N)/Np gt;/Np Thuật_toán/N hiển_nhiên/Np nhất/A cho/E bài/N RMQ/Np là/V ta/P không/R cần/V tiền/N xử_lý/V gì/P cả/P ./CH\nVới/E mỗi/L truy_vấn/Np ,/CH ta/P xét/V lần_lượt/R từng/R phần_tử/N từ/E i/M đến/E j/Np để/E tìm/V phần_tử/N nhỏ/A nhất/A ./CH\nHiển_nhiên/Np ,/CH độ/N phức_tạp/A thuật_toán/N này/P là/V lt;/Np O(1)/Np ,/CH O(N)/Np gt;/Np ./CH\nThuật_toán/N lt;/Np O(N2)/Np ,/CH O(1)/Np gt;/Np Lưu/V giá_trị/N của/E RMQ_A(i/Np ,/CH j)/Np trong/E một/M bảng/N M0/Np ,/CH N-10/Np ,/CH N-1/Np ./CH\nThuật_toán/N sẽ/R có/V độ/N phức_tạp/A lt;/Np O(N3)/Np ,/CH O(1)/Np gt;/Np ./CH\nTuy_nhiên/C ta/P có_thể/R sử_dụng/V quy_hoạch_động/Np để/E giảm/V độ/N phức_tạp/A xuống/V lt;/Np O(N2)/Np ,/CH O(1)/Np gt;/Np như_sau/Np :/CH for/Np i/M =/CH 0/M ./CH ./CH\nN-1_Mii/Np =/CH i;/Np for/Np i/M =/CH 0/M ./CH ./CH\nN-1/Np for/Np j/Np =/CH i+1/Np ./CH ./CH\nN-1/Np if/Np (AMij/Np -/CH 1/M lt;/Np Aj)_Mij/Np =/CH Mij/Np -/CH 1;/Np else/Np Mij/Np =/CH j;/Np Có_thể/R thấy/V thuật_toán/N này/P khá/R chậm/A và/Cc tốn/V bộ_nhớ/Np O(N2)/Np nên/C sẽ/R không/R hữu_ích/A với/E những/L dữ_liệu/N lớn/A hơn/A ./CH\nThuật_toán/N lt;/Np O(N)/Np ,/CH O(\\sqrt_N)/Np gt;/Np Ta/P có_thể/R chia/V mảng/N thành/V \\sqrt/Np N/Ny phần/N ./CH\nTa/P sử_dụng/V một/M mảng/N M0/Np ,/CH \\sqrt/Np N/Ny để/E lưu/V giá_trị/N mỗi/L phần/N ./CH\nM/Nu có_thể/R dễ_dàng/A tính/V được/V trong/E O(N)/Np :/CH Để/E tính/V RMQ_A(i/Np ,/CH j)/Np ,/CH chúng_ta/P xét/V giá_trị/N M/Nu của/E \\sqrt/Np N/Ny phần/N nằm/V trong/E đoạn/Nc i/M ,/CH j/Np ,/CH và/Cc những/L phần_tử/N ở/E đầu/N và/Cc cuối/N đoạn/Nc i/M ,/CH j/Np là/V giao/V giữa/N các/L phần/N ./CH\nVí_dụ/C ,/CH để/E tính/V RMQ_A(2/Np ,/CH 7)/Np ta/P chỉ_cần/Np so_sánh/V A2/Np ,/CH AM1/Np ,/CH A6/Np và/Cc A7/Np ./CH\nDễ/A thấy/V thuật_toán/N không/R sử_dụng/V quá/R 3\\sqrt/Np N/Ny phép_toán/Np cho/E mỗi/L truy_vấn/Np ./CH\nSparse_Table/Np (ST)/Np Đây/P là/V một/M hướng/N tiếp_cận/V tốt/A hơn/A để/E tiền/N xử_lý/V RMQ/Np cho/E các/L đoạn/Nc con/Nc có/V độ_dài/Np 2k/Np ,/CH sử_dụng/V quy_hoạch_động/Np ./CH\nTa/P sử_dụng/V mảng/N M0/Np ,/CH N-10/Np ,/CH logN/Np với/E Mij/Np là/V chỉ_số/N của/E phần_tử/N có_giá/Np trị/V nhỏ/A nhất/A trong/E đoạn/Nc có/V độ_dài/Np 2j/Np và/Cc bắt_đầu/V ở/E i/M ./CH\nVí_dụ/C :/CH Để/E tính/V Mij/Np ,/CH ta/P xét/V M/Nu của/E 2/M nửa/M đầu/N và/Cc nửa/M cuối/N của/E đoạn/Nc ,/CH mỗi/L phần/N sẽ/R có/V độ_dài/Np 2j-1/Np :/CH void/Np process2/Np (/CH int/Np M_MAXN_LOGMAXN/Np ,/CH int/Np A_MAXN/Np ,/CH int/Np N/Ny )/CH int/Np i/M ,/CH j/Np ;/CH //CH Khởi/V tạo/V M/Nu với/E các/L khoảng/N độ_dài/Np 1/M for/Np (/CH i/M =/CH 0/M ;/CH i/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH M/Nu i/M 0/M =/CH i/M ;/CH //CH Tính_M/Np với/E các/L khoảng/N dài/A 2j/Np for/Np (/CH j/Np =/CH 1/M ;/CH 1/M lt;lt;/Np j/Np lt;=/Np N/Ny ;/CH j/Np ++/Np )/CH for/Np (/CH i/M =/CH 0/M ;/CH i/M +/CH (/CH 1/M lt;lt;/Np j/Np )/CH -/CH 1/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH if/Np (/CH A_M/Np i/M j/Np -/CH 1/M lt;/Np A_M/Np i/M +/CH (/CH 1/M lt;lt;/Np (/CH j/Np -/CH 1/M ))/Np j/Np -/CH 1/M )/CH M/Nu i/M j/Np =/CH M/Nu i/M j/Np -/CH 1/M ;/CH else/Np M/Nu i/M j/Np =/CH M/Nu i/M +/CH (/CH 1/M lt;lt;/Np (/CH j/Np -/CH 1/M ))/Np j/Np -/CH 1/M ;/CH Để/E tính/V RMQ_A(i/Np ,/CH j)/Np ta/P dựa/V vào/E 2/M đoạn/Nc con/Nc độ_dài/Np 2k/Np phủ/V hết/V i/M ,/CH j/Np ,/CH với/E k=/Np \\lfloor/Np log(j-i+1)/Np \\rfloor/Np :/CH Độ/N phức_tạp/A tổng_quát/Np của/E thuật_toán/N này/P là/V lt;/Np O(NlogN)/Np ,/CH O(1)/Np gt;/Np Cây/N phân_đoạn/Np (segment/Np tree/Np ,/CH interval/Np tree/Np ,/CH range/Np tree)/Np Ta/P biểu_diễn/V cây/N bằng/E một/M mảng/N M1/Np ,/CH 22logN+1/Np với/E Mi/Np là/V vị_trí/N có_giá/Np trị/V nhỏ/A nhất/A trong/E đoạn/Nc mà/C nút/N i/M quản_lý/V ./CH\nKhởi/V tạo/V :/CH void/Np initialize/Np (/CH intnode/Np ,/CH int/Np b/Ni ,/CH int/Np e/Ni ,/CH int/Np M_MAXIND/Np ,/CH int/Np A_MAXN/Np ,/CH int/Np N/Ny )/CH if/Np (/CH b/Ni ==/Np e/Ni )/CH M/Nu node/Np =/CH b/Ni ;/CH else/Np //CH Khởi/V tạo/V nút/N con/Nc trái/Nc và/Cc nút/N con/Nc phải/V initialize/Np (/CH 2/M node/Np ,/CH b/Ni ,/CH (/CH b/Ni +/CH e/Ni )/CH //CH 2/M ,/CH M/Nu ,/CH A/Ni ,/CH N/Ny );/CH initialize/Np (/CH 2/M node/Np +/CH 1/M ,/CH (/CH b/Ni +/CH e/Ni )/CH //CH 2/M +/CH 1/M ,/CH e/Ni ,/CH M/Nu ,/CH A/Ni ,/CH N/Ny );/CH //CH Tính/V giá_trị/N nhỏ/A nhất/A dựa/V trên/E 2/M nút/N con/Nc if/Np (/CH A_M/Np 2/M node/Np lt;=/Np A_M/Np 2/M node/Np +/CH 1/M )/CH M/Nu node/Np =/CH M/Nu 2/M node/Np ;/CH else/Np M/Nu node/Np =/CH M/Nu 2/M node/Np +/CH 1/M ;/CH Truy_vấn/Np :/CH int/Np query/Np (/CH int/Np node/Np ,/CH int/Np b/Ni ,/CH int/Np e/Ni ,/CH int/Np M_MAXIND/Np ,/CH int/Np A_MAXN/Np ,/CH int/Np i/M ,/CH int/Np j/Np )/CH int/Np p1/Np ,/CH p2/Np ;/CH //CH Đoạn/Nc cần/V tính/V không/R giao/V với/E đoạn/Nc của/E nút/N hiện_tại/N //CH --gt;/Np return/Np -1/Np if/Np (/CH i/M gt;/Np e/Ni j/Np lt;/Np b/Ni )/CH return/Np -/CH 1/M ;/CH //CH Đoạn/Nc cần/V tính/V nằm/V trong/E hoàn_toàn/A trong/E đoạn/Nc của/E nút/N hiện_tại/N //CH --gt;/Np return/Np Mnode/Np if/Np (/CH b/Ni gt;=/Np i/M amp;amp;/Np e/Ni lt;=/Np j/Np )/CH return/Np M/Nu node/Np ;/CH //CH Tìm/V giá_trị/N nhỏ/A nhất/A trong/E 2/M cây_con/Np trái/Nc và/Cc cây_con/Np phải/V p1/Np =/CH query/Np (/CH 2/M node/Np ,/CH b/Ni ,/CH (/CH b/Ni +/CH e/Ni )/CH //CH 2/M ,/CH M/Nu ,/CH A/Ni ,/CH i/M ,/CH j/Np );/CH p2/Np =/CH query/Np (/CH 2/M node/Np +/CH 1/M ,/CH (/CH b/Ni +/CH e/Ni )/CH //CH 2/M +/CH 1/M ,/CH e/Ni ,/CH M/Nu ,/CH A/Ni ,/CH i/M ,/CH j/Np );/CH //CH Tìm/V giá_trị/N nhỏ/A nhất/A trong/E các/L cây_con/Np if/Np (/CH p1/Np ==/Np -/CH 1/M )/CH return/Np M/Nu node/Np =/CH p2/Np ;/CH if/Np (/CH p2/Np ==/Np -/CH 1/M )/CH return/Np M/Nu node/Np =/CH p1/Np ;/CH if/Np (/CH A/Ni p1/Np lt;=/Np A/Ni p2/Np )/CH return/Np M/Nu node/Np =/CH p1/Np ;/CH return/Np M/Nu node/Np =/CH p2/Np ;/CH Mỗi/L truy_vấn/Np sẽ/R được/V thực_hiện/V trong/E O(logN)/Np và/Cc thuật_toán/N có/V độ/N phức_tạp/A tổng_quát/Np là/V lt;/Np O(N)/Np ,/CH O(logN)/Np gt;/Np Bài_toán/N LCA/Np Thuật_toán/N lt;/Np O(N)/Np ,/CH O(N)/Np gt;/Np Thuật_toán/N đơn_giản/A nhất/A như_sau/Np :/CH Đặt/V h(u)/Np là/V độ_cao/Np của/E đỉnh/N u/N ./CH\nĐể/E trả_lời/V truy_vấn/Np u/N ,/CH v/Nu ./CH\nKhông/R làm/V mất/V tính/V tổng_quát/Np ,/CH giả_sử/Np h(u)/Np gt;/Np h(v)/Np ./CH\nTa/P đi/V từ/E u/N đến/E u/N ,/CH với/E u/N là/V tổ_tiên/N của/E u/N và/Cc h(u)/Np =/CH h(v)/Np ./CH\nTa/P đồng_thời/R đi/V từ/E u/N và/Cc v/Nu lên/V cha/N của/E nó/P ,/CH đến/E khi/N 2/M đỉnh/N này/P trùng/V nhau/N (lúc/Np đó/P cả/P 2/M đỉnh/N đều/R ở/E LCA)/Np ./CH\nVí_dụ/C :/CH Ta/P cần/V tìm/V LCA/Np của/E u/N và/Cc v/Nu ./CH\nBan_đầu/N h(u)/Np gt;/Np h(v)/Np ./CH\nTa/P đi/V từ/E u/N đến/E tổ_tiên/N của/E u/N mà/C có/V h(u)/Np =/CH h(v)/Np :/CH Đi/V từ/E u/N lên/V u4/Np lên/V u3/Np ./CH\nSau_đó/Np đồng_thời/R đi/V từ/E u/N và/Cc v/Nu lên/V cha/N của/E nó/P đến/E khi/N 2/M đỉnh/N bằng_nhau/Np :/CH u/N =/CH u2/Np ,/CH v/Nu =/CH v2/Np u/N =/CH u1/Np ,/CH v/Nu =/CH v1/Np u/N =/CH v/Nu =/CH lca/Np function/Np LCA(u/Np ,/CH v)/Np :/CH if/Np h(u)/Np lt;/Np h(v)/Np :/CH swap(u/Np ,/CH v)/Np while/Np h(u)/Np gt;/Np h(v)/Np :/CH u/N =/CH parent(u)/Np while/Np u/N !/CH =/CH v/Nu :/CH u/N =/CH parent(u)/Np v/Nu =/CH parent(v)/Np return/Np u/N Thuật_toán/N lt;/Np O(N)/Np ,/CH O(\\sqrt_N)/Np gt;/Np Ý_tưởng/N chia/V input/Np thành/V các/L phần/N bằng_nhau/Np như/C trong/E bài_toán/N RMQ/Np cũng/R có_thể/R được/V sử_dụng/V với/E LCA/Np ./CH\nChúng_ta/P sẽ/R chia/V cây/N thành/V \\sqrt/Np H/Ny phần/N ,/CH với/E H/Ny là/V chiều_cao/N cây/N ./CH\nPhần/N đầu/N bao_gồm/V các/L tầng/N từ/E 0/M đến/E \\sqrt/Np H-1/Np ,/CH phần/N 2/M sẽ/R gồm/V các/L tầng/N từ/E \\sqrt/Np H/Ny đến/E 2\\sqrt/Np H-1/Np ,/CH ./CH ./CH ./CH :/CH Giờ/N với/E mỗi/L nút/N chúng_ta/P có_thể/R biết/V được/V nút/N tổ_tiên/N ở/E phần/N ngay/R trên/E nó/P ./CH\nTa/P sẽ/R tính/V giá_trị/N này/P sử_dụng/V mảng/N P1/Np ,/CH MAXN/Np :/CH Ta/P có_thể/R tính/V P/Ny bằng/E DFS/Np (Ti/Np là/V cha/N của/E i/M ,/CH nr=\\sqrt/Np H/Ny và/Cc Li/Np là/V tầng/N của/E nút/N i)/Np void/Np dfs/Np (/CH int/Np node/Np ,/CH int/Np T_MAXN/Np ,/CH int/Np N/Ny ,/CH int/Np P_MAXN/Np ,/CH int/Np L_MAXN/Np ,/CH int/Np nr/Np )/CH int/Np k/N ;/CH //CH Nếu/C nút/N ở/E phần/N đầu_tiên/A ,/CH thì/C Pnode/Np =/CH 1/M //CH Nếu/C nút/N ở/E đầu/N của/E 1/M phần/N ,/CH thì/C Pnode/Np =/CH Tnode/Np //CH Trường_hợp/N còn_lại/Np ,/CH Pnode/Np =/CH PTnode/Np if/Np (/CH L/Ny node/Np lt;/Np nr/Np )/CH P/Ny node/Np =/CH 1/M ;/CH else/Np if/Np (/CH !/CH (/CH L/Ny node/Np %/CH nr/Np ))/Np P/Ny node/Np =/CH T/Nu node/Np ;/CH else/Np P/Ny node/Np =/CH P_T/Np node/Np ;/CH //CH DFS/Np xuống/V các/L con/Nc for/Np each_son/Np k/N of/E node/Np dfs/Np (/CH k/N ,/CH T/Nu ,/CH N/Ny ,/CH P/Ny ,/CH L/Ny ,/CH nr/Np );/CH Truy_vấn/Np :/CH int/Np LCA/Np (/CH int/Np T_MAXN/Np ,/CH int/Np P_MAXN/Np ,/CH int/Np L_MAXN/Np ,/CH int/Np x/CH ,/CH int/Np y/N )/CH //CH Nếu/C còn/R nút/N ở/E phần/N tiếp_theo/V không_phải/Np là/V tổ_tiên/N của/E cả/P x/CH và/Cc y/N ,/CH //CH ta/P nhảy/V lên/V phần/N tiếp_theo/V ./CH\nĐoạn/Nc này/P cũng/R tương_tự/A như/C thuật_toán/N //CH lt;O(1)/Np ,/CH O(N)gt;/Np nhưng/C thay_vì/X nhảy/V từng/R nút/N ,/CH ta/P nhảy/V từng/R đoạn/Nc ./CH\nwhile/Np (/CH P/Ny x/CH !/CH =/CH P/Ny y/N )/CH if/Np (/CH L/Ny x/CH gt;/Np L/Ny y/N )/CH x/CH =/CH P/Ny x/CH ;/CH else/Np y/N =/CH P/Ny y/N ;/CH //CH Giờ/N x/CH và/Cc y/N ở/E cùng/A phần/N ./CH\nTa/P tìm/V LCA/Np giống_như/Np thuật/Np lt;O(1)/Np ,/CH O(N)gt;/Np while/Np (/CH x/CH !/CH =/CH y/N )/CH if/Np (/CH L/Ny x/CH gt;/Np L/Ny y/N )/CH x/CH =/CH T/Nu x/CH ;/CH else/Np y/N =/CH T/Nu y/N ;/CH return/Np x/CH ;/CH Hàm/Np này/P sử_dụng/V tối_đa/A 2\\sqrt/Np H/Ny phép_toán/Np ./CH\nVới/E cách/N tiếp_cận/V này/P chúng_ta/P có/V thuật_toán/N lt;/Np O(N)/Np ,/CH O(\\sqrt_H)/Np gt;/Np ,/CH trong/E trường_hợp/N tệ/Nu nhất_thì/Np N=H/Np nên/C độ/N phức_tạp/A tổng_quát/Np của/E thuật_toán/N là/V lt;/Np O(N)/Np ,/CH O(\\sqrt_N)/Np gt;/Np ./CH\nThuật_toán/N lt;/Np O(NlogN)/Np ,/CH O(logN)/Np gt;/Np Ứng_dụng/V Sparse_Table/Np chúng_ta/P có_một/Np thuật_toán/N nhanh/A hơn/A ./CH\nĐầu_tiên/A chúng_ta/P tính/V một/M bảng/N P1/Np ,/CH N1/Np ,/CH logN/Np với/E Pij/Np là/V tổ_tiên/N thứ/N 2j/Np của/E i/M :/CH Code/Np :/CH void/Np process3/Np (/CH int/Np N/Ny ,/CH int/Np T_MAXN/Np ,/CH int/Np P_MAXN_LOGMAXN/Np )/CH int/Np i/M ,/CH j/Np ;/CH //CH Khởi/V tạo/V for/Np (/CH i/M =/CH 0/M ;/CH i/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH for/Np (/CH j/Np =/CH 0/M ;/CH 1/M lt;lt;/Np j/Np lt;/Np N/Ny ;/CH j/Np ++/Np )/CH P/Ny i/M j/Np =/CH -/CH 1/M ;/CH //CH Khởi/V tạo/V cha/N thứ/N 20/M =/CH 1/M của/E mỗi/L nút/N for/Np (/CH i/M =/CH 0/M ;/CH i/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH P/Ny i/M 0/M =/CH T/Nu i/M ;/CH //CH Quy_hoạch_động/Np for/Np (/CH j/Np =/CH 1/M ;/CH 1/M lt;lt;/Np j/Np lt;/Np N/Ny ;/CH j/Np ++/Np )/CH for/Np (/CH i/M =/CH 0/M ;/CH i/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH if/Np (/CH P/Ny i/M j/Np -/CH 1/M !/CH =/CH -/CH 1/M )/CH P/Ny i/M j/Np =/CH P_P/Np i/M j/Np -/CH 1/M j/Np -/CH 1/M ;/CH Bước/V khởi/V tạo/V này/P tốn/V O(NlogN)/Np bộ_nhớ/Np lẫn/C thời_gian/N ./CH\nCách/N tìm/V LCA/Np giống_hệt/A như/C thuật_toán/N ,/CH nhưng/C để/E tăng_tốc/Np ,/CH thay_vì/X nhảy/V lên/V cha/N ở/E mỗi/L bước/V ,/CH thì/C ta/P dùng/V mảng/N P/Ny để/E nhảy/V ,/CH từ_đó/Np thu/V được/V độ/N phức_tạp/A O(logN)/Np cho/E mỗi/L bước/V ./CH\nCụ_thể/A :/CH Gọi/V h(u)/Np là/V độ_cao/Np của/E nút/N u/N ./CH\nĐể/E tính/V LCA(u/Np ,/CH v)/Np ,/CH giả_sử/Np h(u)/Np gt;/Np h(v)/Np ,/CH đầu_tiên_ta/Np tìm/V u/N là/V tổ_tiên/N của/E u/N và/Cc có/V h(u)/Np =/CH h(v)/Np :/CH Rõ_ràng/A ,/CH ta/P cần/V nhảy/V từ/E u/N lên/V cha/N thứ/N h(u)/Np -/CH h(v)/Np ./CH\nTa/P chuyển/V h(u)/Np -/CH h(v)/Np sang/V hệ/N 2/M ./CH\nDuyệt/V j/Np từ/E log(h(u))/Np xuống/V 0/M ,/CH nếu/C tổ_tiên/N thứ/N 2j/Np của/E u/N không/R cao/A hơn/A v/Nu thì/C ta/P cho/E p/Ny nhảy/V lên/V tổ_tiên/N thứ/N 2j/Np của/E nó/P ./CH\nSau/E khi/N u/N và/Cc v/Nu đã/R ở/E cùng/A tầng/N ,/CH ta/P sẽ/R tính/V LCA(u/Np ,/CH v)/Np :/CH cũng_như/C trên/E ,/CH ta/P sẽ/R duyệt/V j/Np từ/E log(h(u))/Np xuống/V 0/M ,/CH nếu/C tổ_tiên/N thứ/N 2j/Np của/E u/N và/Cc v/Nu khác_nhau/Np thì/C chắc_chắn/A LCA(u/Np ,/CH v)/Np sẽ/R ở/E cao/A hơn/A ,/CH khi/N đó/P ta/P sẽ/R cho/E cả/P u/N và/Cc v/Nu nhảy/V lên/V tổ_tiên/N thứ/N 2j/Np của/E nó/P ./CH\nCuối_cùng/A thì/C u/N và/Cc v/Nu sẽ/R có/V cùng/A cha/N ,/CH vậy_nên/Np khi/N đó/P LCA(u/Np ,/CH v)/Np =/CH Tu/V =/CH Tv/Np ./CH Code/Np :/CH function/Np LCA(N/Np ,/CH PMAXNMAXLOGN/Np ,/CH TMAXN/Np ,/CH hMAXN/Np ,/CH u/N ,/CH v)/Np :/CH if/Np h(u)/Np lt;/Np h(v)/Np :/CH //CH Đổi/V u/N và/Cc v/Nu swap(u/Np ,/CH v)/Np log/Np =/CH log2(/Np h(u)/Np )/CH //CH Tìm/V tổ_tiên/N u/N của/E u/N sao_cho/Np h(u)/Np =/CH h(v)/Np for/Np i/M =/CH log/Np ./CH ./CH\n0/M :/CH if/Np h(u)/Np -/CH 2i/Np gt;=/Np h(v)/Np :/CH u/N =/CH Pui/Np if/Np u/N ==/Np v/Nu :/CH return/Np u/N //CH Tính_LCA(u/Np ,/CH v)/Np :/CH for/Np i/M =/CH log/Np ./CH ./CH\n0/M :/CH if/Np Pui/Np !/CH =/CH -1/Np and/Np Pui/Np !/CH =/CH Pvi/Np :/CH u/N =/CH Pui/Np v/Nu =/CH Pvi/Np return/Np Tu;_Mỗi/Np lần/N gọi/V hàm/Np này/P chỉ/R tốn/V tối_đa/A 2logH/Np phép_toán/Np ./CH\nTrong/E trường_hợp/N tệ/Nu nhất_thì/Np H=N/Np nên/C độ/N phức_tạp/A tổng_quát/Np của/E thuật_toán/N này/P là/V lt;/Np O(NlogN)/Np ,/CH O(logN)/Np gt;/Np ./CH\nBài_toán/N LCA/Np còn/R có/V nhiều/A cách/N giải/N thú_vị/A khác/A ./CH\nCác/L bạn/N có_thể/R tham_khảo/V thêm/V trong/E bài/N viết/V này/P ./CH\nTừ_LCA/Np đến/E RMQ_Ta/Np có_thể/R biến_đổi/V bài_toán/N LCA/Np thành/V bài_toán/N RMQ/Np trong/E thời_gian/N tuyến_tính/Np ,/CH do_đó/C mà/C mọi/L thuật_toán/N để/E giải/N bài_toán/N RMQ/Np đều/R có_thể/R sử_dụng/V để/E giải/N bài_toán/N LCA/Np ./CH\nHãy/R cùng/A xét/V ví_dụ/C sau/E :/CH Để_ý/V rằng/C LCA_T(u/Np ,/CH v)/Np là/V nút/N gần/A gốc/N nhất/A xuất_hiện/V giữa/N lúc/N thăm/V u/N và/Cc v/Nu trong/E phép/N duyệt/V DFS/Np ./CH\nVì_thế/C ta/P có_thể/R xét/V tất_cả/P các/L phần_tử/N giữa/N các/L cặp_chỉ/Np số/N bất_kì/R của/E u/N và/Cc v/Nu trong/E dãy/Nc Euler_Tour/Np và/Cc tìm/V nút/N cao/A nhất/A ./CH\nTa/P xây_dựng/V 3/M mảng/N :/CH E1/Np ,/CH 2N-1/Np :/CH dãy/Nc thứ_tự/N thăm/V của/E các/L nút/N trên/E đường_đi/Np Euler/Np ,/CH Ei/Np là/V nút/N được/V thăm/V thứ/N i/M trên/E đường_đi/Np ./CH\nL1/Np ,/CH 2N-1/Np :/CH tầng/N của/E các/L nút/N ,/CH Li/Np là/V tầng/N của/E nút/N Ei_H1/Np ,/CH N/Ny :/CH Hi/Np là/V vị_trí/N xuất_hiện/V đầu_tiên/A của/E nút/N i/M trên/E Euler_Tour_Gỉa/Np sử/Np Hult;Hv/Np ./CH Dễ/A thấy/V việc/N cần/V làm/V lúc_này/Np là/V tìm/V nút/N có/V L/Ny nhỏ/A nhất/A trên/E EHu/Np ./CH ./CH Hv/Np ./CH Do_đó/C LCA_T(u/Np ,/CH v)=ERMQ_L(Hu/Np ,/CH Hv))/Np ./CH\nVí_dụ/C :/CH Cũng/R dễ/A thấy/V là/V mỗi/L 2/M phần_tử/N liên_tiếp/A trong/E L/Ny đều/R hơn/A kém/A nhau/N đúng/A 1/M đơn_vị/N ./CH\nTừ_RMQ/Np đến/E LCA_Một/Np cây/N Cartesian/Np của/E một/M dãy/Nc A0/Np ,/CH N-1/Np là/V một/M cây/N nhị_phân/Np C(A)/Np có/V gốc/N là/V phần_tử/N nhỏ/A nhất/A trong/E A/Ni và/Cc có_vị/Np trí/Np i/M ./CH\nCây_con/Np trái/Nc của/E C(A)/Np là/V cây/N Cartesian/Np của/E A0/Np ,/CH i-1/Np nếu/C igt;0/Np ,/CH ngược_lại/X thì/C không/R có/V ./CH\nCây_con/Np phải/V của/E C(A)/Np là/V cây/N Cartesian/Np của/E Ai+1/Np ,/CH N-1/Np ./CH\nDễ/A thấy/V rằng/C RMQ_A(i/Np ,/CH j)=LCA_C(i/Np ,/CH j)/Np ./CH\nBây_giờ/P việc/N cần/V làm/V chỉ/R còn/R là/V tính/V C(A)/Np trong/E thời_gian/N tuyến_tính/Np ./CH\nChúng_ta/P sẽ/R sử_dụng/V một/M cái/Nc stack/Np ./CH\nBan_đầu/N stack/Np rỗng/A ./CH\nTa/P lần_lượt/R đẩy/V các/L phần_tử/N của/E A/Ni vào/E stack/Np ./CH\nTại/E bước/V thứ/N i/M ,/CH Ai/P sẽ/R được/V đẩy/V vào/E ngay/R cạnh/N phần_tử/N cuối_cùng/A không/R lớn/A hơn/A Ai/P trong/E stack/Np ,/CH các/L phần_tử/N lớn/A hơn/A Ai/P bị/V loại/N khỏi/V stack/Np ./CH\nPhần_tử/N trong/E stack/Np ở/E vị_trí/N của/E Ai/P trước_khi/Np chèn/V Ai/P vào/E sẽ/R là/V con/Nc trái/Nc của/E i/M ,/CH còn/R i/M sẽ/R là/V con/Nc phải/V của/E phần_tử/N trước/E nó/P trong/E stack/Np ./CH\nỞ/E mỗi/L bước/V thì/C phần_tử/N đầu_tiên/A trong/E stack/Np sẽ/R là/V gốc/N của/E cây/N Cartesian/Np ./CH\nVí_dụ/C đối_với/E cây/N ở/E trên/E :/CH Bước_Stack_Sự/Np hình_thành/V cây/N 0/M 0/M 0/M là/V nút/N duy_nhất/A trong/E cây/N 1/M 0/M 1/M 1/M được/V đẩy/V vào/E cuối/N stack/Np ./CH\nGiờ/N 1/M là/V con/Nc phải/V của/E 0/M 2/M 0/M 2/M A2/Np lt;/Np A1)/Np ./CH\nLúc_này/Np 2/M là/V con/Nc phải/V của/E 0/M và/Cc con/Nc trái/Nc của/E 2/M là/V 1/M 3/M 3/M A3/Np hiện/N đang/R là/V phần_tử/N nhỏ/A nhất/A cho_nên/C mọi/L phần_tử/N của/E stack/Np bị/V lấy/V ra/V ra/V và/Cc 3/M trở_thành/V gốc/N cây/N ./CH\nCon/Nc trái/Nc của/E 3/M là/V 0/M 4/M 3/M 4/M 4/M được/V thêm/V vào/E cạnh/N 3/M và/Cc con/Nc phải/V của/E 3/M là/V 4/M 5/M 3/M 4/M 5/M 5/M được/V thêm/V vào/E cạnh/N 4/M ,/CH con/Nc phải/V của/E 4/M là/V 5/M 6/M 3/M 4/M 5/M 6/M 6/M được/V thêm/V vào/E cạnh/N 5/M ,/CH con/Nc phải/V của/E 5/M là/V 6/M 7/M 3/M 4/M 5/M 6/M 7/M 7/M được/V thêm/V vào/E cạnh/N 6/M ,/CH con/Nc phải/V của/E 6/M là/V 7/M 8/M 3/M 8/M 8/M được/V thêm/V vào/E cạnh/N 3/M ,/CH các/L phần_tử/N lớn/A hơn/A bị/V loại_bỏ/V ./CH\n8/M giờ/N là/V con/Nc phải/V của/E 3/M và/Cc con/Nc trái/Nc của/E 8/M là/V 4/M 9/M 3/M 8/M 9/M 9/M được/V thêm/V vào/E cạnh/N 8/M ,/CH con/Nc phải/V của/E 8/M là/V 9/M Vì/E mỗi/L phần_tử/N của/E A/Ni đều/R chỉ/R đẩy/V vào/E và/Cc lấy/V ra/V 1/M lần/N nên/C độ/N phức_tạp/A thuật_toán/N là/V O(N)/Np ./CH\nvoid/Np computeTree/Np (/CH int/Np A_MAXN/Np ,/CH int/Np N/Ny ,/CH int/Np T_MAXN/Np )/CH int/Np st/Np MAXN/Np ,/CH i/M ,/CH k/N ,/CH top/N =/CH -/CH 1/M ;/CH //CH Bắt_đầu/V với/E stack/Np rỗng/A //CH Ở/E bước/V thứ/N i/M ta/P đẩy/V i/M và/Cc stack/Np for/Np (/CH i/M =/CH 0/M ;/CH i/M lt;/Np N/Ny ;/CH i/M ++/Np )/CH //CH vị_trí/N của/E phần_tử/N đầu_tiên/A nhỏ/A hơn/A hoặc/Cc bằng/E Ai/P trong/E stack/Np k/N =/CH top/N ;/CH while/Np (/CH k/N gt;=/Np 0/M amp;amp;/Np A/Ni st/Np k/N gt;/Np A/Ni i/M )/CH k/N --/Np ;/CH //CH Chỉnh_sửa/V cây/N theo/V mô_tả/V ở/E trên/E if/Np (/CH k/N !/CH =/CH -/CH 1/M )/CH T/Nu i/M =/CH st/Np k/N ;/CH if/Np (/CH k/N lt;/Np top/N )/CH T/Nu st/Np k/N +/CH 1/M =/CH i/M ;/CH //CH Đẩy/V i/M vào/E stack/Np rồi/C xóa/V các/L phần_tử/N lớn/A hơn/A Ai/P st/Np ++/Np k/N =/CH i/M ;/CH top/N =/CH k/N ;/CH //CH Phần_tử/N đầu_tiên/A trong/E stack/Np là/V gốc/N cây/N nên/C nó/P không/R có/V cha/N T/Nu st/Np 0/M =/CH -/CH 1/M ;/CH Thuật_toán/N lt;/Np O(N)/Np ,/CH O(1)/Np gt;/Np cho/E bài_toán/N RMQ/Np thu_hẹp/V Bài_toán/N RMQ/Np phát_sinh/V khi/N giải/N bài_toán/N LCA/Np chỉ/R là/V trường_hợp/N đặc_biệt/A của/E bài_toán/N RMQ/Np tổng_quát/Np ,/CH do/E ta/P có_điều/X kiện/V Ai-Ai-1=1/Np với/E mọi/L i\\in1/Np ,/CH N-1/Np (lý/Np do/E là/V 2/M phần_tử/N liên_tiếp/A có/V quan_hệ/N cha/N con/Nc với/E nhau)/Np ./CH\nTa/P gọi/V bài_toán/N RMQ/Np này/P là/V bài_toán/N RMQ/Np thu_hẹp/V ./CH\nTrong/E 1/M số/N tài_liệu/N còn/R được/V gọi_là/V bài_toán/N \\pm/Np 1/M RMQ/Np ./CH\nTrong/E mục/N này/P ,/CH ta/P sẽ/R nghiên_cứu/V một/M thuật_toán/N có/V độ/N phức_tạp/A tốt/A hơn/A cho/E bài_toán/N RMQ/Np thu_hẹp/V ./CH\nHãy/R biến_đổi/V A/Ni thành/V một/M dãy/Nc nhị_phân/Np có/V N-1/Np phần_tử/N ,/CH với/E Bi=Ai-Ai-1/Np ./CH\nNhư_vậy/X Ai=A0+B1+/Np ./CH ./CH +Bi/Np và/Cc Bi/Np chỉ/R nhận/V giá_trị/N 1/M hoặc/Cc -1/Np ./CH\nChúng_ta/P chia/V A/Ni thành/V các/L block/V kích_thước/N l=log(N)/Np ./CH\nGọi_Mi/Np là/V giá_trị/N nhỏ/A nhất/A trong/E block/V thứ/N i/M và/Cc Di/Np là/V vị_trí/N của/E giá_trị/N nhỏ/A nhất/A này/P trong/E A/Ni ./CH\nCả_M/Np và/Cc D/Ny đều/R có/V N/Ny phần_tử/N ./CH\nTính_Sparse_Table/Np cho/E M/Nu ,/CH tốn/V O(N/llog(N/Np về/E bộ_nhớ/Np và/Cc thời_gian/N ./CH\nDùng/V sparse/Np table/Np cho/E mảng/N M/Nu ,/CH ta/P tính/V được_giá/Np trị/V nhỏ/A nhất/A của/E 1/M vài/L block/V trong/E O(1)/Np ./CH\nNhưng/C ta/P vẫn/R cần/V tính/V RMQ/Np giữa/N 2/M vị_trí/N bất_kì/R trong/E cùng/A một/M block/V ./CH\nĐể/E làm/V được/V điều/N này/P ,/CH nhận_thấy/Np B/Ni là/V một/M dãy/Nc nhị_phân/Np ,/CH mà/C mỗi/L block/V có/V l/Ny phần_tử/N ./CH\nVì/E số_lượng/N dãy/Nc nhị_phân_độ/Np dài/A l/Ny là/V 2l=\\sqrt/Np N/Ny là/V một_số/L khá/R nhỏ/A nên/C chúng_ta/P có_thể/R tính/V được/V mảng/N P\\sqrt(N)ll/Np ,/CH với/E P(b/Np ,/CH i/M ,/CH j)/Np là/V giá_trị/N nhỏ/A nhất/A trong/E các/L bit/Np từ/E i/M đến/E j/Np của/E dãy/Nc nhị_phân/Np b/Ni ./CH\nDễ_dàng/A khởi/V tạo/V P/Ny bằng/E quy_hoạch_động/Np trong/E cả/P thời_gian/N và/Cc bộ_nhớ/Np O(\\sqrt_Nl2)/Np ./CH\nChú_ý/V rằng/C ,/CH ta/P cũng/R cần/V biết/V giá_trị/N b/Ni trong/E O(1)/Np với/E mỗi/L block/V của/E mảng/N A/Ni ./CH\nDo_đó/C ,/CH ta/P cần/V khởi/V tạo/V mảng/N T/Nu với/E N/Ny phần_tử/N ,/CH mỗi/L phần_tử/N cho_biết/V giá_trị/N b/Ni của/E block/V tương_ứng/V ./CH\nKết_hợp/V mảng/N T/Nu ,/CH P/Ny với/E Sparse/Np table/Np cho/E mảng/N M/Nu ,/CH ta/P có_thể/R trả_lời/V truy_vấn/Np RMQ_A(i/Np ,/CH j)/Np trong/E O(1)/Np ./CH\nTa/P có/V 2/M trường_hợp/N :/CH i/M và/Cc j/Np thuộc/V cùng/A block/V ./CH\nTa/P dùng/V mảng/N T/Nu để/E biết/V dãy/Nc nhị_phân/Np b/Ni ở/E block/V chứa/V i/M và/Cc j/Np ./CH\nTính/V u/N và/Cc v/Nu là/V vị_trí/N của/E i/M và/Cc j/Np trong/E block/V ./CH\nKết_quả/N chính/T là/V P(b/Np ,/CH u/N ,/CH v)/Np ./CH\ni/M và/Cc j/Np thuộc/V 2/M block/V khác_nhau/Np :/CH kết_quả/N sẽ/R là/V giá_trị/N nhỏ/A nhất/A của/E 3/M giá_trị/N :/CH Giá_trị/N nhỏ/A nhất/A của/E các/L phần_tử/N trong/E block/V chứa/V i/M và/Cc nằm/V bên/N phải/V i/M :/CH Dùng/V mảng/N T/Nu để/E biết/V được_giá/Np trị/V của/E dãy/Nc nhị_phân/Np của/E block/V chứa/V i/M là/V b/Ni ./CH\nTính/V chỉ_số/N của/E i/M trong/E block/V chứa/V i/M là/V u/N ./CH\nKết_quả/N chính/T là/V P(b/Np ,/CH i/M ,/CH l)/Np ./CH\nGiá_trị/N nhỏ/A nhất/A của/E các/L phần_tử/N trong/E block/V chứa/V j/Np và/Cc nằm/V bên/N trái/Nc j/Np :/CH làm/V tương_tự/A trường_hợp/N trên/E Giá_trị/N nhỏ/A nhất/A của/E các/L phần_tử/N thuộc/V các/L block/V nằm/V giữa/N block/V chứa/V i/M và/Cc block/V chứa/V j/Np ./CH\nDùng_Sparse/Np table/Np cho/E M/Nu ,/CH ta/P dễ_dàng/A tính/V được_giá/Np trị/V này/P trong/E O(1)/Np ./CH\nMột_số/L bài/N để/E luyện_tập/V CF/Np 278/Np Div/Np 1/M -/CH B_Bayan/Np 2015/M Contest_Warm_Up/Np -/CH D_Hello/Np 2015/M (Div/Np ./CH 1)/Np -/CH A_LCA_QTREE2_HBTLCA_UPGRANET_VOTREE_SRM/Np 310/Np -/CH Floating_Median_Lorenzo_Von_Matterhorn/Np http/Np :/CH //CH ./CH pku/Np ./CH edu/Np ./CH cn/JudgeOnline/Np ?/CH id=1986/Np http/Np :/CH //CH ./CH pku/Np ./CH edu/Np ./CH cn/JudgeOnline/Np ?/CH id=2374/Np http/Np :/CH //CH ./CH uva/Np ./CH es/nuevoportal/data/Np ./CH php/Np ?/CH p=2045/Np http/Np :/CH //CH ./CH pku/Np ./CH edu/Np ./CH cn/JudgeOnline/Np ?/CH id=2763/Np http/Np :/CH //CH ./CH uva/Np ./CH es/p/v109/Np ./CH html/Np http/Np :/CH //CH ./CH sgu/Np ./CH ru/Np ./CH php/Np ?/CH contest=0amp;problem=155/Np\n", "title": "Bài toán RMQ và bài toán LCA\n", "link": "http://vnoi.info/wiki/translate/topcoder/Range-Minimum-Query-and-Lowest-Common-Ancestor\n"}