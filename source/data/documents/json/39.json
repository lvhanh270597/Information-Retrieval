{"content": "Bài viết gốc : Seam_Carving_Algorithm - K .\nLykov_Blog Giới_thiệu Seam carving là một thuật_toán dùng để thay_đổi kích_thước hình_ảnh , nó được giới_thiệu trong bài báo_cáo khoa_học của S .\nAvidan amp; A .\nShamir .\nTrong bài báo , việc thay_đổi kích_thước ảnh được thực_hiện bằng cách loại_bỏ đi các điểm_ảnh ít quan_trọng và giữ_lại các điểm_ảnh quan_trọng .\nBức ảnh dưới_đây là minh_họa điều này (ảnh bên_trên là ảnh gốc với kích_thước 332x480 và ảnh bên_dưới là ảnh sau khi áp_dụng thuật_toán seam carving đẻ thu_nhỏ còn_lại kích_thước là 272x400) .\nThuật_toán này khá phổ_biến nên có_thể dễ_dàng tìm_thấy rất nhiều bài viết nói về nó .\nTuy_nhiên hầu_hết đa_số các tác_giả đã không đọc_bài báo_cáo ban_đầu và chỉ cung_cấp cách cài_đặt thuật_toán khá cơ_bản .\nTrong bài viết này tôi sẽ mô_tả thuật_toán đầy_đủ các chi_tiết như trong bài viết của Avidan amp; Shamir , dưới góc nhìn của một lập_trình_viên .\nỞ đây ta sẽ sử_dụng matlab để cài_đặt thuật_toán .\nPhần chứng_minh cụ_thể các bạn xem ở phần tham_khảo .\nNăng_lượng (Energy) Để đơn_giản , bài viết này chỉ tập_trung nói về việc_làm giảm kích_thước hình_ảnh .\nTuy_nhiên việc_làm tăng kích_thước hình_ảnh cũng có_thể làm tương_tự , và sẽ được mô_tả sơ_qua ở phần sau .\nÝ_tưởng chính của thuật_toán là việc loại_bỏ các nội_dung có ít ý_nghĩa đối_với người sử_dụng (chứa ít thông tin) .\nTa gọi thông_tin này là Năng_lượng (Energy) .\nVì_vậy ta cần_định_nghĩa hàm năng_lượng để tính_năng lượng điểm_ảnh từ các điểm_ảnh của ảnh gốc .\nVí_dụ , ở đây ta có_thể tính_năng lượng của ảnh thông_qua đạo_hàm của từng điểm_ảnh theo các hướng : e_1=\\left \\frac\\delta I\\delta x \\right + \\left \\frac\\delta I\\delta y \\right .\nNếu_như ảnh có 3 kênh màu thì ta lấy tổng_giá trị năng_lượng của 3 kênh này lại với_nhau .\nĐoạn code Matlab dưới_đây sẽ mô_tả quá_trình tính .\nHàm imfilter được áp_dụng cho các điểm_ảnh được đánh_dấu , do_đó kết_quả là dI(i , j)/dx = I(i+1)-I(i-1)/dx với dx = 1 .\nTương_tự cho dI(i , j)/dy : dI(i , j)/dy = I(j+1)-I(j-1)/dy với dy = 1 .\nfunction res = energyRGB ( I ) % Input : Ảnh màu (3 kênh màu) % Output : Một mảng 2 chiều thể_hiện năng_lượng của các điểm trong ảnh .\n% e = dI/dx + dI/dy % Vì ảnh có 3 kênh màu nên ta trả ra tổng_năng lượng theo 3 kênh màu res = energyGrey ( I ( : , : , 1 )) + energyGrey ( I ( : , : , 2 )) + energyGrey ( I ( : , : , 3 )); function res = energyGrey ( I ) % Input : Ảnh đen trắng % Output : Một mảng 2 chiều thể_hiện năng_lượng của các điểm trong ảnh .\n% e = dI/dx + dI/dy res = abs ( imfilter ( I , - 1 , 0 , 1 , replicate )) + abs ( imfilter ( I , - 1 ; 0 ; 1 , replicate )); end Năng_lượng thu được : Seam_Nếu chúng_ta xóa đi các điểm_ảnh có nặng lượng thấp nhất ở các_vị trí ngẫu_nhiên , ta sẽ ra một hình_ảnh méo_mó .\nNếu chúng_ta xóa theo cột hoặc hàng với năng_lượng tối_thiểu , ta sẽ nhận được một bức ảnh hoàn_chỉnh được thu_nhỏ kích_thước lại .\nỞ đây cột j nghĩa_là tập_hợp (i , j) với j cố_định và một hàng i nghĩa_là tập_hợp (i , j) với i cố_định .\nThuật_toán Seam_Carving xóa các hàng và cột tổng_quát (được gọi_là đường seam) .\nCụ_thể hơn , gọi I là một bức ảnh có kích_thước n m , một đường seam dọc là (sx)i = (i , x(i))s . t . \\forall i , x(i) - x(i - 1) \\leq 1 trong đó x1 . . n \\to 1 . . m .\nNói một_cách dễ_hiểu hơn , một đường seam dọc ( vertical seam ) là một đường_đi từ biên trên của bức ảnh xuống biên dưới của bức ảnh với độ_dài đường_đi bằng chiều_cao của bức ảnh , và với mỗi phần vị_trí (i , j) của đường seam , ta có_thể đi tiếp đến các phần_tử (i + 1 , j - 1) , (i + 1 , j) , (i + 1 , j + 1) .\nTương_tự ta cũng có_thể định_nghĩa cho đường seam ngang ( horizontal seam ) .\nVí_dụ về các đường màu đen là các đường seam trong hình dưới_đây .\nChúng_ta sẽ tìm_kiếm một đường seam sao_cho có tổng_giá trị năng_lượng là nhỏ nhất (theo chiều chúng_ta chọn) : s= \\min \\limits_s \\sum\\limits_i=1n e(I(s_i)) .\nCách để tìm được kết_quả tối_ưu cho bài toàn là sử_dụng phương_pháp quy_hoạch_động .\nTìm đường seam tối_ưu từ biên trên của ảnh đến mỗi điểm_ảnh (i , j) .\nGọi_Mi , j là giá_trị năng_lượng nhỏ nhất đi từ biên trên của ảnh đến điểm_ảnh (i , j) .\nM1 , j = e(1 , j) với e(i , j) là năng_lượng điểm_ảnh tại (i , j) .\nMi , j = min(Mi - 1 , j - 1 , Mi - 1 , j , Mi - 1 , j + 1) + e(i , j) .\nỞ biên dưới của ảnh , ta tìm điểm đường seam tối_ưu (tổng giá_trị năng_lượng thấp nhất thông_qua bảng phương_án M) và đi ngược về để tìm đường_đi tối_ưu .\nLưu_ý : trong đoạn code dưới_đây trả về một ma_trận n m chỉ gồm 0 và 1 với các điểm_ảnh trên đường_đi seam sẽ có_giá trị là 0 và ngược_lại .\nĐể tìm đường seam ngang , ta chỉ_cần chuyển_vị ma_trận năng_lượng lại .\nfunction optSeamMask , seamEnergy = findOptSeam ( energy ) % Input : mảng 2 chiều là năng_lượng của các điểm_ảnh % Output : Đường seam dọc tối_ưu amp; năng_lượng % Mảng optSeamMask gồm 0/1 , với 0 thể_hiện điểm đó thuộc đường seam % Để tìm đường seam ngang tối_ưu , cho Input là ma_trận chuyển_vị % Tính mảng quy_hoạch_động M cho các đường seam dọc M = padarray ( energy , 0 1 , realmax ( double )); % M = mảng energy thêm 2 cột có_giá trị cực_đại ở đầu và cuối để tránh xử_lý_biên sz = size ( M ); for i = 2 : sz ( 1 ) for j = 2 : ( sz ( 2 ) - 1 ) neighbors = M ( i - 1 , j - 1 ) M ( i - 1 , j ) M ( i - 1 , j + 1 ); M ( i , j ) = M ( i , j ) + min ( neighbors ); end end % Tìm phần_tử nhỏ nhất hàng cuối val , indJ = min ( M ( sz ( 1 ) , : )); seamEnergy = val ; optSeamMask = zeros ( size ( energy ) , uint8 ); % Đi_ngược_lại và truy vết for i = sz ( 1 ) : - 1 : 2 % optSeam(i) = indJ - 1; optSeamMask ( i , indJ - 1 ) = 1 ; % -1 vì lúc đầu ta thêm một cột 0 vào bên trái neighbors = M ( i - 1 , indJ - 1 ) M ( i - 1 , indJ ) M ( i - 1 , indJ + 1 ); val , indIncr = min ( neighbors ); seamEnergy = seamEnergy + val ; indJ = indJ + ( indIncr - 2 ); % (x - 2) : 1 , 2-gt;-1 , 1 end optSeamMask ( 1 , indJ - 1 ) = 1 ; % -1 vì lúc đầu ta thêm một cột 0 vào bên trái optSeamMask = ~ optSeamMask ; end Tìm phương_án tối_ưu để xóa đường seam Bây_giờ ta có_thể tính_toán ra được đường seam và sử_dụng đoạn code dưới_đây , ta có_thể loại_bỏ đường seam ra khỏi bức ảnh .\nfunction imageReduced = reduceImageByMaskVertical ( image , seamMask ) % Input : Ảnh amp; mask của đường seam % Output : Ảnh sau khi xóa đường seam dọc imageReduced = zeros ( size ( image , 1 ) , size ( image , 2 ) - 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) imageReduced ( i , : , 1 ) = image ( i , seamMask ( i , : ) , 1 ); imageReduced ( i , : , 2 ) = image ( i , seamMask ( i , : ) , 2 ); imageReduced ( i , : , 3 ) = image ( i , seamMask ( i , : ) , 3 ); end end function imageReduced = reduceImageByMaskHorizontal ( image , seamMask ) % Input : Ảnh amp; mask của đường seam % Output : Ảnh sau khi xóa đường seam ngang imageReduced = zeros ( size ( image , 1 ) - 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) imageReduced ( : , j , 1 ) = image ( seamMask ( : , j ) , j , 1 ); imageReduced ( : , j , 2 ) = image ( seamMask ( : , j ) , j , 2 ); imageReduced ( : , j , 3 ) = image ( seamMask ( : , j ) , j , 3 ); end end Đây là một thuật_toán hiệu_quả để làm giám kích_thước ảnh theo một_chiều - chỉ_cần việc tìm và xóa các đường seam nhiều lần như bạn cần .\nNhưng nếu làm giảm kích_thước theo cả hai chiều , ta cần phải làm như_thế nào ?\nLàm_sao để quyết_định rằng ở mỗi lần lắp đưa_ra quyết_định là xóa theo dòng hay cột sẽ tốt hơn ?\nVấn_đề này một_lần nữa được giải_quyết bằng quy_hoạch_động .\nTa gọi T(i , j) là giá_trị năng_lượng thấp nhất khi ta loại_bỏ i đường seam theo chiều_dọc và j đường seam theo chiều_ngang .\nCụ_thể : T(i , j) = min(T(i , j-1) + E(seamVertical) , T(i-1 , j) + E(seamHorizontal)) .\nTrong đó E(seamVertical) là giá_trị nhỏ nhất (tối ưu) đường seam dọc loại_bỏ đi , E(seamHorizontal) là giá_trị nhỏ nhất (tối ưu) đường seam ngang loại_bỏ đi .\nTa sử_dụng thêm một mảng transBitMask(i , j) lưu truy vết đường_đi cho bản phương_án T(i , j) .\ntransBitMask(i , j) = 1 bỏ_đi đường seam dọc , transBitMask(i , j) = 0 bỏ_đi đường seam ngang .\nNhìn một đoạn code giả dưới_đây để có_thể dễ hình_dung .\n1) T(0 , 0) = 0; 2) Khởi tạo T : for all j T(0 , j) = T(0 , j - 1) + E(seamVertical); for all i T(i , 0) = T(j - 1 , 0) + E(seamHorizontal); 3) Initialize borders of TransBitMask (TBM) : for all j TBM(0 , j) = 1; for all i TBM(0 , i) = 0; 4) Tính_T và TBM : for i = 2 to r imageWithoutRow = image; for j = 2 to c energy = computeEnergy(imageWithoutRow); horizontalSeamEnergy = findHorizontalSeamEnergy(energy); verticalSeamEnergy = findVerticalSeamEnergy(energy); tVertical = T(i - 1 , j) + verticalSeamEnergy; tHorizontal = T(i , j - 1) _ horizontalSeamEnergy; if (tVertical lt; tHorizontal) T(i , j) = tVertical; TBM(i , j) = 1 else T(i , j) = tHorizontal; TBM(i , j) = 0 // Xóa đường seam dọc imageWithoutRow = removeVerticalSeam(energy); energy = computeEnergy(image); image = removeHorizontalSeam(energy); 5) Truy vết theo T và TBM .\nĐoạn code_bằng matlab .\nChú_ý ở pseduocode dùng zerobased index , do matlab sử_dụng onebased index nên cần phải đẩy index lên 1 đơn_vị .\nfunction T , transBitMask = findTransportMatrix ( sizeReduction , image ) % Input : Kích_thước cần giảm amp; ảnh gốc % Output : T , TBM định_nghĩa ở trên T = zeros ( sizeReduction ( 1 ) + 1 , sizeReduction ( 2 ) + 1 , double ); transBitMask = ones ( size ( T )) - 1 ; % Khởi tạo T(i , 1) , T(1 , i) , TBM(i , 1) , TBM(1 , i) imageNoRow = image ; for i = 2 : size ( T , 1 ) % Tính_năng lượng energy = energyRGB ( imageNoRow ); % Tìm đường seam ngang tối_ưu optSeamMask , seamEnergyRow = findOptSeam ( energy ); % Xóa đường seam imageNoRow = reduceImageByMask ( imageNoRow , optSeamMask , 0 ); % Tính_T và TBM_T ( i , 1 ) = T ( i - 1 , 1 ) + seamEnergyRow ; transBitMask ( i , 1 ) = 0 ; end ; imageNoColumn = image ; for j = 2 : size ( T , 2 ) % Tính_năng lượng energy = energyRGB ( imageNoColumn ); % Tìm đường seam dọc optSeamMask , seamEnergyColumn = findOptSeam ( energy ); % Xóa đường seam dọc imageNoColumn = reduceImageByMask ( imageNoColumn , optSeamMask , 1 ); % Tính_TBM amp; T transBitMask ( 1 , j ) = 1 ; T ( 1 , j ) = T ( 1 , j - 1 ) + seamEnergyColumn ; end ; % Xóa 1 hàng và 1 cột energy = energyRGB ( image ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 0 ); energy = energyRGB ( image ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 1 ); % fill in internal part for i = 2 : size ( T , 1 ) imageWithoutRow = image ; % Ta sẽ xóa 1 hàng của imageWithoutRow for j = 2 : size ( T , 2 ) energy = energyRGB ( imageWithoutRow ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageWithoutRow , optSeamMaskRow , 0 ); optSeamMaskColumn , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageWithoutRow , optSeamMaskColumn , 1 ); neighbors = ( T ( i - 1 , j ) + seamEnergyRow ) ( T ( i , j - 1 ) + seamEnergyColumn ); val , ind = min ( neighbors ); T ( i , j ) = val ; transBitMask ( i , j ) = ind - 1 ; % Ta xóa lần_lượt từng cột imageWithoutRow = imageNoColumn ; end ; energy = energyRGB ( image ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); % move from top to bottom image = reduceImageByMask ( image , optSeamMaskRow , 0 ); end ; end Phóng to hình_ảnh Để phóng to hình_ảnh , thay_vì ta loại_bỏ đường seam ra khỏi ảnh , thì ta thêm một đường seam mới vào với giá_trị trung_bình của các điểm_ảnh lận cận .\nfunction imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ) % Input : Ảnh và đường seam % Output : Ảnh đã được phóng to thêm 1 cột avg = ( image , i , j , k ) ( image ( i , j - 1 , k ) + image ( i , j + 1 , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) , size ( image , 2 ) + 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) j = find ( seamMask ( i , : ) ~= 1 ); imageEnlarged ( i , : , 1 ) = image ( i , 1 : j , 1 ) , avg ( image , i , j , 1 ) , image ( i , j + 1 : end , 1 ); imageEnlarged ( i , : , 2 ) = image ( i , 1 : j , 2 ) , avg ( image , i , j , 2 ) , image ( i , j + 1 : end , 2 ); imageEnlarged ( i , : , 3 ) = image ( i , 1 : j , 3 ) , avg ( image , i , j , 3 ) , image ( i , j + 1 : end , 3 ); end ; end function imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ) % Input : Ảnh và đường seam % Output : Ảnh đã được phóng to thêm 1 hàng avg = ( image , i , j , k ) ( image ( i - 1 , j , k ) + image ( i + 1 , j , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) + 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) i = find ( seamMask ( : , j ) ~= 1 ); imageEnlarged ( : , j , 1 ) = image ( 1 : i , j , 1 ); avg ( image , i , j , 1 ); image ( i + 1 : end , j , 1 ); imageEnlarged ( : , j , 2 ) = image ( 1 : i , j , 2 ); avg ( image , i , j , 2 ); image ( i + 1 : end , j , 2 ); imageEnlarged ( : , j , 3 ) = image ( 1 : i , j , 3 ); avg ( image , i , j , 3 ); image ( i + 1 : end , j , 3 ); end ; end Source code Dưới_đây là toàn_bộ code của tác_giả (giữ nguyên lại comment gốc bằng tiếng Anh) % (C) Copyright_Kirill_Lykov 2013 .\n% % Distributed under the FreeBSD_Software_License (See accompanying file license . txt) function image = seamCarving ( newSize , image ) % apply seam carving to the_image % following paper by Avidan and Shamir 07 sizeReductionX = size ( image , 1 ) - newSize ( 1 ); sizeReductionY = size ( image , 2 ) - newSize ( 2 ); mmax = ( left , right ) max ( left right ); image = seamCarvingReduce ( mmax ( 0 , sizeReductionX ) , mmax ( 0 , sizeReductionY ) , image ); image = seamCarvingEnlarge ( mmax ( 0 , - sizeReductionX ) , mmax ( 0 , - sizeReductionY ) , image ); end function image = seamCarvingReduce ( sizeReduction , image ) if ( sizeReduction == 0 ) return ; end ; T , transBitMask = findTransportMatrix ( sizeReduction , image ); image = addOrDeleteSeams ( transBitMask , sizeReduction , image , reduceImageByMask ); end % TODO_Bug : enlarge gives artifacts althout I chouse different seams as described % in 4 . 3 in the_paper function image = seamCarvingEnlarge ( sizeEnlarge , image ) if ( sizeEnlarge == 0 ) return ; end ; T , transBitMask = findTransportMatrix ( sizeEnlarge , image ); image = addOrDeleteSeams ( transBitMask , sizeEnlarge , image , enlargeImageByMask ); end function T , transBitMask = findTransportMatrix ( sizeReduction , image ) % find optimal order of removing raws and columns T = zeros ( sizeReduction ( 1 ) + 1 , sizeReduction ( 2 ) + 1 , double ); transBitMask = ones ( size ( T )) - 1 ; % fill in borders imageNoRow = image ; for i = 2 : size ( T , 1 ) energy = energyRGB ( imageNoRow ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageNoRow , optSeamMask , 0 ); transBitMask ( i , 1 ) = 0 ; T ( i , 1 ) = T ( i - 1 , 1 ) + seamEnergyRow ; end ; imageNoColumn = image ; for j = 2 : size ( T , 2 ) energy = energyRGB ( imageNoColumn ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageNoColumn , optSeamMask , 1 ); transBitMask ( 1 , j ) = 1 ; T ( 1 , j ) = T ( 1 , j - 1 ) + seamEnergyColumn ; end ; % on the borders , just remove one column and one row before proceeding energy = energyRGB ( image ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 0 ); energy = energyRGB ( image ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 1 ); % fill in internal part for i = 2 : size ( T , 1 ) imageWithoutRow = image ; % copy for deleting columns for j = 2 : size ( T , 2 ) energy = energyRGB ( imageWithoutRow ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageWithoutRow , optSeamMaskRow , 0 ); optSeamMaskColumn , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageWithoutRow , optSeamMaskColumn , 1 ); neighbors = ( T ( i - 1 , j ) + seamEnergyRow ) ( T ( i , j - 1 ) + seamEnergyColumn ); val , ind = min ( neighbors ); T ( i , j ) = val ; transBitMask ( i , j ) = ind - 1 ; % move from left to right imageWithoutRow = imageNoColumn ; end ; energy = energyRGB ( image ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); % move from top to bottom image = reduceImageByMask ( image , optSeamMaskRow , 0 ); end ; end function image = addOrDeleteSeams ( transBitMask , sizeReduction , image , operation ) % delete seams following optimal way i = size ( transBitMask , 1 ); j = size ( transBitMask , 2 ); for it = 1 : ( sizeReduction ( 1 ) + sizeReduction ( 2 )) energy = energyRGB ( image ); if ( transBitMask ( i , j ) == 0 ) optSeamMask , seamEnergyRaw = findOptSeam ( energy ); image = operation ( image , optSeamMask , 0 ); i = i - 1 ; else optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = operation ( image , optSeamMask , 1 ); j = j - 1 ; end ; end ; end function optSeamMask , seamEnergy = findOptSeam ( energy ) % following paper by Avidan and Shamir 07 % finds optimal seam % returns mask with 0 mean a pixel is in the_seam % find M for_vertical seams % for_vertical - use I_M = padarray ( energy , 0 1 , realmax ( double )); % to avoid handling border elements sz = size ( M ); for i = 2 : sz ( 1 ) for j = 2 : ( sz ( 2 ) - 1 ) neighbors = M ( i - 1 , j - 1 ) M ( i - 1 , j ) M ( i - 1 , j + 1 ); M ( i , j ) = M ( i , j ) + min ( neighbors ); end end % find the min element in the last raw val , indJ = min ( M ( sz ( 1 ) , : )); seamEnergy = val ; %optSeam = zeros(sz(1) , 1 , int32); optSeamMask = zeros ( size ( energy ) , uint8 ); %indJ = indJ - 1; % because of padding on 1 element from left %go backward and save (i , j) for i = sz ( 1 ) : - 1 : 2 %optSeam(i) = indJ - 1; optSeamMask ( i , indJ - 1 ) = 1 ; % -1 because of padding on 1 element from left neighbors = M ( i - 1 , indJ - 1 ) M ( i - 1 , indJ ) M ( i - 1 , indJ + 1 ); val , indIncr = min ( neighbors ); seamEnergy = seamEnergy + val ; indJ = indJ + ( indIncr - 2 ); % (x - 2) : 1 , 2-gt;-1 , 1 end %optSeam(1) = indJ; % to avoid if in loop becuase matlab is slow as hell optSeamMask ( 1 , indJ - 1 ) = 1 ; % -1 because of padding on 1 element from left optSeamMask = ~ optSeamMask ; end function imageReduced = reduceImageByMask ( image , seamMask , isVerical ) % removes pixels by input mask % removes vertical line if isVerical == 1 , otherwise horizontal if ( isVerical ) imageReduced = reduceImageByMaskVertical ( image , seamMask ); else imageReduced = reduceImageByMaskHorizontal ( image , seamMask ); end ; end % could not find a more elegant way to do it function imageReduced = reduceImageByMaskVertical ( image , seamMask ) imageReduced = zeros ( size ( image , 1 ) , size ( image , 2 ) - 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) imageReduced ( i , : , 1 ) = image ( i , seamMask ( i , : ) , 1 ); imageReduced ( i , : , 2 ) = image ( i , seamMask ( i , : ) , 2 ); imageReduced ( i , : , 3 ) = image ( i , seamMask ( i , : ) , 3 ); end end function imageReduced = reduceImageByMaskHorizontal ( image , seamMask ) imageReduced = zeros ( size ( image , 1 ) - 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) imageReduced ( : , j , 1 ) = image ( seamMask ( : , j ) , j , 1 ); imageReduced ( : , j , 2 ) = image ( seamMask ( : , j ) , j , 2 ); imageReduced ( : , j , 3 ) = image ( seamMask ( : , j ) , j , 3 ); end end function imageEnlarged = enlargeImageByMask ( image , seamMask , isVerical ) % removes pixels by input mask % removes vertical line if isVerical == 1 , otherwise horizontal if ( isVerical ) imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ); else imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ); end ; end function imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ) avg = ( image , i , j , k ) ( image ( i , j - 1 , k ) + image ( i , j + 1 , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) , size ( image , 2 ) + 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) j = find ( seamMask ( i , : ) ~= 1 ); imageEnlarged ( i , : , 1 ) = image ( i , 1 : j , 1 ) , avg ( image , i , j , 1 ) , image ( i , j + 1 : end , 1 ); imageEnlarged ( i , : , 2 ) = image ( i , 1 : j , 2 ) , avg ( image , i , j , 2 ) , image ( i , j + 1 : end , 2 ); imageEnlarged ( i , : , 3 ) = image ( i , 1 : j , 3 ) , avg ( image , i , j , 3 ) , image ( i , j + 1 : end , 3 ); end ; end function imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ) avg = ( image , i , j , k ) ( image ( i - 1 , j , k ) + image ( i + 1 , j , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) + 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) i = find ( seamMask ( : , j ) ~= 1 ); imageEnlarged ( : , j , 1 ) = image ( 1 : i , j , 1 ); avg ( image , i , j , 1 ); image ( i + 1 : end , j , 1 ); imageEnlarged ( : , j , 2 ) = image ( 1 : i , j , 2 ); avg ( image , i , j , 2 ); image ( i + 1 : end , j , 2 ); imageEnlarged ( : , j , 3 ) = image ( 1 : i , j , 3 ); avg ( image , i , j , 3 ); image ( i + 1 : end , j , 3 ); end ; end function res = energyRGB ( I ) % returns energy of all pixelels % e = dI/dx + dI/dy res = energyGrey ( I ( : , : , 1 )) + energyGrey ( I ( : , : , 2 )) + energyGrey ( I ( : , : , 3 )); end function res = energyGrey ( I ) % returns energy of all pixelels % e = dI/dx + dI/dy res = abs ( imfilter ( I , - 1 , 0 , 1 , replicate )) + abs ( imfilter ( I , - 1 ; 0 ; 1 , replicate )); end Tham_khảo Wikipedia_Seam_Carving for Content-Aware_Image_Scaling https : //jeremykun . com/2013/03/04/seam-carving-for-content-aware-image-scaling/ http : //kirilllykov . github . io/blog/2013/06/06/seam-carving-algorithm/\n", "tagged": "Bài/N viết/V gốc/N :/CH Seam_Carving_Algorithm/Np -/CH K/N ./CH\nLykov_Blog/Np Giới_thiệu/V Seam/Np carving/Np là/V một/M thuật_toán/N dùng/V để/E thay_đổi/V kích_thước/N hình_ảnh/N ,/CH nó/P được/V giới_thiệu/V trong/E bài/N báo_cáo/N khoa_học/N của/E S/Y ./CH\nAvidan/Np amp;/Np A/Ni ./CH\nShamir/Np ./CH\nTrong/E bài/N báo/N ,/CH việc/N thay_đổi/V kích_thước/N ảnh/N được/V thực_hiện/V bằng/E cách/N loại_bỏ/V đi/V các/L điểm_ảnh/Np ít/A quan_trọng/A và/Cc giữ_lại/Np các/L điểm_ảnh/Np quan_trọng/A ./CH\nBức/Nc ảnh/N dưới_đây/Np là/V minh_họa/V điều/N này/P (ảnh/Np bên_trên/Np là/V ảnh/N gốc/N với/E kích_thước/N 332x480/Np và/Cc ảnh/N bên_dưới/Np là/V ảnh/N sau/E khi/N áp_dụng/V thuật_toán/N seam/Np carving/Np đẻ/V thu_nhỏ/Np còn_lại/Np kích_thước/N là/V 272x400)/Np ./CH\nThuật_toán/N này/P khá/R phổ_biến/V nên/C có_thể/R dễ_dàng/A tìm_thấy/Np rất/R nhiều/A bài/N viết/V nói/V về/E nó/P ./CH\nTuy_nhiên/C hầu_hết/R đa_số/N các/L tác_giả/N đã/R không/R đọc_bài/Np báo_cáo/N ban_đầu/N và/Cc chỉ/R cung_cấp/V cách/N cài_đặt/V thuật_toán/N khá/R cơ_bản/A ./CH\nTrong/E bài/N viết/V này/P tôi/P sẽ/R mô_tả/V thuật_toán/N đầy_đủ/A các/L chi_tiết/N như/C trong/E bài/N viết/V của/E Avidan/Np amp;/Np Shamir/Np ,/CH dưới/E góc/N nhìn/V của/E một/M lập_trình_viên/Np ./CH\nỞ/E đây/P ta/P sẽ/R sử_dụng/V matlab/Np để/E cài_đặt/V thuật_toán/N ./CH\nPhần/N chứng_minh/V cụ_thể/A các/L bạn/N xem/V ở/E phần/N tham_khảo/V ./CH\nNăng_lượng/N (Energy)/Np Để/E đơn_giản/A ,/CH bài/N viết/V này/P chỉ/R tập_trung/V nói/V về/E việc_làm/N giảm/V kích_thước/N hình_ảnh/N ./CH\nTuy_nhiên/C việc_làm/N tăng/V kích_thước/N hình_ảnh/N cũng/R có_thể/R làm/V tương_tự/A ,/CH và/Cc sẽ/R được/V mô_tả/V sơ_qua/Np ở/E phần/N sau/E ./CH\nÝ_tưởng/N chính/T của/E thuật_toán/N là/V việc/N loại_bỏ/V các/L nội_dung/N có/V ít/A ý_nghĩa/N đối_với/E người/N sử_dụng/V (chứa/Np ít/A thông/V tin)/Np ./CH\nTa/P gọi/V thông_tin/N này/P là/V Năng_lượng/N (Energy)/Np ./CH\nVì_vậy/C ta/P cần_định_nghĩa/Np hàm/Np năng_lượng/N để/E tính_năng/N lượng/N điểm_ảnh/Np từ/E các/L điểm_ảnh/Np của/E ảnh/N gốc/N ./CH\nVí_dụ/C ,/CH ở/E đây/P ta/P có_thể/R tính_năng/N lượng/N của/E ảnh/N thông_qua/V đạo_hàm/Np của/E từng/R điểm_ảnh/Np theo/V các/L hướng/N :/CH e_1=\\left/Np \\frac\\delta/Np I\\delta/Np x/CH \\right/Np +/CH \\left/Np \\frac\\delta/Np I\\delta/Np y/N \\right/Np ./CH\nNếu_như/C ảnh/N có/V 3/M kênh/N màu/N thì/C ta/P lấy/V tổng_giá/Np trị/V năng_lượng/N của/E 3/M kênh/N này/P lại/R với_nhau/Np ./CH\nĐoạn/Nc code/Np Matlab/Np dưới_đây/Np sẽ/R mô_tả/V quá_trình/N tính/V ./CH\nHàm/Np imfilter/Np được/V áp_dụng/V cho/E các/L điểm_ảnh/Np được/V đánh_dấu/V ,/CH do_đó/C kết_quả/N là/V dI(i/Np ,/CH j)/Np =/CH I(i+1)-I(i-1)/Np với/E dx/Np =/CH 1/M ./CH\nTương_tự/A cho/E dI(i/Np ,/CH j)/Np :/CH dI(i/Np ,/CH j)/Np =/CH I(j+1)-I(j-1)/Np với/E dy/Np =/CH 1/M ./CH\nfunction/Np res/Np =/CH energyRGB/Np (/CH I/M )/CH %/CH Input/Np :/CH Ảnh/N màu/N (3/Np kênh/N màu)/Np %/CH Output/Np :/CH Một/M mảng/N 2/M chiều/N thể_hiện/V năng_lượng/N của/E các/L điểm/N trong/E ảnh/N ./CH\n%/CH e/Ni =/CH dI/Np +/CH dI/Np %/CH Vì/E ảnh/N có/V 3/M kênh/N màu/N nên/C ta/P trả/V ra/V tổng_năng/Np lượng/N theo/V 3/M kênh/N màu/N res/Np =/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 1/M ))/Np +/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 2/M ))/Np +/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 3/M ));/Np function/Np res/Np =/CH energyGrey/Np (/CH I/M )/CH %/CH Input/Np :/CH Ảnh/N đen/A trắng/A %/CH Output/Np :/CH Một/M mảng/N 2/M chiều/N thể_hiện/V năng_lượng/N của/E các/L điểm/N trong/E ảnh/N ./CH\n%/CH e/Ni =/CH dI/Np +/CH dI/Np res/Np =/CH abs/Np (/CH imfilter/Np (/CH I/M ,/CH -/CH 1/M ,/CH 0/M ,/CH 1/M ,/CH replicate/Np ))/Np +/CH abs/Np (/CH imfilter/Np (/CH I/M ,/CH -/CH 1/M ;/CH 0/M ;/CH 1/M ,/CH replicate/Np ));/Np end/Np Năng_lượng/N thu/V được/V :/CH Seam_Nếu/Np chúng_ta/P xóa/V đi/V các/L điểm_ảnh/Np có/V nặng/A lượng/N thấp/A nhất/A ở/E các_vị/Np trí/Np ngẫu_nhiên/A ,/CH ta/P sẽ/R ra/V một/M hình_ảnh/N méo_mó/A ./CH\nNếu/C chúng_ta/P xóa/V theo/V cột/N hoặc/Cc hàng/N với/E năng_lượng/N tối_thiểu/A ,/CH ta/P sẽ/R nhận/V được/V một/M bức/Nc ảnh/N hoàn_chỉnh/V được/V thu_nhỏ/Np kích_thước/N lại/R ./CH\nỞ/E đây/P cột/N j/Np nghĩa_là/V tập_hợp/N (i/Np ,/CH j)/Np với/E j/Np cố_định/A và/Cc một/M hàng/N i/M nghĩa_là/V tập_hợp/N (i/Np ,/CH j)/Np với/E i/M cố_định/A ./CH\nThuật_toán/N Seam_Carving/Np xóa/V các/L hàng/N và/Cc cột/N tổng_quát/Np (được/Np gọi_là/V đường/N seam)/Np ./CH\nCụ_thể/A hơn/A ,/CH gọi/V I/M là/V một/M bức/Nc ảnh/N có/V kích_thước/N n/Ny m/Nu ,/CH một/M đường/N seam/Np dọc/A là/V (sx)i/Np =/CH (i/Np ,/CH x(i))s/Np ./CH t/Nu ./CH \\forall/Np i/M ,/CH x(i)/Np -/CH x(i/Np -/CH 1)/Np \\leq/Np 1/M trong/E đó/P x1/Np ./CH ./CH n/Ny \\to/Np 1/M ./CH ./CH m/Nu ./CH\nNói/V một_cách/N dễ_hiểu/Np hơn/A ,/CH một/M đường/N seam/Np dọc/A (/CH vertical/Np seam/Np )/CH là/V một/M đường_đi/Np từ/E biên/N trên/E của/E bức/Nc ảnh/N xuống/V biên/N dưới/E của/E bức/Nc ảnh/N với/E độ_dài/Np đường_đi/Np bằng/E chiều_cao/N của/E bức/Nc ảnh/N ,/CH và/Cc với/E mỗi/L phần/N vị_trí/N (i/Np ,/CH j)/Np của/E đường/N seam/Np ,/CH ta/P có_thể/R đi/V tiếp/V đến/E các/L phần_tử/N (i/Np +/CH 1/M ,/CH j/Np -/CH 1)/Np ,/CH (i/Np +/CH 1/M ,/CH j)/Np ,/CH (i/Np +/CH 1/M ,/CH j/Np +/CH 1)/Np ./CH\nTương_tự/A ta/P cũng/R có_thể/R định_nghĩa/N cho/E đường/N seam/Np ngang/A (/CH horizontal/Np seam/Np )/CH ./CH\nVí_dụ/C về/E các/L đường/N màu/N đen/A là/V các/L đường/N seam/Np trong/E hình/N dưới_đây/Np ./CH\nChúng_ta/P sẽ/R tìm_kiếm/V một/M đường/N seam/Np sao_cho/Np có/V tổng_giá/Np trị/V năng_lượng/N là/V nhỏ/A nhất/A (theo/Np chiều/N chúng_ta/P chọn)/Np :/CH s=/Np \\min/Np \\limits_s/Np \\sum\\limits_i=1n/Np e(I(s_i))/Np ./CH\nCách/N để/E tìm/V được/V kết_quả/N tối_ưu/A cho/E bài/N toàn/R là/V sử_dụng/V phương_pháp/N quy_hoạch_động/Np ./CH\nTìm/V đường/N seam/Np tối_ưu/A từ/E biên/N trên/E của/E ảnh/N đến/E mỗi/L điểm_ảnh/Np (i/Np ,/CH j)/Np ./CH\nGọi_Mi/Np ,/CH j/Np là/V giá_trị/N năng_lượng/N nhỏ/A nhất/A đi/V từ/E biên/N trên/E của/E ảnh/N đến/E điểm_ảnh/Np (i/Np ,/CH j)/Np ./CH\nM1/Np ,/CH j/Np =/CH e(1/Np ,/CH j)/Np với/E e(i/Np ,/CH j)/Np là/V năng_lượng/N điểm_ảnh/Np tại/E (i/Np ,/CH j)/Np ./CH\nMi/Np ,/CH j/Np =/CH min(Mi/Np -/CH 1/M ,/CH j/Np -/CH 1/M ,/CH Mi/Np -/CH 1/M ,/CH j/Np ,/CH Mi/Np -/CH 1/M ,/CH j/Np +/CH 1)/Np +/CH e(i/Np ,/CH j)/Np ./CH\nỞ/E biên/N dưới/E của/E ảnh/N ,/CH ta/P tìm/V điểm/N đường/N seam/Np tối_ưu/A (tổng/Np giá_trị/N năng_lượng/N thấp/A nhất/A thông_qua/V bảng/N phương_án/N M)/Np và/Cc đi/V ngược/A về/E để/E tìm/V đường_đi/Np tối_ưu/A ./CH\nLưu_ý/V :/CH trong/E đoạn/Nc code/Np dưới_đây/Np trả/V về/E một/M ma_trận/N n/Ny m/Nu chỉ/R gồm/V 0/M và/Cc 1/M với/E các/L điểm_ảnh/Np trên/E đường_đi/Np seam/Np sẽ/R có_giá/Np trị/V là/V 0/M và/Cc ngược_lại/X ./CH\nĐể/E tìm/V đường/N seam/Np ngang/A ,/CH ta/P chỉ_cần/Np chuyển_vị/Np ma_trận/N năng_lượng/N lại/R ./CH\nfunction/Np optSeamMask/Np ,/CH seamEnergy/Np =/CH findOptSeam/Np (/CH energy/Np )/CH %/CH Input/Np :/CH mảng/N 2/M chiều/N là/V năng_lượng/N của/E các/L điểm_ảnh/Np %/CH Output/Np :/CH Đường/N seam/Np dọc/A tối_ưu/A amp;/Np năng_lượng/N %/CH Mảng/N optSeamMask/Np gồm/V 0/M ,/CH với/E 0/M thể_hiện/V điểm/N đó/P thuộc/V đường/N seam/Np %/CH Để/E tìm/V đường/N seam/Np ngang/A tối_ưu/A ,/CH cho/E Input/Np là/V ma_trận/N chuyển_vị/Np %/CH Tính/V mảng/N quy_hoạch_động/Np M/Nu cho/E các/L đường/N seam/Np dọc/A M/Nu =/CH padarray/Np (/CH energy/Np ,/CH 0/M 1/M ,/CH realmax/Np (/CH double/Np ));/Np %/CH M/Nu =/CH mảng/N energy/Np thêm/V 2/M cột/N có_giá/Np trị/V cực_đại/A ở/E đầu/N và/Cc cuối/N để/E tránh/V xử_lý_biên/Np sz/Np =/CH size/Nb (/CH M/Nu );/CH for/Np i/M =/CH 2/M :/CH sz/Np (/CH 1/M )/CH for/Np j/Np =/CH 2/M :/CH (/CH sz/Np (/CH 2/M )/CH -/CH 1/M )/CH neighbors/Np =/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np -/CH 1/M )/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np )/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np +/CH 1/M );/CH M/Nu (/CH i/M ,/CH j/Np )/CH =/CH M/Nu (/CH i/M ,/CH j/Np )/CH +/CH min/Np (/CH neighbors/Np );/CH end/Np end/Np %/CH Tìm/V phần_tử/N nhỏ/A nhất/A hàng/N cuối/N val/Np ,/CH indJ/Np =/CH min/Np (/CH M/Nu (/CH sz/Np (/CH 1/M )/CH ,/CH :/CH ));/Np seamEnergy/Np =/CH val/Np ;/CH optSeamMask/Np =/CH zeros/Np (/CH size/Nb (/CH energy/Np )/CH ,/CH uint8/Np );/CH %/CH Đi_ngược_lại/Np và/Cc truy/V vết/N for/Np i/M =/CH sz/Np (/CH 1/M )/CH :/CH -/CH 1/M :/CH 2/M %/CH optSeam(i)/Np =/CH indJ/Np -/CH 1;/Np optSeamMask/Np (/CH i/M ,/CH indJ/Np -/CH 1/M )/CH =/CH 1/M ;/CH %/CH -1/Np vì/E lúc/N đầu/N ta/P thêm/V một/M cột/N 0/M vào/E bên/N trái/Nc neighbors/Np =/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np -/CH 1/M )/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np )/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np +/CH 1/M );/CH val/Np ,/CH indIncr/Np =/CH min/Np (/CH neighbors/Np );/CH seamEnergy/Np =/CH seamEnergy/Np +/CH val/Np ;/CH indJ/Np =/CH indJ/Np +/CH (/CH indIncr/Np -/CH 2/M );/CH %/CH (x/Np -/CH 2)/Np :/CH 1/M ,/CH 2-gt;-1/Np ,/CH 1/M end/Np optSeamMask/Np (/CH 1/M ,/CH indJ/Np -/CH 1/M )/CH =/CH 1/M ;/CH %/CH -1/Np vì/E lúc/N đầu/N ta/P thêm/V một/M cột/N 0/M vào/E bên/N trái/Nc optSeamMask/Np =/CH ~/CH optSeamMask/Np ;/CH end/Np Tìm/V phương_án/N tối_ưu/A để/E xóa/V đường/N seam/Np Bây_giờ/P ta/P có_thể/R tính_toán/V ra/V được/V đường/N seam/Np và/Cc sử_dụng/V đoạn/Nc code/Np dưới_đây/Np ,/CH ta/P có_thể/R loại_bỏ/V đường/N seam/Np ra/V khỏi/V bức/Nc ảnh/N ./CH\nfunction/Np imageReduced/Np =/CH reduceImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np )/CH %/CH Input/Np :/CH Ảnh/N amp;/Np mask/Np của/E đường/N seam/Np %/CH Output/Np :/CH Ảnh/N sau/E khi/N xóa/V đường/N seam/Np dọc/A imageReduced/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH -/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np i/M =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 1/M )/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 1/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 1/M );/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 2/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 2/M );/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 3/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 3/M );/CH end/Np end/Np function/Np imageReduced/Np =/CH reduceImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np )/CH %/CH Input/Np :/CH Ảnh/N amp;/Np mask/Np của/E đường/N seam/Np %/CH Output/Np :/CH Ảnh/N sau/E khi/N xóa/V đường/N seam/Np ngang/A imageReduced/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH -/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np j/Np =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 2/M )/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 1/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 1/M );/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 2/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 2/M );/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 3/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 3/M );/CH end/Np end/Np Đây/P là/V một/M thuật_toán/N hiệu_quả/N để/E làm/V giám/Np kích_thước/N ảnh/N theo/V một_chiều/Np -/CH chỉ_cần/Np việc/N tìm/V và/Cc xóa/V các/L đường/N seam/Np nhiều/A lần/N như/C bạn/N cần/V ./CH\nNhưng/C nếu/C làm/V giảm/V kích_thước/N theo/V cả/P hai/M chiều/N ,/CH ta/P cần/V phải/V làm/V như_thế/X nào/P ?/CH\nLàm_sao/X để/E quyết_định/V rằng/C ở/E mỗi/L lần/N lắp/V đưa_ra/Np quyết_định/V là/V xóa/V theo/V dòng/N hay/Cc cột/N sẽ/R tốt/A hơn/A ?/CH\nVấn_đề/N này/P một_lần/Np nữa/R được/V giải_quyết/V bằng/E quy_hoạch_động/Np ./CH\nTa/P gọi/V T(i/Np ,/CH j)/Np là/V giá_trị/N năng_lượng/N thấp/A nhất/A khi/N ta/P loại_bỏ/V i/M đường/N seam/Np theo/V chiều_dọc/Np và/Cc j/Np đường/N seam/Np theo/V chiều_ngang/Np ./CH\nCụ_thể/A :/CH T(i/Np ,/CH j)/Np =/CH min(T(i/Np ,/CH j-1)/Np +/CH E(seamVertical)/Np ,/CH T(i-1/Np ,/CH j)/Np +/CH E(seamHorizontal))/Np ./CH\nTrong/E đó/P E(seamVertical)/Np là/V giá_trị/N nhỏ/A nhất/A (tối/Np ưu)/Np đường/N seam/Np dọc/A loại_bỏ/V đi/V ,/CH E(seamHorizontal)/Np là/V giá_trị/N nhỏ/A nhất/A (tối/Np ưu)/Np đường/N seam/Np ngang/A loại_bỏ/V đi/V ./CH\nTa/P sử_dụng/V thêm/V một/M mảng/N transBitMask(i/Np ,/CH j)/Np lưu/V truy/V vết/N đường_đi/Np cho/E bản/Nc phương_án/N T(i/Np ,/CH j)/Np ./CH\ntransBitMask(i/Np ,/CH j)/Np =/CH 1/M bỏ_đi/Np đường/N seam/Np dọc/A ,/CH transBitMask(i/Np ,/CH j)/Np =/CH 0/M bỏ_đi/Np đường/N seam/Np ngang/A ./CH\nNhìn/V một/M đoạn/Nc code/Np giả/A dưới_đây/Np để/E có_thể/R dễ/A hình_dung/V ./CH\n1)/Np T(0/Np ,/CH 0)/Np =/CH 0;/Np 2)/Np Khởi/V tạo/V T/Nu :/CH for/Np all/Np j/Np T(0/Np ,/CH j)/Np =/CH T(0/Np ,/CH j/Np -/CH 1)/Np +/CH E(seamVertical);/Np for/Np all/Np i/M T(i/Np ,/CH 0)/Np =/CH T(j/Np -/CH 1/M ,/CH 0)/Np +/CH E(seamHorizontal);/Np 3)/Np Initialize/Np borders/Np of/E TransBitMask/Np (TBM)/Np :/CH for/Np all/Np j/Np TBM(0/Np ,/CH j)/Np =/CH 1;/Np for/Np all/Np i/M TBM(0/Np ,/CH i)/Np =/CH 0;/Np 4)/Np Tính_T/Np và/Cc TBM/Np :/CH for/Np i/M =/CH 2/M to/A r/Np imageWithoutRow/Np =/CH image;/Np for/Np j/Np =/CH 2/M to/A c/Ni energy/Np =/CH computeEnergy(imageWithoutRow);/Np horizontalSeamEnergy/Np =/CH findHorizontalSeamEnergy(energy);/Np verticalSeamEnergy/Np =/CH findVerticalSeamEnergy(energy);/Np tVertical/Np =/CH T(i/Np -/CH 1/M ,/CH j)/Np +/CH verticalSeamEnergy;/Np tHorizontal/Np =/CH T(i/Np ,/CH j/Np -/CH 1)/Np _/Np horizontalSeamEnergy;/Np if/Np (tVertical/Np lt;/Np tHorizontal)/Np T(i/Np ,/CH j)/Np =/CH tVertical;/Np TBM(i/Np ,/CH j)/Np =/CH 1/M else/Np T(i/Np ,/CH j)/Np =/CH tHorizontal;/Np TBM(i/Np ,/CH j)/Np =/CH 0/M //CH Xóa/V đường/N seam/Np dọc/A imageWithoutRow/Np =/CH removeVerticalSeam(energy);/Np energy/Np =/CH computeEnergy(image);/Np image/Np =/CH removeHorizontalSeam(energy);/Np 5)/Np Truy/V vết/N theo/V T/Nu và/Cc TBM/Np ./CH\nĐoạn/Nc code_bằng/Np matlab/Np ./CH\nChú_ý/V ở/E pseduocode/Np dùng/V zerobased/Np index/Np ,/CH do/E matlab/Np sử_dụng/V onebased/Np index/Np nên/C cần/V phải/V đẩy/V index/Np lên/V 1/M đơn_vị/N ./CH\nfunction/Np T/Nu ,/CH transBitMask/Np =/CH findTransportMatrix/Np (/CH sizeReduction/Np ,/CH image/Np )/CH %/CH Input/Np :/CH Kích_thước/N cần/V giảm/V amp;/Np ảnh/N gốc/N %/CH Output/Np :/CH T/Nu ,/CH TBM/Np định_nghĩa/N ở/E trên/E T/Nu =/CH zeros/Np (/CH sizeReduction/Np (/CH 1/M )/CH +/CH 1/M ,/CH sizeReduction/Np (/CH 2/M )/CH +/CH 1/M ,/CH double/Np );/CH transBitMask/Np =/CH ones/Np (/CH size/Nb (/CH T/Nu ))/Np -/CH 1/M ;/CH %/CH Khởi/V tạo/V T(i/Np ,/CH 1)/Np ,/CH T(1/Np ,/CH i)/Np ,/CH TBM(i/Np ,/CH 1)/Np ,/CH TBM(1/Np ,/CH i)/Np imageNoRow/Np =/CH image/Np ;/CH for/Np i/M =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 1/M )/CH %/CH Tính_năng/N lượng/N energy/Np =/CH energyRGB/Np (/CH imageNoRow/Np );/CH %/CH Tìm/V đường/N seam/Np ngang/A tối_ưu/A optSeamMask/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH %/CH Xóa/V đường/N seam/Np imageNoRow/Np =/CH reduceImageByMask/Np (/CH imageNoRow/Np ,/CH optSeamMask/Np ,/CH 0/M );/CH %/CH Tính_T/Np và/Cc TBM_T/Np (/CH i/M ,/CH 1/M )/CH =/CH T/Nu (/CH i/M -/CH 1/M ,/CH 1/M )/CH +/CH seamEnergyRow/Np ;/CH transBitMask/Np (/CH i/M ,/CH 1/M )/CH =/CH 0/M ;/CH end/Np ;/CH imageNoColumn/Np =/CH image/Np ;/CH for/Np j/Np =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 2/M )/CH %/CH Tính_năng/N lượng/N energy/Np =/CH energyRGB/Np (/CH imageNoColumn/Np );/CH %/CH Tìm/V đường/N seam/Np dọc/A optSeamMask/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH %/CH Xóa/V đường/N seam/Np dọc/A imageNoColumn/Np =/CH reduceImageByMask/Np (/CH imageNoColumn/Np ,/CH optSeamMask/Np ,/CH 1/M );/CH %/CH Tính_TBM/Np amp;/Np T/Nu transBitMask/Np (/CH 1/M ,/CH j/Np )/CH =/CH 1/M ;/CH T/Nu (/CH 1/M ,/CH j/Np )/CH =/CH T/Nu (/CH 1/M ,/CH j/Np -/CH 1/M )/CH +/CH seamEnergyColumn/Np ;/CH end/Np ;/CH %/CH Xóa/V 1/M hàng/N và/Cc 1/M cột/N energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMask/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 0/M );/CH energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMask/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 1/M );/CH %/CH fill/Np in/V internal/Np part/Np for/Np i/M =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 1/M )/CH imageWithoutRow/Np =/CH image/Np ;/CH %/CH Ta/P sẽ/R xóa/V 1/M hàng/N của/E imageWithoutRow/Np for/Np j/Np =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 2/M )/CH energy/Np =/CH energyRGB/Np (/CH imageWithoutRow/Np );/CH optSeamMaskRow/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoRow/Np =/CH reduceImageByMask/Np (/CH imageWithoutRow/Np ,/CH optSeamMaskRow/Np ,/CH 0/M );/CH optSeamMaskColumn/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoColumn/Np =/CH reduceImageByMask/Np (/CH imageWithoutRow/Np ,/CH optSeamMaskColumn/Np ,/CH 1/M );/CH neighbors/Np =/CH (/CH T/Nu (/CH i/M -/CH 1/M ,/CH j/Np )/CH +/CH seamEnergyRow/Np )/CH (/CH T/Nu (/CH i/M ,/CH j/Np -/CH 1/M )/CH +/CH seamEnergyColumn/Np );/CH val/Np ,/CH ind/Np =/CH min/Np (/CH neighbors/Np );/CH T/Nu (/CH i/M ,/CH j/Np )/CH =/CH val/Np ;/CH transBitMask/Np (/CH i/M ,/CH j/Np )/CH =/CH ind/Np -/CH 1/M ;/CH %/CH Ta/P xóa/V lần_lượt/R từng/R cột/N imageWithoutRow/Np =/CH imageNoColumn/Np ;/CH end/Np ;/CH energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMaskRow/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH %/CH move/Np from/Np top/N to/A bottom/Np image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMaskRow/Np ,/CH 0/M );/CH end/Np ;/CH end/Np Phóng/V to/A hình_ảnh/N Để/E phóng/V to/A hình_ảnh/N ,/CH thay_vì/X ta/P loại_bỏ/V đường/N seam/Np ra/V khỏi/V ảnh/N ,/CH thì/C ta/P thêm/V một/M đường/N seam/Np mới/R vào/E với/E giá_trị/N trung_bình/A của/E các/L điểm_ảnh/Np lận/V cận/A ./CH\nfunction/Np imageEnlarged/Np =/CH enlargeImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np )/CH %/CH Input/Np :/CH Ảnh/N và/Cc đường/N seam/Np %/CH Output/Np :/CH Ảnh/N đã/R được/V phóng/V to/A thêm/V 1/M cột/N avg/Np =/CH (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH k/N )/CH (/CH image/Np (/CH i/M ,/CH j/Np -/CH 1/M ,/CH k/N )/CH +/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M ,/CH k/N ))/Np 2/M ;/CH imageEnlarged/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH +/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np i/M =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 1/M )/CH j/Np =/CH find/Np (/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ~=/Np 1/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 1/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 1/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 1/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 1/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 2/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 2/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 2/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 2/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 3/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 3/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 3/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 3/M );/CH end/Np ;/CH end/Np function/Np imageEnlarged/Np =/CH enlargeImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np )/CH %/CH Input/Np :/CH Ảnh/N và/Cc đường/N seam/Np %/CH Output/Np :/CH Ảnh/N đã/R được/V phóng/V to/A thêm/V 1/M hàng/N avg/Np =/CH (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH k/N )/CH (/CH image/Np (/CH i/M -/CH 1/M ,/CH j/Np ,/CH k/N )/CH +/CH image/Np (/CH i/M +/CH 1/M ,/CH j/Np ,/CH k/N ))/Np 2/M ;/CH imageEnlarged/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH +/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np j/Np =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 2/M )/CH i/M =/CH find/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ~=/Np 1/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 1/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 1/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 1/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 1/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 2/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 2/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 2/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 2/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 3/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 3/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 3/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 3/M );/CH end/Np ;/CH end/Np Source/Np code/Np Dưới_đây/Np là/V toàn_bộ/L code/Np của/E tác_giả/N (giữ/Np nguyên/A lại/R comment/Np gốc/N bằng/E tiếng/N Anh)/Np %/CH (C)/Np Copyright_Kirill_Lykov/Np 2013/M ./CH\n%/CH %/CH Distributed/Np under/Np the/B FreeBSD_Software_License/Np (See/Np accompanying/Np file/Np license/Np ./CH txt)/Np function/Np image/Np =/CH seamCarving/Np (/CH newSize/Np ,/CH image/Np )/CH %/CH apply/Np seam/Np carving/Np to/A the_image/Np %/CH following/Np paper/Np by/Np Avidan/Np and/Np Shamir/Np 07/M sizeReductionX/Np =/CH size/Nb (/CH image/Np ,/CH 1/M )/CH -/CH newSize/Np (/CH 1/M );/CH sizeReductionY/Np =/CH size/Nb (/CH image/Np ,/CH 2/M )/CH -/CH newSize/Np (/CH 2/M );/CH mmax/Np =/CH (/CH left/Np ,/CH right/Np )/CH max/Np (/CH left/Np right/Np );/CH image/Np =/CH seamCarvingReduce/Np (/CH mmax/Np (/CH 0/M ,/CH sizeReductionX/Np )/CH ,/CH mmax/Np (/CH 0/M ,/CH sizeReductionY/Np )/CH ,/CH image/Np );/CH image/Np =/CH seamCarvingEnlarge/Np (/CH mmax/Np (/CH 0/M ,/CH -/CH sizeReductionX/Np )/CH ,/CH mmax/Np (/CH 0/M ,/CH -/CH sizeReductionY/Np )/CH ,/CH image/Np );/CH end/Np function/Np image/Np =/CH seamCarvingReduce/Np (/CH sizeReduction/Np ,/CH image/Np )/CH if/Np (/CH sizeReduction/Np ==/Np 0/M )/CH return/Np ;/CH end/Np ;/CH T/Nu ,/CH transBitMask/Np =/CH findTransportMatrix/Np (/CH sizeReduction/Np ,/CH image/Np );/CH image/Np =/CH addOrDeleteSeams/Np (/CH transBitMask/Np ,/CH sizeReduction/Np ,/CH image/Np ,/CH reduceImageByMask/Np );/CH end/Np %/CH TODO_Bug/Np :/CH enlarge/Np gives/Np artifacts/Np althout/Np I/M chouse/Np different/Np seams/Np as/Np described/Np %/CH in/V 4/M ./CH 3/M in/V the_paper/Np function/Np image/Np =/CH seamCarvingEnlarge/Np (/CH sizeEnlarge/Np ,/CH image/Np )/CH if/Np (/CH sizeEnlarge/Np ==/Np 0/M )/CH return/Np ;/CH end/Np ;/CH T/Nu ,/CH transBitMask/Np =/CH findTransportMatrix/Np (/CH sizeEnlarge/Np ,/CH image/Np );/CH image/Np =/CH addOrDeleteSeams/Np (/CH transBitMask/Np ,/CH sizeEnlarge/Np ,/CH image/Np ,/CH enlargeImageByMask/Np );/CH end/Np function/Np T/Nu ,/CH transBitMask/Np =/CH findTransportMatrix/Np (/CH sizeReduction/Np ,/CH image/Np )/CH %/CH find/Np optimal/Np order/Np of/E removing/Np raws/Np and/Np columns/Np T/Nu =/CH zeros/Np (/CH sizeReduction/Np (/CH 1/M )/CH +/CH 1/M ,/CH sizeReduction/Np (/CH 2/M )/CH +/CH 1/M ,/CH double/Np );/CH transBitMask/Np =/CH ones/Np (/CH size/Nb (/CH T/Nu ))/Np -/CH 1/M ;/CH %/CH fill/Np in/V borders/Np imageNoRow/Np =/CH image/Np ;/CH for/Np i/M =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 1/M )/CH energy/Np =/CH energyRGB/Np (/CH imageNoRow/Np );/CH optSeamMask/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoRow/Np =/CH reduceImageByMask/Np (/CH imageNoRow/Np ,/CH optSeamMask/Np ,/CH 0/M );/CH transBitMask/Np (/CH i/M ,/CH 1/M )/CH =/CH 0/M ;/CH T/Nu (/CH i/M ,/CH 1/M )/CH =/CH T/Nu (/CH i/M -/CH 1/M ,/CH 1/M )/CH +/CH seamEnergyRow/Np ;/CH end/Np ;/CH imageNoColumn/Np =/CH image/Np ;/CH for/Np j/Np =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 2/M )/CH energy/Np =/CH energyRGB/Np (/CH imageNoColumn/Np );/CH optSeamMask/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoColumn/Np =/CH reduceImageByMask/Np (/CH imageNoColumn/Np ,/CH optSeamMask/Np ,/CH 1/M );/CH transBitMask/Np (/CH 1/M ,/CH j/Np )/CH =/CH 1/M ;/CH T/Nu (/CH 1/M ,/CH j/Np )/CH =/CH T/Nu (/CH 1/M ,/CH j/Np -/CH 1/M )/CH +/CH seamEnergyColumn/Np ;/CH end/Np ;/CH %/CH on/Np the/B borders/Np ,/CH just/Np remove/Np one/Np column/Np and/Np one/Np row/Np before/Np proceeding/Np energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMask/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 0/M );/CH energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMask/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 1/M );/CH %/CH fill/Np in/V internal/Np part/Np for/Np i/M =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 1/M )/CH imageWithoutRow/Np =/CH image/Np ;/CH %/CH copy/Np for/Np deleting/Np columns/Np for/Np j/Np =/CH 2/M :/CH size/Nb (/CH T/Nu ,/CH 2/M )/CH energy/Np =/CH energyRGB/Np (/CH imageWithoutRow/Np );/CH optSeamMaskRow/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoRow/Np =/CH reduceImageByMask/Np (/CH imageWithoutRow/Np ,/CH optSeamMaskRow/Np ,/CH 0/M );/CH optSeamMaskColumn/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH imageNoColumn/Np =/CH reduceImageByMask/Np (/CH imageWithoutRow/Np ,/CH optSeamMaskColumn/Np ,/CH 1/M );/CH neighbors/Np =/CH (/CH T/Nu (/CH i/M -/CH 1/M ,/CH j/Np )/CH +/CH seamEnergyRow/Np )/CH (/CH T/Nu (/CH i/M ,/CH j/Np -/CH 1/M )/CH +/CH seamEnergyColumn/Np );/CH val/Np ,/CH ind/Np =/CH min/Np (/CH neighbors/Np );/CH T/Nu (/CH i/M ,/CH j/Np )/CH =/CH val/Np ;/CH transBitMask/Np (/CH i/M ,/CH j/Np )/CH =/CH ind/Np -/CH 1/M ;/CH %/CH move/Np from/Np left/Np to/A right/Np imageWithoutRow/Np =/CH imageNoColumn/Np ;/CH end/Np ;/CH energy/Np =/CH energyRGB/Np (/CH image/Np );/CH optSeamMaskRow/Np ,/CH seamEnergyRow/Np =/CH findOptSeam/Np (/CH energy/Np );/CH %/CH move/Np from/Np top/N to/A bottom/Np image/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH optSeamMaskRow/Np ,/CH 0/M );/CH end/Np ;/CH end/Np function/Np image/Np =/CH addOrDeleteSeams/Np (/CH transBitMask/Np ,/CH sizeReduction/Np ,/CH image/Np ,/CH operation/Np )/CH %/CH delete/Np seams/Np following/Np optimal/Np way/Np i/M =/CH size/Nb (/CH transBitMask/Np ,/CH 1/M );/CH j/Np =/CH size/Nb (/CH transBitMask/Np ,/CH 2/M );/CH for/Np it/Np =/CH 1/M :/CH (/CH sizeReduction/Np (/CH 1/M )/CH +/CH sizeReduction/Np (/CH 2/M ))/Np energy/Np =/CH energyRGB/Np (/CH image/Np );/CH if/Np (/CH transBitMask/Np (/CH i/M ,/CH j/Np )/CH ==/Np 0/M )/CH optSeamMask/Np ,/CH seamEnergyRaw/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH operation/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 0/M );/CH i/M =/CH i/M -/CH 1/M ;/CH else/Np optSeamMask/Np ,/CH seamEnergyColumn/Np =/CH findOptSeam/Np (/CH energy/Np );/CH image/Np =/CH operation/Np (/CH image/Np ,/CH optSeamMask/Np ,/CH 1/M );/CH j/Np =/CH j/Np -/CH 1/M ;/CH end/Np ;/CH end/Np ;/CH end/Np function/Np optSeamMask/Np ,/CH seamEnergy/Np =/CH findOptSeam/Np (/CH energy/Np )/CH %/CH following/Np paper/Np by/Np Avidan/Np and/Np Shamir/Np 07/M %/CH finds/Np optimal/Np seam/Np %/CH returns/Np mask/Np with/Np 0/M mean/Np a/Ni pixel/Np is/Np in/V the_seam/Np %/CH find/Np M/Nu for_vertical/Np seams/Np %/CH for_vertical/Np -/CH use/Np I_M/Np =/CH padarray/Np (/CH energy/Np ,/CH 0/M 1/M ,/CH realmax/Np (/CH double/Np ));/Np %/CH to/A avoid/Np handling/Np border/Np elements/Np sz/Np =/CH size/Nb (/CH M/Nu );/CH for/Np i/M =/CH 2/M :/CH sz/Np (/CH 1/M )/CH for/Np j/Np =/CH 2/M :/CH (/CH sz/Np (/CH 2/M )/CH -/CH 1/M )/CH neighbors/Np =/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np -/CH 1/M )/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np )/CH M/Nu (/CH i/M -/CH 1/M ,/CH j/Np +/CH 1/M );/CH M/Nu (/CH i/M ,/CH j/Np )/CH =/CH M/Nu (/CH i/M ,/CH j/Np )/CH +/CH min/Np (/CH neighbors/Np );/CH end/Np end/Np %/CH find/Np the/B min/Np element/Np in/V the/B last/Np raw/Np val/Np ,/CH indJ/Np =/CH min/Np (/CH M/Nu (/CH sz/Np (/CH 1/M )/CH ,/CH :/CH ));/Np seamEnergy/Np =/CH val/Np ;/CH %optSeam/Np =/CH zeros(sz(1)/Np ,/CH 1/M ,/CH int32);/Np optSeamMask/Np =/CH zeros/Np (/CH size/Nb (/CH energy/Np )/CH ,/CH uint8/Np );/CH %indJ/Np =/CH indJ/Np -/CH 1;/Np %/CH because/Np of/E padding/Np on/Np 1/M element/Np from/Np left/Np %go/Np backward/Np and/Np save/Np (i/Np ,/CH j)/Np for/Np i/M =/CH sz/Np (/CH 1/M )/CH :/CH -/CH 1/M :/CH 2/M %optSeam(i)/Np =/CH indJ/Np -/CH 1;/Np optSeamMask/Np (/CH i/M ,/CH indJ/Np -/CH 1/M )/CH =/CH 1/M ;/CH %/CH -1/Np because/Np of/E padding/Np on/Np 1/M element/Np from/Np left/Np neighbors/Np =/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np -/CH 1/M )/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np )/CH M/Nu (/CH i/M -/CH 1/M ,/CH indJ/Np +/CH 1/M );/CH val/Np ,/CH indIncr/Np =/CH min/Np (/CH neighbors/Np );/CH seamEnergy/Np =/CH seamEnergy/Np +/CH val/Np ;/CH indJ/Np =/CH indJ/Np +/CH (/CH indIncr/Np -/CH 2/M );/CH %/CH (x/Np -/CH 2)/Np :/CH 1/M ,/CH 2-gt;-1/Np ,/CH 1/M end/Np %optSeam(1)/Np =/CH indJ;/Np %/CH to/A avoid/Np if/Np in/V loop/Np becuase/Np matlab/Np is/Np slow/Np as/Np hell/Nb optSeamMask/Np (/CH 1/M ,/CH indJ/Np -/CH 1/M )/CH =/CH 1/M ;/CH %/CH -1/Np because/Np of/E padding/Np on/Np 1/M element/Np from/Np left/Np optSeamMask/Np =/CH ~/CH optSeamMask/Np ;/CH end/Np function/Np imageReduced/Np =/CH reduceImageByMask/Np (/CH image/Np ,/CH seamMask/Np ,/CH isVerical/Np )/CH %/CH removes/Np pixels/Np by/Np input/Np mask/Np %/CH removes/Np vertical/Np line/N if/Np isVerical/Np ==/Np 1/M ,/CH otherwise/Np horizontal/Np if/Np (/CH isVerical/Np )/CH imageReduced/Np =/CH reduceImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np );/CH else/Np imageReduced/Np =/CH reduceImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np );/CH end/Np ;/CH end/Np %/CH could/Np not/Np find/Np a/Ni more/Np elegant/Np way/Np to/A do/E it/Np function/Np imageReduced/Np =/CH reduceImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np )/CH imageReduced/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH -/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np i/M =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 1/M )/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 1/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 1/M );/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 2/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 2/M );/CH imageReduced/Np (/CH i/M ,/CH :/CH ,/CH 3/M )/CH =/CH image/Np (/CH i/M ,/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ,/CH 3/M );/CH end/Np end/Np function/Np imageReduced/Np =/CH reduceImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np )/CH imageReduced/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH -/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np j/Np =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 2/M )/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 1/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 1/M );/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 2/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 2/M );/CH imageReduced/Np (/CH :/CH ,/CH j/Np ,/CH 3/M )/CH =/CH image/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ,/CH j/Np ,/CH 3/M );/CH end/Np end/Np function/Np imageEnlarged/Np =/CH enlargeImageByMask/Np (/CH image/Np ,/CH seamMask/Np ,/CH isVerical/Np )/CH %/CH removes/Np pixels/Np by/Np input/Np mask/Np %/CH removes/Np vertical/Np line/N if/Np isVerical/Np ==/Np 1/M ,/CH otherwise/Np horizontal/Np if/Np (/CH isVerical/Np )/CH imageEnlarged/Np =/CH enlargeImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np );/CH else/Np imageEnlarged/Np =/CH enlargeImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np );/CH end/Np ;/CH end/Np function/Np imageEnlarged/Np =/CH enlargeImageByMaskVertical/Np (/CH image/Np ,/CH seamMask/Np )/CH avg/Np =/CH (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH k/N )/CH (/CH image/Np (/CH i/M ,/CH j/Np -/CH 1/M ,/CH k/N )/CH +/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M ,/CH k/N ))/Np 2/M ;/CH imageEnlarged/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH +/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np i/M =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 1/M )/CH j/Np =/CH find/Np (/CH seamMask/Np (/CH i/M ,/CH :/CH )/CH ~=/Np 1/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 1/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 1/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 1/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 1/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 2/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 2/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 2/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 2/M );/CH imageEnlarged/Np (/CH i/M ,/CH :/CH ,/CH 3/M )/CH =/CH image/Np (/CH i/M ,/CH 1/M :/CH j/Np ,/CH 3/M )/CH ,/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 3/M )/CH ,/CH image/Np (/CH i/M ,/CH j/Np +/CH 1/M :/CH end/Np ,/CH 3/M );/CH end/Np ;/CH end/Np function/Np imageEnlarged/Np =/CH enlargeImageByMaskHorizontal/Np (/CH image/Np ,/CH seamMask/Np )/CH avg/Np =/CH (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH k/N )/CH (/CH image/Np (/CH i/M -/CH 1/M ,/CH j/Np ,/CH k/N )/CH +/CH image/Np (/CH i/M +/CH 1/M ,/CH j/Np ,/CH k/N ))/Np 2/M ;/CH imageEnlarged/Np =/CH zeros/Np (/CH size/Nb (/CH image/Np ,/CH 1/M )/CH +/CH 1/M ,/CH size/Nb (/CH image/Np ,/CH 2/M )/CH ,/CH size/Nb (/CH image/Np ,/CH 3/M ));/Np for/Np j/Np =/CH 1/M :/CH size/Nb (/CH seamMask/Np ,/CH 2/M )/CH i/M =/CH find/Np (/CH seamMask/Np (/CH :/CH ,/CH j/Np )/CH ~=/Np 1/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 1/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 1/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 1/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 1/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 2/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 2/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 2/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 2/M );/CH imageEnlarged/Np (/CH :/CH ,/CH j/Np ,/CH 3/M )/CH =/CH image/Np (/CH 1/M :/CH i/M ,/CH j/Np ,/CH 3/M );/CH avg/Np (/CH image/Np ,/CH i/M ,/CH j/Np ,/CH 3/M );/CH image/Np (/CH i/M +/CH 1/M :/CH end/Np ,/CH j/Np ,/CH 3/M );/CH end/Np ;/CH end/Np function/Np res/Np =/CH energyRGB/Np (/CH I/M )/CH %/CH returns/Np energy/Np of/E all/Np pixelels/Np %/CH e/Ni =/CH dI/Np +/CH dI/Np res/Np =/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 1/M ))/Np +/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 2/M ))/Np +/CH energyGrey/Np (/CH I/M (/CH :/CH ,/CH :/CH ,/CH 3/M ));/Np end/Np function/Np res/Np =/CH energyGrey/Np (/CH I/M )/CH %/CH returns/Np energy/Np of/E all/Np pixelels/Np %/CH e/Ni =/CH dI/Np +/CH dI/Np res/Np =/CH abs/Np (/CH imfilter/Np (/CH I/M ,/CH -/CH 1/M ,/CH 0/M ,/CH 1/M ,/CH replicate/Np ))/Np +/CH abs/Np (/CH imfilter/Np (/CH I/M ,/CH -/CH 1/M ;/CH 0/M ;/CH 1/M ,/CH replicate/Np ));/Np end/Np Tham_khảo/V Wikipedia_Seam_Carving/Np for/Np Content-Aware_Image_Scaling/Np https/Np :/CH //CH ./CH com/2013/03/04/seam-carving-for-content-aware-image-scaling/Np http/Np :/CH //CH ./CH github/Np ./CH io/blog/2013/06/06/seam-carving-algorithm/Np\n", "title": "Seam Carving Algorithm\n", "link": "http://vnoi.info/wiki/cs/imageprocessing/Seam-Carving\n"}