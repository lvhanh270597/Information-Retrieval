{"content": "Disjoint_Sets là 1 CTDL rất hữu_dụng , sử_dụng rất nhanh , gọn và dễ_dàng .\nNó được dùng làm nền_tảng cho một_số thuật_toán , như Kruskal’s và Prim’s , 2 thuật_toán tìm cây khung nhỏ nhất trên đồ_thị .\nDisjoint_Sets , hoặc DSU ( Disjoint_Sets_Union ) như tên_gọi của nó , là một_tập hợp các tập_hợp .\nHãy tưởng_tượng chúng_ta có n cái hộp và n viên sỏi .\nCác viên sỏi_phân biệt .\nBan_đầu mỗi viên sỏi nằm trong một cái hộp .\nta cần thực_hiện 2 loại truy_vấn : Cho hết sỏi ở 2 hộp u và v vào cùng một hộp .\nKiểm_tra 2 viên sỏi i và j có thuộc cùng một hộp hay_không Giả_sử , chỉ_có duy_nhất 1 bộ dụng_cụ trong 1 hộp .\nTa có n bộ dụng_cụ , n hộp , và ban_đầu , bộ thứ i sẽ nằm trong hộp thứ i .\nVới những yêu_cầu trên , ta có_thể sử_dụng nhiều cấu_trúc , như : Cài_đặt Disjoint_Set với Cây_Cây là cấu_trúc hữu_hiệu nhất dùng cho DSU .\nVới mỗi đỉnh , ta lưu lại đỉnh cha của nó (đỉnh cha của đỉnh gốc là -1) .\nBan_đầu , mọi đỉnh cha được set là -1 .\nCó các truy_vấn tìm đỉnh gốc của mỗi hộp (có được gốc , ta có_thể truy ra vị_trí của hộp) và các truy_vấn yêu_cầu hợp 2 cây lại .\nĐể thuật_toán nhanh hơn , mỗi lần tìm gốc của mỗi đỉnh , ta đặt đỉnh cha của nó là gốc cho truy_vấn tiếp_theo .\nLuôn muốn độ_cao của cây là nhỏ nhất có_thể , vì_vậy , mỗi khi nhập các hộp lại với_nhau , ta bỏ các bộ dụng_cụ trong hộp có ít bộ hơn vào hộp còn_lại .\nCode_C++ ( bmerry ) // pari = x nếu viên sỏi i và viên sỏi x nằm trong cùng một hộp // Nếu pari lt; 0 thì viên sỏi i nằm trong hộp i , và -pari chính là số sỏi trong hộp đó .\n// Ban_đầu , khởi tạo pari = -1 với mọi i .\nint root ( int v ) // Cho 1 số v , tìm hộp chứa viên sỏi v return par v lt; 0 ?\nv : ( par v = root ( par v )); // Viên sỏi v nằm trong cùng hộp với viên sỏi chứa parv // Chú_ý ở đây ta gán lại parv = root(parv) , kĩ_thuật này // được gọi_là Path_Compression , giúp giảm độ phức_tạp mỗi // thao_tác xuống log(n) void merge ( int x , int y ) // Gộp 2 hộp chứa viên sỏi x và y vào cùng 1 hộp if (( x = root ( x )) == ( y = root ( y )) // 2 viên sỏi x và y đã thuộc cùng 1 hộp , ta không cần làm_gì cả return ; if ( par y lt; par x ) // Ta gộp vào hộp chứa nhiều sỏi hơn .\nKĩ_thuật này gọi_là Union-by-rank , và cũng giúp giảm // độ phức_tạp mỗi thao_tác xuống log(n) .\n// Nếu kết_hợp cả Union-by-rank và Path-compression thì độ phức_tạp mỗi thao_tác là ackerman(n) , // rất rất nhỏ với n .\nswap ( x , y ); par x += par y ; par y = x ; Cài_đặt Disjoint set với Mảng amp; Vector_Ta lưu vị_trí các viên sỏi trong một vector (hoặc mảng ) và mỗi khi có truy_vấn yêu_cầu nhập hai hộp , ta bỏ các viên sỏi ở hộp có ít viên sỏi hơn vào hộp còn_lại .\nĐộ phức_tạp không cao vì với mỗi viên sỏi , tổng_số lần lấy và bỏ nó vào hộp chỉ tối_đa là log(n) .\nĐộ phức_tạp cho n thao_tác sẽ là O(nlog(n)) .\nKhi cài_đặt DSU , cách này không được sử_dụng (do phức_tạp hơn cách trên) , tuy_nhiên ý_tưởng này có_thể được áp_dụng cho nhiều bài khác .\nCài_đặt Disjoint_Set với Sets (Cây Đỏ_Đen;_Red-Black_Trees) Một_cách khác là lưu chúng trong một cây_đỏ đen (trong C++ là set thư_viện STL ) .\nTa làm y_như đã làm với vectors , độ phức_tạp sẽ là O(nlog2n) .\n(1 log cho việc nhập vào) .\nBài_tập : (Phải tham_gia nhóm ACM-OI ) Hamro amp; Tools_TROY_Query Tài_liệu tham_khảo : Codeforces\n", "tagged": "Disjoint_Sets/Np là/V 1/M CTDL/Np rất/R hữu_dụng/Np ,/CH sử_dụng/V rất/R nhanh/A ,/CH gọn/A và/Cc dễ_dàng/A ./CH\nNó/P được/V dùng/V làm/V nền_tảng/N cho/E một_số/L thuật_toán/N ,/CH như/C Kruskal’s/Np và/Cc Prim’s/Np ,/CH 2/M thuật_toán/N tìm/V cây/N khung/N nhỏ/A nhất/A trên/E đồ_thị/Np ./CH\nDisjoint_Sets/Np ,/CH hoặc/Cc DSU/Np (/CH Disjoint_Sets_Union/Np )/CH như/C tên_gọi/Np của/E nó/P ,/CH là/V một_tập/Np hợp/V các/L tập_hợp/N ./CH\nHãy/R tưởng_tượng/V chúng_ta/P có/V n/Ny cái/Nc hộp/N và/Cc n/Ny viên/Nc sỏi/N ./CH\nCác/L viên/Nc sỏi_phân/Np biệt/Np ./CH\nBan_đầu/N mỗi/L viên/Nc sỏi/N nằm/V trong/E một/M cái/Nc hộp/N ./CH\nta/P cần/V thực_hiện/V 2/M loại/N truy_vấn/Np :/CH Cho/E hết/V sỏi/N ở/E 2/M hộp/N u/N và/Cc v/Nu vào/E cùng/A một/M hộp/N ./CH\nKiểm_tra/V 2/M viên/Nc sỏi/N i/M và/Cc j/Np có/V thuộc/V cùng/A một/M hộp/N hay_không/Np Giả_sử/Np ,/CH chỉ_có/Np duy_nhất/A 1/M bộ/N dụng_cụ/N trong/E 1/M hộp/N ./CH\nTa/P có/V n/Ny bộ/N dụng_cụ/N ,/CH n/Ny hộp/N ,/CH và/Cc ban_đầu/N ,/CH bộ/N thứ/N i/M sẽ/R nằm/V trong/E hộp/N thứ/N i/M ./CH\nVới/E những/L yêu_cầu/V trên/E ,/CH ta/P có_thể/R sử_dụng/V nhiều/A cấu_trúc/N ,/CH như/C :/CH Cài_đặt/V Disjoint_Set/Np với/E Cây_Cây/Np là/V cấu_trúc/N hữu_hiệu/A nhất/A dùng/V cho/E DSU/Np ./CH\nVới/E mỗi/L đỉnh/N ,/CH ta/P lưu/V lại/R đỉnh/N cha/N của/E nó/P (đỉnh/Np cha/N của/E đỉnh/N gốc/N là/V -1)/Np ./CH\nBan_đầu/N ,/CH mọi/L đỉnh/N cha/N được/V set/N là/V -1/Np ./CH\nCó/V các/L truy_vấn/Np tìm/V đỉnh/N gốc/N của/E mỗi/L hộp/N (có/Np được/V gốc/N ,/CH ta/P có_thể/R truy/V ra/V vị_trí/N của/E hộp)/Np và/Cc các/L truy_vấn/Np yêu_cầu/V hợp/V 2/M cây/N lại/R ./CH\nĐể/E thuật_toán/N nhanh/A hơn/A ,/CH mỗi/L lần/N tìm/V gốc/N của/E mỗi/L đỉnh/N ,/CH ta/P đặt/V đỉnh/N cha/N của/E nó/P là/V gốc/N cho/E truy_vấn/Np tiếp_theo/V ./CH\nLuôn/R muốn/V độ_cao/Np của/E cây/N là/V nhỏ/A nhất/A có_thể/R ,/CH vì_vậy/C ,/CH mỗi/L khi/N nhập/V các/L hộp/N lại/R với_nhau/Np ,/CH ta/P bỏ/V các/L bộ/N dụng_cụ/N trong/E hộp/N có/V ít/A bộ/N hơn/A vào/E hộp/N còn_lại/Np ./CH\nCode_C++/Np (/CH bmerry/Np )/CH //CH pari/Np =/CH x/CH nếu/C viên/Nc sỏi/N i/M và/Cc viên/Nc sỏi/N x/CH nằm/V trong/E cùng/A một/M hộp/N //CH Nếu/C pari/Np lt;/Np 0/M thì/C viên/Nc sỏi/N i/M nằm/V trong/E hộp/N i/M ,/CH và/Cc -pari/Np chính/T là/V số/N sỏi/N trong/E hộp/N đó/P ./CH\n//CH Ban_đầu/N ,/CH khởi/V tạo/V pari/Np =/CH -1/Np với/E mọi/L i/M ./CH\nint/Np root/Np (/CH int/Np v/Nu )/CH //CH Cho/E 1/M số/N v/Nu ,/CH tìm/V hộp/N chứa/V viên/Nc sỏi/N v/Nu return/Np par/Np v/Nu lt;/Np 0/M ?/CH\nv/Nu :/CH (/CH par/Np v/Nu =/CH root/Np (/CH par/Np v/Nu ));/Np //CH Viên/Nc sỏi/N v/Nu nằm/V trong/E cùng/A hộp/N với/E viên/Nc sỏi/N chứa/V parv/Np //CH Chú_ý/V ở/E đây/P ta/P gán/V lại/R parv/Np =/CH root(parv)/Np ,/CH kĩ_thuật/N này/P //CH được/V gọi_là/V Path_Compression/Np ,/CH giúp/V giảm/V độ/N phức_tạp/A mỗi/L //CH thao_tác/V xuống/V log(n)/Np void/Np merge/Np (/CH int/Np x/CH ,/CH int/Np y/N )/CH //CH Gộp/V 2/M hộp/N chứa/V viên/Nc sỏi/N x/CH và/Cc y/N vào/E cùng/A 1/M hộp/N if/Np ((/Np x/CH =/CH root/Np (/CH x/CH ))/Np ==/Np (/CH y/N =/CH root/Np (/CH y/N ))/Np //CH 2/M viên/Nc sỏi/N x/CH và/Cc y/N đã/R thuộc/V cùng/A 1/M hộp/N ,/CH ta/P không/R cần/V làm_gì/X cả/P return/Np ;/CH if/Np (/CH par/Np y/N lt;/Np par/Np x/CH )/CH //CH Ta/P gộp/V vào/E hộp/N chứa/V nhiều/A sỏi/N hơn/A ./CH\nKĩ_thuật/N này/P gọi_là/V Union-by-rank/Np ,/CH và/Cc cũng/R giúp/V giảm/V //CH độ/N phức_tạp/A mỗi/L thao_tác/V xuống/V log(n)/Np ./CH\n//CH Nếu/C kết_hợp/V cả/P Union-by-rank/Np và/Cc Path-compression/Np thì/C độ/N phức_tạp/A mỗi/L thao_tác/V là/V ackerman(n)/Np ,/CH //CH rất/R rất/R nhỏ/A với/E n/Ny ./CH\nswap/Np (/CH x/CH ,/CH y/N );/CH par/Np x/CH +=/Np par/Np y/N ;/CH par/Np y/N =/CH x/CH ;/CH Cài_đặt/V Disjoint/Np set/N với/E Mảng/N amp;/Np Vector_Ta/Np lưu/V vị_trí/N các/L viên/Nc sỏi/N trong/E một/M vector/Np (hoặc/Np mảng/N )/CH và/Cc mỗi/L khi/N có/V truy_vấn/Np yêu_cầu/V nhập/V hai/M hộp/N ,/CH ta/P bỏ/V các/L viên/Nc sỏi/N ở/E hộp/N có/V ít/A viên/Nc sỏi/N hơn/A vào/E hộp/N còn_lại/Np ./CH\nĐộ/N phức_tạp/A không/R cao/A vì/E với/E mỗi/L viên/Nc sỏi/N ,/CH tổng_số/N lần/N lấy/V và/Cc bỏ/V nó/P vào/E hộp/N chỉ/R tối_đa/A là/V log(n)/Np ./CH\nĐộ/N phức_tạp/A cho/E n/Ny thao_tác/V sẽ/R là/V O(nlog(n))/Np ./CH\nKhi/N cài_đặt/V DSU/Np ,/CH cách/N này/P không/R được/V sử_dụng/V (do/Np phức_tạp/A hơn/A cách/N trên)/Np ,/CH tuy_nhiên/C ý_tưởng/N này/P có_thể/R được/V áp_dụng/V cho/E nhiều/A bài/N khác/A ./CH\nCài_đặt/V Disjoint_Set/Np với/E Sets/Np (Cây/Np Đỏ_Đen;_Red-Black_Trees)/Np Một_cách/N khác/A là/V lưu/V chúng/P trong/E một/M cây_đỏ/Np đen/A (trong/Np C++/Np là/V set/N thư_viện/N STL/Np )/CH ./CH\nTa/P làm/V y_như/A đã/R làm/V với/E vectors/Np ,/CH độ/N phức_tạp/A sẽ/R là/V O(nlog2n)/Np ./CH\n(1/Np log/Np cho/E việc/N nhập/V vào)/Np ./CH\nBài_tập/Np :/CH (Phải/Np tham_gia/V nhóm/N ACM-OI/Np )/CH Hamro/Np amp;/Np Tools_TROY_Query/Np Tài_liệu/N tham_khảo/V :/CH Codeforces/Np\n", "title": "Disjoints Sets\n", "link": "http://vnoi.info/wiki/algo/data-structures/disjoint-set\n"}