Thuật toán Boyer Moore - Boyer Moore Algorithm
http://www.giaithuatlaptrinh.com/?p=245
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Thuật toán BoyerMoore (BM) là một thuật toán tìm kiếm xâu khá hiệu quả trong thực tế, tuy rằng về mặt lý thuyết, số phép so sánh trong trường hợp tồi nhất là  (không tốt hơn thuật toán ). Ta phát biểu lại bài toán tìm kiếm xâu như sau: Thuật toán BM gồm hai bước chính, bắt đầu từ vị trí  của văn bản :Như vậy, thuật toán BM sẽ đối sánh  và  theo chiều từ phải sang trái của . Liệu so sánh từ phải sang trái có tốt hơn từ trái sang phải như trong thuật toán trâu bò? Bằng cách áp dụng thêm luật kí tự tồi (bad character rule) và luật hậu tố tốt, thuật toán BM trong thực tế nhanh hơn hẳn thuật toán trâu bò. Trước hết chúng ta hãy xem xét ví dụ sau để hiểu luật này. Ví dụ:  và .Hi vọng ví dụ trên đã thuyết phục bạn rằng đối sánh thừ phải sang trái thực sự nhanh hơn từ trái sang phải. Tại bước 1 và 3 trong ví dụ trên, ta có thể dịch lên  đơn vị ở mỗi bước chỉ dùng 1 phép so sánh. Do đó, ta có thể suy ra trong trường hợp tốt nhất, ta chỉ cần  phép so sánh để tìm ra  trong .Luật kí tự tồi sẽ cho phép chúng ta xác định giá trị của  trong bước thứ 2 của thuật toán BM. Tại mỗi bước đối sánh một xâu con của  với , kí tự  gọi là  nếu không khớp xảy ra tại kí tự này . Trong ví dụ trên, tại  bước thứ 1, kí tự  là kí tự tồi. Hay trong bước 2, kí tự  là kí tự tồi. Mỗi lần bắt gặp một kí tự tồi, chúng ta dịch  theo luật sau: Dịch  lên một số  đơn vị sao cho kí tự tồi  khớp với kí tự  là kí tự xuất hiện gần với  nhất ( lớn nhất). Nếu  hoặc không tồn tại kí tự  như vậy thì ta dịch  lên 1.Áp dụng luật kí tự tồi vào bước thứ 2 của ví dụ trên,  (), ta dịch  lên  đơn vị sao cho  khớp với  vì  là kí tự xuất hiện gần với  nhất và khớp với  (). Do đó, ta phải dịch  lên  đơn vị. Để thực thi luật kí tự tồi, với mỗi kí tự , gọi  là vị trí xuất hiện của kí tự  gần với  nhất. Nếu , . Theo quy luật kí tự tồi, mỗi bước chúng ta sẽ dịch  một đoạn là:  Thủ tục  dưới đây cập nhật bảng  trong thời gian . Giả mã của thuật toán BM sử dụng luật kí tự tồi như sau:  
Code của giả mã bằng C: Xét ví dụ khi bạn đang so sánh một đoạn  của văn bản  nào đó với , bạn sẽ thấy không khớp xảy ra ở vị trí  (). Ta có kí tự khớp với  và gần  nhất là , theo luật kí tự tồi,  ta dịch  lên  đơn vị vì . Tuy nhiên ta có thể dịch  lên 3 đơn vị để  khớp với  (thay vì ). Luật kí tự tồi mở rộng phát biểu như sau: Dịch  lên một số  đơn vị sao cho kí tự tồi  khớp với kí tự  xuất hiện gần nhất bên trái của .Như vậy, với mỗi gía trị không khớp , ta phải tìm  lớn nhất sao cho:   và dịch  sao cho .Gọi  là bảng 2 chiều trong đó  tương ứng với   và vị trí xảy ra không khớp là  trong mẫu . Thủ tục  cập nhật bảng  trong thời gian  ( nếu số kí tự trong bảng chữ cái không nhiều). Thuật toán BM với luật kí tự tồi mở rộng như sau:  Code của giả mã bằng C:Chúng ta có thể tiết kiệm bộ nhớ  bằng cách thay bảng  bằng danh sách liên kết, mỗi danh sách cho một kí tự của  và mỗi danh sách của một kí tự lưu các vị trí xuất hiện của kí tự đó trong , sắp xếp theo chiều giảm dần của vị trí. Bằng phân tích khấu trừ như trong , chúng ta cũng có thể chứng minh rằng lưu trữ bằng danh sách liên kết như vậy tối đa sẽ mất thời gian  thuật toán  với mảng hai chiều  (không tính thời gian khởi tạo ).  Một cách khác là chúng ta cũng có thể thay thế danh sách liên kết bằng các cấu trúc khác để tăng thời gian tìm kiếm. Ở đây mình không đi sâu vào các vấn đề như vậy. Cũng như luật kí tự tồi, thời gian tiệm cận của thuật toán BM trong trường hợp xấu nhất vẫn không đổi và bằng .Chỉ sử dụng luật kí tự tồi không đủ để giảm thời gian tiệm cận của thuật toán BM và thực tế, thuật toán vẫn chưa đủ nhanh và khó mở rộng một cách hiệu quả ra trường hợp tìm tất cả sự xuất hiện của  trong . Ví dụ khi bạn muốn tìm tất cả các vị trí xuất hiện của xâu  ( kí tự ) trong  ( kí tự ). Kể cả áp dụng luật kí tự tồi mở rông, thời gian chaỵ vẫn là . Một luật nữa được đề xuất để cải tiến thuật toán đó là luật hậu tố tốt (good suffix rule). Phiên bản đầu tiên của luật hậu tố tốt vẫn có thời gian tồi nhất . Phiên bản mình trình bày ở đây bao gồm cả cải tiến của Galil [5] có thời gian  trong trường hợp tồi nhất. Luật hậu tố tốt chúng ta phát biểu trong phần này mạnh hơn phát biểu gốc cuả thuật toán Boyer-Moore [1]. Phát biểu gốc của thuật toán vẫn chưa đủ để chứng minh thời gian trong trường hợp tồi nhất là tuyến tính. Trước khi đi sâu vào phát biểu và thực thi luật hậu tố tốt, mình recommend bạn đọc  trước vì thực thi luật này sẽ sử dụng hàm  trong bước tiền xử lí. Luật hậu tố tốt khá dài và khó hiểu. Giả sử khi so sánh, một xâu con  của văn bản  khớp với hậu tố của mẫu , nhưng kí tự liền kề bên trái của  không khớp với kí tự tương ứng trong . Tìm một xâu con  (nếu có) phải nhất (right most-- gần với kí tự cuối  nhất) của  thỏa mãn:   không phải là hậu tố của  và  kí tự liền kề bên trái của  khác với kí tự liền kề bên trái của  hậu tố  của . Dịch  sao cho  khớp với  trong . Nếu  không tồn taị, dịch  một số lượng ít nhất sao cho:  Kí tự đầu tiên của  vượt quá kí tự đầu tiên của   và  tiền tố của  khớp với hậu tố của . Nếu không thể dịch  để thỏa mãn điều kiện đó, dịch  lên   đơn vị Trường hợp ta tìm tất cả sự xuất hiện của  trong , sau khi đã tìm thấy , ta dịch  một lượng ít nhất (> 0) sao cho tiền tố của  khớp với hậu tố của  trong . Trong trường hợp không thể dịch như vậy, dịch  lên  đơn vị.Có lẽ chỉ đọc luật thôi đã mệt rồi. Nếu bạn đọc một lần chưa hiểu thì .... đọc lại vậy. Xét ví dụ sau:  và  khi so sánh  với , nhận thấy , theo , ta có thể dịch  hoặc  đơn vị để khớp với . Tuy nhiên, theo , ta dịch sẽ dịch  đơn vị.Xét một ví dụ khác,  và , khi so sánh  với , nhận thấy .  không tồn tại trong trường hợp này, theo  ta dịch  ít nhất  đơn vị và theo , ta sẽ dịch  đơn vị. Trường hợp muốn tìm tất cả sự xuất hiện của  trong  khá dễ hiểu và có lẽ không cần thêm ví dụ.Trước hết ta chứng minh luật hậu tố tốt không bỏ sót bất kì kí tự nào. 
 Giả sử  thẳng hàng với  trước khi luật hậu tố tốt dịch  sang vị trí mới để  thẳng hàng với . Giả sử tồn tại  sao cho:Nếu  tồn tại, sẽ tồn tại   là xâu con của  gần  hơn  hiện tại khi  thẳng hàng với  hoặc tồn tại một tiền tố dài hơn của  khớp với hậu tố của . Do đó, luật hậu tố tốt sẽ dịch  sao cho  thẳng hàng với  thay vì .Trước hết để ý luật hậu tố tốt phát biểu chỉ phụ thuộc vào , do đó ta có thể áp dụng tiền xử lí để thực thi luật này (có gì đó hơi giống ). Nhận xét thấy  luôn là một hậu tố của . Trước hết ta thực thi  và  trong luật hậu tố tốt. Gọi  là vị trí lớn nhất nhỏ hơn  sao cho xâu  khớp với hậu tố của  và  là vị trí lớn nhất nhỏ hơn  sao cho xâu  khớp với  hậu tố của  và kí tự liền kề bên trái của hậu tố khớp trong  khác . Ví dụ: , Nếu ta đã tính được  và  với mọi , theo trường hợp (1) và (2) của luật hậu tố tốt, ta sẽ dịch  một đoạn là  ( là vị trí ngay trước vị trí xảy ra không khớp). Ta sẽ tìm cách tính  và  trong thời gian . Với mỗi , gọi  là chiều dài của hậu tố dài nhất của  khớp với hậu tố của . Nhắc lại: với một xâu , hàm Z của  có  là chiều dài của xâu con dài nhất của  bắt đầu từ  và khớp với một tiền tố của . Do đó gọi  là xâu đảo ngược của , ta có thể tính được  thông qua Z  của  như sau:  Ta có quan hệ sau giữa  và   như sau:   và  là chỉ số  lớn nhất sao cho:  Lemma 2 có thể được chứng minh trực tiếp từ định nghĩa của  và coi như bài tập cho bạn đọc. Ta có thuật toán sau tính : 
Code của giả mã bằng C:Bây giờ chúng ta chỉ cần phải thực hiện  và  trong luật hậu tố tốt và luật dịch khi ta muốn tìm tất cả các vị trí xuất hiện của  trong . Gọi  là chiều dài của hậu tố dài nhất (có thể có ) của  khớp với một tiền tố của . Nếu không tồn tại hậu tố như vậy, .
Dựa vào định nghĩa của , ta có  là số  lớn nhất sao cho . Ta có giả mã tính  trong thời gian  như sau: 
Code của giả mã bằng C:Tổng kết lại, gọi  là kí tự khớp cuối cùng khi so sánh  với một xâu con của  (). Ta sẽ dịch  một lượng  bằng:  Giả mã của thuật toán Boyer-Moore đầy đủ với luật kí tự tồi và luật hậu tố tốt: Code của giả mã bằng C:Nếu mẫu  không xuất hiện trong văn bản , Knuth, Morris and Pratt [4] chứng minh rằng thời gian tìm kiếm của thuật toán Boyer-Moore với luật kí tự tồi và hậu tố tốt là . Phiên bản đầu tiên của thuật toán Boyer-Moore [1] tìm tất cả sự xuất hiện của  trong  có thời gian trong trường hợp tồi nhất là . Galil [5] sửa đổi thuật toán Boyer-Moore tìm tất cả sự xuất hiện của  trong thời gian . Ở giả mã trên mình chỉ tìm một sự xuất hiện của . Code tìm sự tất cả sự xuất hiện của  được đính kèm ở dưới (mình sử dụng code này cho bài toán  trên spoj).  Trong trường hợp chỉ sử dụng luật kí tự tồi với văn bản đầu vào là các kí tự được sinh ngẫu nhiên, thời gian của thuật toán Boyer-Moore là  (sub-linear). Trong thực tế, thuật toán Boyer-Moore cũng có thời gian sub-linear, do đó, thuật toán này được ưu tiên sử dụng hơn các thuật toán khác. Code: , .[1] Boyer, Robert S., and J. Strother Moore. . Communications of the ACM 20.10 (1977): 762-772.
[2] Gusfield, Dan. . Cambridge university press, 1997.
[3] Sedgewick, R., Wayne, K. (2011). . Addison-Wesley. ISBN: 978-0-321-57351-3
[4] Knuth, Donald E., James H. Morris, Jr, and Vaughan R. Pratt.  Fast pattern matching in strings. SIAM journal on computing 6.2 (1977): 323-350.
[5] Galil, Zvi. . Automata, Languages and Programming. Springer Berlin Heidelberg, 1978. 241-250. , , Trackback link: Powered by  and 