Thuật toán Knuth-Morris-Pratt -- KMP string matching
http://www.giaithuatlaptrinh.com/?p=238
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong loạt bài này mình giới thiệu các thuật toán thao tác với các xâu kí tự. Chúng ta bắt đầu bằng bài toán cơ bản nhất: tìm sự xuất hiện của một xâu kí tự trong một văn bản. 
Ví dụ: đoạn văn bản  và xâu mẫu ,  xuất hiện ở vị trí 7 của văn bản . Trong ví dụ này bảng chữ cái  gồm các kí tự latin viết thường.Chúng ta bắt đầu với thuật toán trâu bò (brute force), đôi khi còn gọi là vét cạn. Các thuật toán trâu bò thường chậm tuy nhiên dễ thiết kế, cài đặt và thường là bước đầu tiên trước khi chúng ta phát triển các thuật toán cải tiến cao cấp hơn. Ý tưởng của thuật toán trâu bò khá đơn giản như sau: bắt đầu từ kí tự đầu tiên của văn bản , dịch dần xâu  về bên phải từng kí tự một. Nếu ta dịch đến kí tự thứ , so sánh  với . Nếu ta tìm thấy xâu mẫu, i.e,  , ta trả về vị trí . Nếu không ta tiếp tục dịch sang vị trí . Giả mã như sau: 
Code của thuật toán bằng C:Có thể thấy với mỗi vòng lặp, chúng ta mất tối đa  phép so sánh để kiểm tra xâu  có xuất hiện trong văn bản hay không. Do đó:     Thuật toán  được Knuth, Morris và Pratt phát triển vào năm 1977 là thuật toán tìm kiếm có thời gian tuyến tính . Thuật toán này chạy khá tốt trong thực tế, tuy nhiên cũng khá khó hiểu, vì thế khó gỡ lỗi. Trước hết mình trình bày một biến thể của thuật toán (biến thể này được trình bày trong [1]) với thời gian tính cỡ . Thuật toán này có hai điểm mạnh:  Mình khuyến khích bạn đọc thêm bài về để hiểu hơn về thuật toán KMP.Ý tưởng của thuật toán KMP dựa trên quan sát rằng trong thuật toán trâu bò có nhiều bước so sánh dư thừa. Cụ thể, khi so sánh phần tử  với , nếu , ta đã có thông tin:  Thuật toán trâu bò dịch sang  lên 1 đơn vị bằng cách và thiết lập biến chạy trên xâu mẫu  mà  thông tin này. Trong phần này, thay vì nói "dịch xâu mẫu lên  đơn vị" ta sẽ nói "lùi biến chạy  về vị trí ". Hai cách nói này về cơ bản là tương đương.Như vậy tại sao thông tin này lại có ích? Xét văn bản  và xâu mẫu  trong ví dụ đầu tiên.

Khi so sánh   với , chúng ta thấy hai xâu này không khớp tại vị trí  (). Thay vì thiết lập biến chạy  như trong thuật toán trâu bò, ta thiết lập   và tiếp tục so sánh  với . Cứ làm như vậy, thì mỗi vòng lặp biến chạy trên văn bản  luôn tăng và do đó thời gian tính toán sẽ là  nếu như ta có thể tính được vị trí cần lùi lại của biến chạy  trong thời gian . Tại sao trong ví dụ trên ta lại lùi biến chạy  về vị trí . Quan sát kĩ ta thấy chúng ta lùi  về vị trí  là do , tức là  kết thúc tại  của  khớp với  bắt đầu từ  của . Tổng kết lại, quy luật lùi biến chạy  như sau:: Lùi  về vị trí  sao cho tiền tố kết thúc tại  của  (chính là ) khớp với hậu tố bắt đầu tại  của  (chính là ) và độ dài của đoạn khớp này (chính là ) lớn nhất.Ta gọi kí tự  là kí tự . Trong ví dụ trên, nếu ta lùi lại  thì   khới với .  Nếu ta lùi lại  thì   khới với  và độ dài đoạn khớp này là . Tương tự, nếu ta lùi  thì   khới với  và độ dài đoạn khớp là . Theo luật trên, ta lùi  về vị trí sao cho độ dài đoạn khớp là lớn nhất, do đó, ta lùi . Nhận xét thấy vị trí lùi lại  phụ thuộc vào hai yếu tố:Trường hợp kí tự chốt  không xuất hiện trong , ta lùi lại  (hay nói cách khác ta dịch  lên  đơn vị). Ví dụ nếu  thì ta có thể dịch  lên  đơn vị. Dựa trên nhận xét trên, ta sẽ tính trước mảng  trong đó  là giá trị ta sẽ lùi lại nếu  là kí tự thứ  trong bảng chữ cái và vị trí xảy ra không khớp là  trong xâu mẫu . Ví dụ trong ví dụ trên  (tương đương với  nếu ) và , thì . Giả sử ta đã tính được bảng  bằng thủ tục  (ở dưới), thuật toán tìm xâu sẽ như sau: 
Code của giả mã bằng C:Với mỗi vòng lặp ta mất thời gian , do đó, tổng thời gian là  trong đó  là thời gian tính bảng . Để tính bảng , ta sử dụng chính ý tưởng lùi biến chạy ở trên kết hợp với quy hoạch động.Gọi  là mảng trong đó  là chỉ số  lớn nhất sao cho  khớp với . Gọi  là chỉ số của  trong bảng chữ cái .  và  có thể được tính thông qua  dựa trên công thức quy hoạch động sau:


  Khởi tạo  với mọi  và  (why ?). Giả mã như sau: 
Code của  giả mã bằng C:Do  và  chỉ phụ thuộc vào , ta có thể tiết kiệm một chút bộ nhớ bằng cách chỉ dùng một biến  thay vì dùng cả mảng . Dễ thấy thuật toán trên mất thời gian  để cập nhật bảng , do đó: Trong thuật toán trước, sự phụ thuộc thời gian vào kích thước bảng chữ cái dường như dễ hiểu vì kí tự chốt  có thể là bất kì kí tự nào trong bảng chữ cái. Để xóa bỏ sự phụ thuộc này, ta chọn kí tự chốt là . Do , kí tự  này luôn xuất hiện trong . Quy luật lùi biến chạy có thể phát biểu lại như sau:: Lùi  về vị trí  sao cho tiền tố kết thúc tại  của  (chính là ) khớp với hậu tố bắt đầu tại  của  (chính là ) và độ dài của đoạn khớp này (chính là ) lớn nhất.Sự khác biệt cơ bản giữa quy luật 1 và quy luật 3/2 đó là: sau mỗi lần lùi biến chạy , quy luật 1 luôn đảm bảo  và do đó ta tiếp tục xét kí tự tiếp theo . Còn quy luật 3/2 không đảm bảo điều này, do đó, sau mỗi lần lùi biến chạy , nếu , ta phải tiếp tục lùi biến chạy  một lần nữa (nghe hơi giống đệ quy). Dường như thuật toán này mất nhiều phép so sa nhơn thuật toán trước. Tuy nhiên, phân tích dưới đây chỉ ra rằng số lần lùi lại như vậy không nhiều.Do , quy luật trên có thể được phát biểu lại như sau:: Lùi  về vị trí  sao cho tiền tố kết thúc tại  của  (chính là ) khớp với hậu tố bắt đầu tại  của  (chính là ) và độ dài của đoạn khớp này (chính là ) lớn nhất.Trong ví dụ trên, nếu ta lùi lại  thì tiền tố  của    khới với hậu tố .  Nếu ta lùi lại  thì tiền tố  của   với hậu tố  của  và độ dài đoạn khớp này là . Tương tự, nếu ta lùi  thì   với  và độ dài đoạn khớp là . Theo luật trên, ta lùi  về vị trí sao cho độ dài đoạn khớp là lớn nhất, do đó, ta lùi .Theo quy luật 2, ta có thể thấy vị trí lùi lại  chỉ phụ thuộc vào vị trí xảy ra không khớp trong  (chính là ), không phụ thuộc vào . Gọi  là vị trí  phải lùi về khi . Giả sử ta đã tính được  bằng thủ tục  (ở dưới), thuật toán tìm xâu sẽ như sau: 
Code bằng C của giả mã:Giả sử thủ tục () sử dụng  phép so sánh, ta sẽ chứng minh rằng số phép so sánh của thuật toán  () là . Không dễ để có thể thấy được điều này vì sự xuất hiện vòng lặp while bên trong vòng lặp for. Trước hết ta thấy sau mỗi phép so sánh bằng (), cả  và  đều tăng lên 1. Do đó, số phép so sánh bằng tối đa là . Vòng lặp while giảm giá trị của  mỗi khi ta bắt gặp một phép so sánh không bằng (). Tuy nhiên, số lượng giảm của  không thể vượt quá giá trị mà  đã tăng lên (sau mỗi phép so sánh bằng) qua các vòng lặp trước đó. Điều đó có nghĩa là tổng số phép so sánh không bằng không thể vượt quá tổng số phép so sánh bằng, do đó, tối đa là . Như vậy, tổng số phép so sánh là . có thể được tính dựa vào định nghĩa của  và quy luật 2 trong thời gian . Cụ thể, để tính , ta sẽ kiểm tra tất cả các chỉ số  từ  đến  sao cho  khớp với  và chọn ra chỉ số  lớn nhất thỏa mãn điều kiện này. Tuy nhiên, Knuth-Morris-Pratt chỉ ra rằng bảng  có thể được tính trong thời gian  bằng cách sửa đổi thuật toán  đối sánh  với chính nó.   Code bằng C của giả mã:Tại sao đối sánh  với chính nó lại cho ra kết quả ta mong muốn. Về mặt trực quan, để ý quy luật 3/2, nếu thay  trong quy luật này bởi ,  và  bởi , giá trị  trong quy luật 3/2 chính là . Thủ tục   về cơ bản thực thi quy luật này, do đó, ta có thể sử dụng chính thủ tục này để tính .Một cách hiểu khác của thủ tục này là như sau: giả sử , ta biết rằng . Do đó, ta tìm các  , bắt đầu từ ứng viên lớn nhất (chính là ), sao cho:  Nếu  thì  chính là . Nếu , ứng viên tiếp theo sẽ là  (theo định nghĩa của bảng ), do đó ở dòng (*), ta gán . Do ta xét các ứng cử viên từ lớn đến nhỏ, giá trị tìm được sẽ tương ứng với đoạn khớp lớn nhất. Phân tích tương tự như trên, số phép so sánh trong thủ tục  là . Do đó, Ví dụ: bảng  ứng với mẫu  như sau: Code: , , 
[1] Sedgewick, R., Wayne, K. (2011). , Chapter 5. Addison-Wesley. ISBN: 978-0-321-57351-3
[2] Knuth, Donald E., James H. Morris, Jr, and Vaughan R. Pratt.  SIAM Journal on Computing 6.2 (1977): 323-350.
[3] Jeff Erickson, , UIUC.
[4] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 32. MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7 , , Trackback link: Powered by  and 