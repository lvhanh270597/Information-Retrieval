Cây khung nhỏ nhất: thuật toán Kruskal --- Kruskal Algorithm
http://www.giaithuatlaptrinh.com/?p=1140
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Thuật toán Kruskal là một thuật toán tham lam. Thuật toán sẽ duy trì một đồ thị con phi chu trình , gọi là một rừng (forest), của . Ban đầu, khởi tạo , i.e,  là tập chỉ gồm các đỉnh mà không có cạnh nào cả. Tại mỗi bước, thuật toán sẽ cố gắng thêm cạnh vào , để cuối cùng  sẽ là một cây khung. Do ta muốn tổng trọng số của  nhỏ nhất có thể, ta sẽ chọn cạnh cạnh có  nhỏ nhất, gọi là , trong số các cạnh  ở trong  và thêm vào . Sẽ có hai trường hợp:Tính chất (6) cho chúng ta biết thêm cạnh theo thứ tự tăng dần của trọng số như vậy  sẽ cho chúng ta cây khung nhỏ nhất.
Ví dụ: các bước chạy của thuật toán với đồ thị cho trong hình trên. Các cạnh màu đỏ là các cạnh nằm trong cây khung nhỏ nhất. Các cạnh màu xanh là các cạnh đã được xét và không nằm trong cây khung. Các cạnh màu xanh gạch ngang là cạnh sẽ được xem xét đưa vào cây khung trong bước tiếp theo. Thứ tự các cạnh được xét là theo chiều tăng dần của trọng số.Giả mã: Tạm thời chưa quan tâm đến thời gian thực thi .  Câu hỏi đầu tiên mà ta quan tâm đó là: thuật toán  có thực sự trả về cây khung nhỏ nhất? Để trả lời câu hỏi này, ta sẽ trả lời một loạt câu hỏi (dễ hơn) sau.Đồ thị  đầu ra của  có phải là chu trình hay không? Câu trả lời là  vì điều kiện trong dòng màu đỏ luôn đảm bảo điều này.Đồ thị  đầu ra của  có phải là một cây hay không? Ta đã biết  không có chu trình, do đó, nó sẽ là cây nếu liên thông (chỉ có duy nhất một thành phần liên thông). Giả sử đầu ra không liên thông,  sẽ có ít nhât hai thành phần liên thông (mỗi thành phần liên thông có thể chỉ là 1 đỉnh). Chọn hai thành phần liên thông  của , sao cho tồn tại một cạnh của  nối hai thành phần này. Ta luôn chọn được  vì  liên thông. Gọi  là cạnh có trọng số nhỏ nhất nối . Cạnh  này không thuộc  vì nếu không  sẽ là chỉ là một thành phần mà thôi. Nhưng khi kiểm tra điều kiện ở dòng màu đỏ,  rõ ràng không có chu trình. Điều đó có nghĩa ta sẽ thêm  vào trong  ngay sau đó. Điều này trái với giả sử  không thuộc . Do đó  phải liên thông, i.e,  là một cây.Giờ ta sẽ chứng minh: 
 Gọi  là một cây khung nhỏ nhất của  sao cho số cạnh chung giữa  và  là lớn nhất. Nếu  thì rõ ràng  là một cây khung nhỏ nhất. Do đó, giả sử . Gọi  và  lần lượt là thứ tự các cạnh của  và  sắp xếp theo chiều tăng của trọng số. Gọi  là chỉ số nhỏ nhất sao cho cạnh  và cạnh  là hai cạnh khác nhau. Theo cách chọn , ta suy ra  và . Do đó,  không có chu trình.Ta sẽ có , vì nếu không, dòng màu đỏ trong thuật toán sẽ kiểm tra cạnh   kiểm tra cạnh , và do  không có chu trình,  sẽ được thêm vào  trước . Hay nói cách khác,  chính là cạnh thứ  của ; trái với giả thiết .   Xét đồ thị .  sẽ có một chu trình . Chu trình  có hai tính chất sau:Gọi ;  là một cây (tại sao?). Do , . Từ đó suy ra  cũng là một cây khung nhỏ nhất. Nhưng rõ ràng  có số cạnh chung với  nhiều hơn . Điều này trái với giả thiết  là cây khung nhỏ nhất có số cạnh chung nhiều nhất với . Như vậy, , i.e,  là cây khung nhỏ nhất.Phần khó thực thi nhất của thuật toán   có lẽ là dòng màu đỏ. Theo tính chất (1) của cây khung,  có tối đa  cạnh, do đó,  có tối đa  cạnh. Dòng màu đỏ thực ra có thể quy về bài toán:Kiểm tra xem một đồ thị có chu trình hay không?Ta có thể giải bài toán này bằng bất kì thuật toán  nào (BFS/DFS). Do đó, ta có thể thực hiện dòng màu đỏ trong thời gian , qua đó thu được thuật toán . Tuy nhiên, ta muốn thực hiện nhanh hơn thế.Ta nhận xét thấy trong mỗi bước trung gian,  là một rừng, i.e, mỗi thành phần liên thông của  là một cây. Phép kiểm tra xem  có chu trình hay không tương đương với kiểm tra xem hai đầu mút, gọi là , của  có thuộc cùng một cây trong rừng  hay không.Giờ nếu biểu diễn mỗi cây trong  bằng cấu trúc tập hợp. Các đỉnh thuộc cùng một cây khi và chỉ khí nó nằm trong cùng một tập. Thao tác (a) sẽ tương đương với so sánh  và . Thao tác (b) sẽ tương đương với . Các bạn xem thêm . Do đó, ta có thể viết lại thuật toán  như sau: Để thực thi giả mã trên, chúng ta có thể sử dụng biểu diễn dạng ma trận kề hay danh sách kề. Tuy nhiên, trong giả mã trên, không có truy vấn dạng "tìm hàng xóm của một đỉnh". Do đó, ta có thể sử dụng cấu trúc danh sách cạnh để biểu diễn đồ thị (gọi là danh sách chứ thực ra ta có thể dùng một mảng các struct, mỗi struct biểu diễn một cạnh). Phép biểu diễn này cho phép chúng ta có thể gọi thủ tục sắp xếp cạnh một cách dễ dàng. Trong Code dưới đây, mình sử dụng danh sách cạnh để cài đặt.Code C: Sắp xếp các cạnh của đồ thị theo trọng số mất thời gian  (vd sử dụng ). Như ta đã biết, mỗi thao tác của cấu trúc Union-Find (kết hợp nén đường đi) mất thời gian  trong đó  là  ngược. Hàm này có giá trị  với mọi giá trị thực tế của . Do đó, vòng lặp for (có chứa dòng màu đỏ) sẽ mất thời gian . Do đó, tổng thời gian của thuật toán là . Trong cấu trúc Union-Find, giả sử ta có một tập  gồm  phần tử. Ta muốn có một cấu trúc dữ liệu biểu diễn các tập con không giao nhau (disjoint subsets) của . Cấu trúc này hỗ trợ các thao tác sau:Mỗi tập hợp con của , ta sẽ dùng một cây để biểu diễn. Mảng  sẽ biểu diễn cấu trúc cây này. i.e,  nếu như  là nút cha của  trong cây (biểu diễn tập hợp chứa ). Do đó, để kiểm tra xem hai phần tử  có trong cùng một cây hay không, ta chỉ việc tìm xem nút gốc của cây biểu diễn có trùng nhau hay không. Trong thực thi dưới đây, ta sẽ sử dụng nén đường đi. Về cơ bản, khi ta đã tìm được gốc, gọi là , của cây chứa nút , ta đặt luôn , để các phép tìm gốc sau đó của  sẽ nhanh hơn.Để hợp 2 cây, ta sẽ hợp theo hạng (rank) và ta sẽ dùng một mảng . Về mặt trực quan, khi gộp 2 cây, ta nên gộp cây có độ sâu (depth) nhỏ hơn vào cây có độ sâu lớn hơn vì làm như vậy, chiều sâu của cây không tăng lên tối đa 1 sau khi gộp, và do đó, các phép tìm gốc sau này sẽ nhanh hơn. Hạng là một chỉ số, về mặt trực quan (nhưng không hoàn toàn), đo xem cây nào có chiều sâu nhỏ hơn cây nào. Do đó, ta sẽ gộp cây của nút có hạng nhỏ hơn vào cây của nút có hạng lớn hơn.Giả mã:  
 
Code C:Code đầy đủ: .[1] Kruskal, Joseph B.  Proceedings of the American Mathematical society 7.1 (1956): 48-50.
[2] Prim, Robert Clay.  Bell System Technical Journal 36.6 (1957): 1389-1401.
[3] Borůvka, Otakar (1926). . Elektronický Obzor (in Czech) 15: 153–154.
[4] Nešetřil, Jaroslav, Eva Milková, and Helena Nešetřilová.  Discrete Mathematics 233.1 (2001): 3-36.
[5] Karger, David R.; Klein, Philip N.; Tarjan, Robert E. . Journal of the ACM 42 (2): 321–328, 1995.
[6] Jeff Erickson. . UIUC, 2014.  , , , Trackback link:  on                     Thank you share itPowered by  and 