Cây khung nhỏ nhất: thuật toán KKT -- KKT Algorithm
http://www.giaithuatlaptrinh.com/?p=1297
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Thuật toán KKT, là thuật toán ngẫu nhiên tìm cây khung nhỏ nhất với xác suất cao trong thời gian tuyến tính được phát triển bởi Klein, Karger và Tarjan[1]. Ý tưởng của thuật toán này rất đẹp, và hi vọng bài này sẽ truyền tải được cái đẹp đó đến các bạn. Nội dung kiến thức của bài viết này có thể coi ở mức độ cao cấp, do đó nhiều chi tiết đơn giản mình sẽ bỏ qua. Bạn đọc nếu chưa từng đọc các bài viết trước về cây khung nhỏ nhất thì xin xem lại các bài viết đó  trước khi đọc tiếp.   Trong bài viết này, mình sẽ giải sử trọng số của các cạnh là duy nhất, i.e, không có hai cạnh nào có trọng số giống nhau. Trong bài , mình đã đưa ra cách để thực hiện giải thuyết này với đồ thị đầu vào bất kì trong thời gian tuyến tính. Mình khuyến khích bạn đọc xem lại. Với giả sử này, .Giả sử bạn tung một đồng xu với xác suất mặt ngửa là  (do đó xác suất mặt sấp là ). Bạn muốn tung đồng xu đó đến khi nào bạn thu được một mặt ngửa. Gọi  là số lần tung cần thiết. Khi đó, ta có phân phối:  Phân phối của  được gọi là phân phối hình học (). Kì vọng của phân phối này là:  Tính chất này mình không chứng minh mà gợi ý bạn đọc xem tại . Từ đó ta có hệ quả:  
Bài toán trên gọi là bài toán xác nhận cây khung nhỏ nhất (MST Verification). Khác với bài toán cây khung nhỏ nhất, bài toán này có thể được giải quyết trong thời gian tuyến tính . Giải thuật không đơn giản và ý tưởng cũng không quá đẹp. Xem [2,3] để biết thêm chi tiết. Sau đây mình sẽ đưa ra mấy tính chất cơ bản của cây khung mà các thuật toán xác nhận áp dụng. Gọi  là một rừng (forest) của đồ thị . Với mỗi cặp đỉnh  của , gọi  là trọng số của cạnh (có trọng số) lớn nhất trên đường đi (duy nhất) từ  đến  trong . Quy ước nếu  thuộc hai cây khác nhau của  thì . Cạnh  được gọi là  nếu  >  và được gọi là  nếu ngược lại. Ta có một số nhận xét:Giải thuật của King[2] cho chúng ta Theorem sau: Để xác nhận cây khung  có phải là nhỏ nhất không, ta áp dụng Theorem 1 để tìm tất cả các cạnh -heavy của đồ thị. Nếu tập trả về là rỗng, cây  sẽ là cây khung nhỏ nhất, và ngược lại nếu tập trả về là khác rỗng (tại sao?).  Do đó ta có: Thuật toán KKT trực tiếp áp dụng thuật toán Borůvka và giải thuật xác nhận cây khung nhỏ nhất của King (Theorem 1). Chúng ta đã biết thuật toán Borůvka tìm cây khung nhỏ nhất bằng cách lặp lại 2 thao tác sau cho đến khi đồ thị chỉ còn một đỉnh:Ta gọi 2 thao tác trên là một Borůvka-step. Sau mỗi Borůvka-step, ít nhất  cạnh sẽ bị co, và do đó, số đỉnh của đồ thị giảm ít nhất một nửa.  Từ đó suy ra số vòng lặp của thuật toán Borůvka là . Do đó, tổng thời gian của thuật toán là O((V+E)\log V) vì mỗi bước co có thể được thực hiện trong thời gian .Giả sử đồ thị sau mỗi bước đều thưa ( với hằng số  nào đó) thì thời gian của thuật toán Borůvka là:   trong đó  là tổng số vòng lặp của thuật toán Borůvka. Do đó, thời gian của thuật toán là tuyến tính. (Trong trường hợp đồ thị phẳng thì đồ thị sau mỗi bước của thuật toán Borůvka đều thưa, do đó, thuật toán là tuyến tính).Tuy nhiên, sau một số bước co cạnh, đồ thị sẽ trở nên dày hơn. Giải quyết vấn đề này chính là cái hay của thuật toán KKT. Thuật toán KKT sẽ xóa đi một số cạnh dư thừa, i.e, các cạnh mà ta biết chắc chúng không nằm trong cây khung nhỏ nhất. Sau khi xóa, đồ thị lại trở nên thưa và do đó, tiếp tục áp dụng thuật toán Borůvka. Phân tích ở trên chỉ ra rằng, thời gian cuối cùng sẽ là tuyến tính. (Nice!).Làm thế nào xóa được các cạnh dư thừa. Xem lại Theorem 1. Các cạnh -heavy (của bất kì rừng  nào đó) sẽ là  dư thừa. Xóa các cạnh dưa thừa đó đi thì chỉ còn các cạnh -light trong đồ thị. Thuật toán KKT sử dụng ngẫu nhiên để tìm ra rừng  sao cho số cạnh -light là nhỏ. Do đó, đồ thị sau khi xóa cạnh -heavy là thưa. Chi tiết như sau:Gọi  là đồ thị thu được bằng cách lấy mẫu (sampling) mỗi cạnh của đồ thị với xác suất . Hay nói cách khác, với mỗi cạnh của , ta tung một đồng xu có xác suất mặt ngửa là . Nếu đồng xu là ngửa thì ta thêm cạnh đó vào , và không làm gì cả nếu đồng xu có mặt sấp. Gọi  là rừng khung nhỏ nhất của  (gọi là rừng khung vì  có thể không liên thông). Ta có:  Ta sẽ sử dụng thuật toán Kruskal để chứng minh (các bạn nên xem lại thuật toán này). Giả sử ta sắp xếp các cạnh của  theo trọng số giảm dần. Khởi tạo  và  rỗng. Với mỗi cạnh  (theo thứ tự đã sắp xếp), ta tung một đồng xu (có mặt ngửa xác suất ). Nếu đồng xu có mặt ngửa thì ta thêm  vào . Nếu   là -light thì ta thêm vào . Sau khi quá trình kết thúc,  chính là rừng khung nhỏ nhất của  (quá trình thêm cạnh vào  chính là thuật toán Kruskal). Nên nhớ các cạnh -heavy trong  thì cũng là -heavy trong . Do đó, các cạnh này là dư thừa. Ta giờ phân loại đồng xu thành 2 loại: loại 5k và loại 1k. Nếu cạnh  là -heavy trong  thì đồng xu mà ta tung là loại 1k, và ngược lại là loại 5k. Loại đồng xu 1k sẽ không liên quan gì đến số cạnh -light cuối cùng trong  vì cho dù nó là mặt sấp hay ngửa thì cạnh đó vẫn là cạnh dư thừa. Ta chỉ cần đếm xem có bao nhiêu loại 5k ta đã tung. Nên nhớ rừng  có tối đa  cạnh. Theo Corollary 1, với kì vọng tung tối đa  lần, ta sẽ thu được rừng  (những cạnh với đồng xu 5k mà không thuộc  sẽ là các cạnh -light của ). Do đó, số cạnh -light tối đa trong  là .Tổng hợp tất cả những gì ta đã thảo luận, ta thu được giải thuật sau:   Trong giải thuật KKT, chúng ta 2 lần gọi đệ quy, một lần trên  và một lần trên . Gọi  là thời gian tính toán của thuật toán trên đồ thị gốc , với  lần lượt là số đỉnh, cạnh của đồ thị. Chú ý do thuật toán là ngẫu nhiên,  là một biến ngẫu nhiên. Ta sẽ tính kì vọng .Nhận xét thấy: kì vọng số đỉnh và cạnh của đồ thị  lần lượt là  và . Kì vọng số đỉnh của  là  và kì vọng số cạnh (theo Theorem 2) là . Chú ý ở đây ta áp dụng 2 bước Borůvka nên số đỉnh giảm đi còn tối đa  sau hai bước này. Ngoại trừ 2 thủ tục đệ quy, các thao tác khác trong thuật toán KKT đều có thể tính được trong thời gian tuyến tính. Gọi thời gian đó là  với  là một hằng số. Ta có:  Ta sẽ chứng minh  bằng quy nạp. Thật vậy, từ ,  ta có: 
 Do đó, ta có:  Trong [1], các tác giả còn chứng minh được rằng thời gian chạy của thuật toán là  với xác suất ít nhất . Mình khuyến khích bạn đọc tham khảo thêm.[1] Karger, David R., Philip N. Klein, and Robert E. Tarjan.  Journal of the ACM (JACM) 42.2 (1995): 321-328.
[2] King, Valerie.  Algorithmica 18.2 (1997): 263-270.
[3] Hagerup, Torben.  International Workshop on Graph-Theoretic Concepts in Computer Science. Springer Berlin Heidelberg, 2009. .
[4] Uri Zwick. . Tel Aviv University, 2013. , , , , Trackback link: Powered by  and 