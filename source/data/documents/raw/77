Cây khung nhỏ nhất: thuật toán Borůvka -- Borůvka Algorithm
http://www.giaithuatlaptrinh.com/?p=1204
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Đây là bài thứ 3 trong loạt bài về cây khung nhỏ nhất. Mình khuyến khích bạn đọc xem lại bài thuật toán Kruskal và thuật toán Prim . Một số tính chất của cây khung mình không nhắc lại ở đây nữa.Thuật toán Borůvka có lẽ là một trong số những thuật toán có "tuổi đời" khá lớn trong các thuật toán mà mình blog. Thuật toán được phát triển bởi [1] Otakar Borůvka năm 1926. Trọng tâm của thuật toán này là phép  (edge contraction), một trong ba phép phổ biến (xóa cạnh, xóa đỉnh và co cạnh) hay áp dụng trong lý thuyết đồ thị. Hình dưới đây minh họa một phép co cạnh. Hình (3) là đồ thị thu được sau khi co cạnh màu đỏ trong hình (1)

Phép co một cạnh còn có thể được mở rộng ra một tập cạnh. Gọi  là một tập  cạnh. Đồ thị  thu được sau phép co tập cạnh , kí hiệu là , là đồ thị thu được sau  lần liên tục co lần lượt các cạnh trong  (thứ tự cạnh nào được co trước, co sau không quan trọng).Hình dưới đây minh họa một phép co  một tập cạnh. Hình (3) là đồ thị thu được sau khi co tập cạnh màu đỏ trong hình (1)

Phép co cạnh thì có liên quan gì đến cây khung? Thực ra hai thuật toán Kruskal và Prim mà chúng ta tìm hiểu ở hai bài trước đều có thể được nhìn dưới góc độ phép co cạnh. Lấy thuật toán Kruskal làm ví dụ. Thuật toán Kruskal ban đầu sắp xếp các cạnh theo thứ tự tăng dần của trọng số, sau đó xét từng cạnh theo thứ tự đã sắp xếp và thêm cạnh vào rừng (kết quả trung gian là một rừng (forest) chứ không phải cây) hiện tại. Nếu thêm cạnh đó vào mà không tạo ra chu trình của rừng hiện tại thì ta thêm. Nếu không, ta xét cạnh tiếp theo.  Mình khuyến khích bạn đọc xem lại ví dụ trong bài trước . Nhìn dưới góc độ của phép co cạnh, ta sẽ thực hiện thuật toán Kruskal bằng một câu như sau: Tìm cạnh có trọng số nhỏ nhất và co.Ví dụ thực hiện ý tưởng trên cho đồ thị được minh họa trong hình dưới đây. Chú ý khi co cạnh với đồ thị có trọng số, ta sẽ giữ lại cạnh có  trong số các cạnh song song. Thứ tự các cạnh được co màu đỏ cũng chính là thứ tự các cạnh được thêm vào cây khung trong thuật toán Kruskal.  Thuật toán Borůvka có ý tưởng tương tự như trên. Để phát biểu thuật toán, ta sẽ cần thêm khái niệm  (safe edge): 
Chú ý cụm từ . Ví dụ cạnh màu đỏ trong (1) là cạnh an toàn ứng với đỉnh  nhưng không phải là cạnh an toán ứng với đỉnh . Các cạnh màu đỏ trong (2) là tập các cạnh an toàn.
Để việc mô tả thuật toán trở nên đơn giản, ta sẽ giả thiết: Không có hai cạnh nào của đồ thị đầu vào  có cùng trọng số. Ta sẽ sử dụng giả thiết này để chứng minh tính đúng đắn của thuật toán Borůvka. Cuối bài ta sẽ thảo luận phương pháp để loại bỏ giả thiết này. Thuật toán Borůvka có thể được mô tả đơn giản bằng một câu sau: Tìm, thêm vào cây khung và co tất cả các cạnh an toàn cho đến khi đồ thị chỉ còn một đỉnh.Ví dụ với đồ thị hình dưới đây, thuật toán Borůvka chỉ cần 3 bước để tìm ra cây khung (là tập các cạnh màu đỏ bị co).Giả mã: Thực thi giả mã trên khá phức tạp. Trước khi đi vào chi tiết, chúng ta thử phân tích tính đúng đắn và thời gian thực hiện của thuật toán. Ta sẽ chứng minh tập các cạnh trả về  ở cuối thuật toán là cây khung nhỏ nhất. Dễ thấy  phải là liên thông vì  cuối cùng chỉ là một đỉnh. Để chứng minh  là một cây, ta sẽ chứng minh tập các cạnh an toàn  mà ta đưa vào tập  trong mỗi bước không chứa chu trình. Thật vậy, giả sử  là một chu trình của .  Theo định nghĩa của cạnh an toàn, ta có  < . Không mất tính tổng quát, ta giả sử  < . Do  là cạnh an toàn và  < , ta suy ra  < . Lập luận tương tự, ta có:  <  < <  <    <  Đó là điều không thể xảy ra. Như vậy  phải là một cây.Để chứng minh  có trọng số  nhỏ nhất, ta dựa vào nhận xét: cạnh  là an toàn khi và chỉ khi nó là cạnh nhỏ nhất của ít nhất một trong 2 lát cắt . Theo tính chất (số 6 tại ) của cây khung nhỏ nhất, cạnh an toàn phải nằm trong cây khung nhỏ nhất. Do đó, tập cạnh an toàn mà ta thực hiện co tại mỗi bước phải nằm trong cây khung nhỏ nhất của đồ thị tại bước đó. Điều này đã đủ để kết luận tập cạnh an toàn sẽ nằm trong cây khung nhỏ nhất của ?  Thực ra là chưa. Chúng ta cần thêm một tính chất nữa đó là: nếu  là cây khung nhỏ nhất của  thì  là cây khung nhỏ nhất của . Chứng minh tính chất này không khó và coi như bài tập cho bạn đọc.Do đó, đầu ra  là cây khung nhỏ nhất của đồ thị.  
 Mỗi lần ta co một tập cạnh  trong mỗi bước lặp, số đỉnh của đồ thị giảm đi ít nhất một nửa. Số đỉnh giảm đúng một nửa khi và chỉ khi  là một cặp ghép hoàn hảo (). Do đó, sau  bước lặp, số đỉnh của đồ thị chỉ còn lại 1. Lúc này vòng lặp  kết thúc.Nhiệm vụ còn lại của chúng ta là thực thi đoạn code trong vòng lặp while. Nếu chúng ta thực hiện được trong thời gian  thì, theo Lemma 1, chúng ta sẽ thu được thuật toán .Trước hết chúng ta sẽ nghiên cứu xem làm thế nào để thực thi phép co cạnh. Có 2 cách thực thi thường được dùng:Cách đầu tiên thì thường ít được dùng vì nó liên quan đến việc sửa đổi đồ thì và chúng ta cũng có thể "cảm nhận" thấy co cạnh theo cách đầu tiên "thực sự" phức tạp và có thể mất thời gian lên tới  cho mỗi thao tác co cạnh. Mặc dù ta có thể mở rộng cách đầu tiên ra để co  với thời gian , thực hiện co thực sự vẫn là một thao tác tốn kém. Lợi thế của cách thực thi này là kích thước của đồ thị thực sự giảm sau mỗi phép co. Điều này có ý nghĩa về mặt lý thuyết, như Eisner [3] đã chỉ ra (trang 19), độ phức tạp của thuật toán  với thực thi co cạnh thực sự là . Thuật toán này thực sự nhanh hơn các thực thi của Kruskal và Prim mà chúng ta đã tìm hiểu trong blog này.Với cách thứ hai, co một cạnh tương ứng với gọi thao tác  và thao tác kiểm tra xem  có thuộc cùng một tập hay không tương ứng với  . Cấu trúc này có thể được thực thi kiểu danh sách hoặc bằng cây (các bạn xem lại bài ). Trong thuật toán , chúng ta sẽ không thực sự thực hiện Union-Find giống như thuật toán Kruskal mà thực hiện sử dụng mảng nhãn (chi tiết xem tại dưới đây), vì cách thực thi này đơn giản hơn mà có cùng (thậm chí tốt hơn) thời gian tiệm cận. Một vấn đề nữa là ta không thực sự xóa cạnh/đỉnh khỏi đồ thị, do đó, sau khi co cạnh, kích thước của đồ thị không thay đổi. Ta cần phải chú ý điều này khi phân tích các thuật toán với phép co cạnh hàm ẩn. Ở đây ta có hai đồ thị: đồ thị gốc và đồ thị thu được sau khi đã co một (tập) cạnh. Ta sẽ gọi đỉnh và cạnh của đồ thị co (tại bước hiện tại của thuật toán) lần lượt là  và .  Đỉnh co thực chất là một tập hợp các đỉnh còn cạnh co thực chất là cạnh của đồ thị với trọng số nhỏ nhất trong số các cạnh song song giữa hai đỉnh co. Sự nhập nhằng giữa 2 đồ thị này có thể làm thuật toán hơi khó hiểu một chút và mình sẽ cố gắng viết rõ ràng nhất có thể. Mọi câu hỏi xin để lại ở phần comment.Ta sẽ dùng một mảng nhãn  để biểu diễn các đỉnh sau khi đã thực hiện co cạnh. Cụ thể,  nếu  thuộc đỉnh co  trong đồ thị co. Ban đầu, ta khởi tạo . Ta sẽ sử dụng thêm một biến  để đếm số đỉnh trong đồ thị hiện tại sau khi đã co. Nhãn của các đỉnh sẽ có giá trị từ  tới . Ta sẽ không biểu diễn đồ thị co một cách trực tiếp, mà sẽ thao tác với nó thông qua nhãn của các đỉnh của đồ thị gốc. Ta sẽ lần lượt thực thi từng dọng trong vòng lặp  của thuật toán  ở trên.Để tìm các cạnh an toàn, ta sẽ duyệt qua tất cả các cạnh của đồ thị co bằng cách duyệt qua các cạnh của đồ thị gốc . Với mỗi đỉnh co , ta sẽ lưu một số  và một cạnh (của đồ thị gốc)  trong đó,   nếu cạnh co nhỏ nhất kề với  mà ta phát hiện tại bước duyệt cạnh hiện tại có trọng số , và  nếu  là cạnh của đồ thị gốc tương ứng với cạnh co nhỏ nhất kề với  đó. Khi duyệt cạnh , ta sẽ:Mảng cạnh  chính là các cạnh an toàn của đồ thị co. Chú ý là có thể  với hai đỉnh co  khác nhau. Do đó, trước khi trả lại M, ta sẽ xóa các cạnh trùng lặp.
Dễ thấy thao tác này có thể thực hiện trong thời gian . Giả mã: 
Code C:Ta sẽ biểu diễn rừng trung gian bằng danh sách kề. Do đó, để đưa mỗi cạnh vào rừng hiện tại, ta chỉ việc xét mỗi cạnh trong tập  và cập nhật danh sách kề. Code C:Co tập cạnh thực chất là cập nhật lại nhãn của các đỉnh. Để cập nhật lại nhãn ta duyệt  (dùng BFS hay DFS) để gán cho đỉnh của mỗi thành phần liên thông của  một nhãn. Cuối cùng ta cập nhật lại biến , là số thành phần liên thông của . Thao tác này có thể thực hiện trong thời gian .  
Code C:Như vậy ta đã thực thi được vòng lặp  một cách trọn vẹn. Việc còn lại là chúng ta ghép mọi thứ lại với nhau. Dễ thấy, trong thực thi ở trên, mỗi thủ tục con mất thời gian . Ta có:  Trong thuật toán Borůvka là mỗi vòng lặp, ta có thể thực hiện co tập các cạnh an toàn cùng một lúc. Do đó, ta có thể dễ dàng song song hóa thuật toán Borůvka. Nếu biểu diễn rừng trung gian  bằng danh sách cạnh, bước thêm cạnh vào rừng đơn giản chỉ là thêm phần tử vào một danh sách. Tuy nhiên, khi đó ta không thể dùng BFS hay DFS để gán lại nhãn trong bước co tập cạnh (DFS và BFS với biểu diễn d.s cạnh mất thời gian bình phương). Mặc dù vậy, ta có cách khác để gán lại nhãn trong thời gian . Mình không trình bày phương pháp này ở đây vì nó chỉ là vấn đề kĩ thuật và có khi làm phức tạp thêm bài toán. Chi tiết cụ thể coi như bài tập cho bạn đọc.Phần này ta sẽ thảo luận phương pháp để loại bỏ giả thiết trọng số duy nhất ở trên. Tại sao ta cần các cạnh có trọng số duy nhất? Xét đồ thị tam giác, với 3 cạnh bằng nhau dưới đây.
Theo định nghĩa của cạnh an toàn, bất kì cạnh nào cũng có thể là cạnh an toàn tương ứng với các đỉnh đầu mút. Do đó, bước tìm cạnh an toàn có thể trả về tập cạnh là cả 3 cạnh này. Hay nói cách khác, tập  trong giả mã có thể chứa chu trình, và khi thêm  vào ,  không còn là một cây nữa. May mắn là trường hợp này chỉ xảy ra khi đồ thị có một chu trình mà tất cả các cạnh trong chu trình bằng nhau ( bạn có thể chứng minh?). Đây cũng là chìa khóa để chúng ta giải quyết trường hợp cạnh của đồ thị có trọng số  duy nhất.Ta sẽ định nghĩa một cạnh  có trọng số  "nhỏ hơn" một cạnh  nếu một trong ba trường hợp sau xảy ra.Ta kí hiệu "nhỏ hơn" là . Với định nghĩa như vậy, áp dụng vào đồ thị tam giác trên ta sẽ có thứ tự:  Giả mã: Như vậy, không có bất kì hai cạnh nào có cùng trọng số theo thứ tự mới này, và do đó, ta đã biến trọng số của đồ thị đầu vào thành duy nhất. Trong code đầy đủ được attach dưới đây, ta sẽ sử dụng ý tưởng này để giải thuật đúng với cả trường hợp đồ thị trọng số không duy nhất.Code đầy đủ: .
[1]  Borůvka, Otakar (1926). "Příspěvek k řešení otázky ekonomické stavby elektrovodních sítí (Contribution to the solution of a problem of economical construction of electrical networks)". Elektronický Obzor (in Czech) 15: 153–154.
[2] Jeff Erickson. . UIUC, 2014.
[3] Jason Eisner. , University of Pennsylvania, 1997.
[4] Uri Zwick. .  Tel Aviv University, 2013. , , , Trackback link: Powered by  and 