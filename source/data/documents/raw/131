Máy trạng thái hữu  hạn và thuật toán KMP
http://www.giaithuatlaptrinh.com/?p=687
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Các máy trạng thái hữu hạn (-FSM) thông thường được định nghĩa khá phức tạp, tùy thuộc vào ngữ cảnh ứng dụng. Định nghĩa ở đây mình gắn luôn với bài toán tìm kiếm xâu, do đó, có đôi chút khác biệt so với các định nghĩa thông thường. Nhắc lại, trong bài toán tìm kiếm xâu, ta có một văn bản (text) biểu diễn bới xâu  và một mẫu (pattern) biểu diễn bởi xâu . Ta muốn tìm vị trí xâu  xuất hiện trong văn bản . Chi tiết các bạn xem thêm ở các bài viết khác trong cùng mục tìm kiếm xâu .  Máy trạng thái hữu hạn biểu diễn xâu mẫu  là một  có  nút sắp xếp trên một đường thẳng và được đánh số từ  đến . Giữa nút thứ  và , , có một cạnh có hướng được gọi là  (success edge). Cạnh khớp này có nhãn là kí tự  của xâu . Mỗi nút , ngoại trừ nút  và nút thứ , còn có một cạnh  hướng ra khác được gọi là . Nút  có cạnh không khớp tới nút . Các cạnh không khớp khác nối nút thứ  với một nút thứ  nào đó với . Ví dụ về một máy trạng thái hữu hạn với  được biểu diễn bởi hình dưới đây. Các cạnh có nhãn màu xanh là các cạnh khớp. Các cạnh màu đỏ (không có nhãn) là các cạnh không khớp. 

  Mình sẽ giải thích tại sao các cạnh màu đỏ lại xuất hiện trong hình trên theo thứ tự như vậy ngay sau đây. Tạm thời bây giờ chưa cần chú ý đến nó vội. Bạn đọc hãy quan sát kĩ hình vẽ và tự đối chiếu với các khái niệm trong định nghĩa máy trạng thái hữu hạn. Ta nhận thấy nhãn của các cạnh màu xanh khi gộp lại chính là xâu . Hơn nữa, nếu ta gộp nhãn của các cạnh từ nút  tới nút thứ  thì ta thu được tiền tố  của . Nếu quan sát kĩ hơn thì ta có thể thấy rằng:  Nút  có một cạnh không khớp tới nút  () khi và chỉ khi  là số lớn nhất nhỏ hớn  sao cho  là hậu tố của . Ví dụ nhìn vào hình trên ta thấy nút  có một cạnh không khớp tới nút  vì  là hậu tố của . Bạn đọc nên dành thời gian để kiểm tra luật trên với các nút khác. Bây giờ ta sẽ biến luật cạnh không khớp trên thành giải thuật để xác định các cạnh không khớp. Hiển nhiên với mỗi , ta chỉ cần duyệt từ  cho đến khi tìm được  thỏa mãn luật cạnh không khớp. Như vậy, ta có thể xây dựng cạnh không khớp cho nút  trong thời gian , do đó: Tuy nhiên, ta có thể sử dụng  để xây dựng cạnh không khớp nhanh hơn. Gọi  là mảng trong đó  nếu có một cạnh không khớp từ nút  tới nút  ( < ). Ta có . Giả sử ta đã tính được . Làm sao ta có thể tính được ? (bạn đọc nên tự suy nghĩ một lúc trước khi xem lời giải dưới đây).Nếu , ta suy ra   là hậu tố của  (theo luật cạnh không khớp). Do đó nếu  thì ta chỉ cần gán  (hình (a) trong hình minh họa dưới đây). Ví dụ trên với , ta thấy  và , do đó ta gán . Tuy nhiên, cuộc sống không có dễ dàng vậy nếu . Trong trường hợp này, ta sẽ phải xét  và lại so sánh  với . Chú ý ở đây   là hậu tố của , do đó, nó cũng là hậu tố của  vì ta đã biết  là hậu tố của .  Từ đó suy ra nếu  , ta sẽ gán  (xem hình (b) trong hình minh họa dưới đây). Nếu không ta sẽ tiếp tục lặp lại như trên. Trường hợp xấu nhất, đến một lúc nào đó ta sẽ trở về vị trí  sau  bước (tại sao?) với một số  nào đó, và do đó, ta sẽ gán  vì hiển nhiên  (theo quy ước) là một hậu tố của . 
Ta có thuật toán sau: 
Code C:Việc chứng minh (bằng quy nạp) rằng nếu nếu  được gán bằng số  nào đó theo thuật toán trên thì  là số lớn nhất nhỏ hơn  thỏa mãn tính chất của luật cạnh không khớp coi như bài tập cho bạn đọc. Mặc dù  không có trong định nghĩa, ta vẫn thêm vào mảng  phần tử   để cho việc viết giả mã sáng sủa hơn.   Thông qua mảng , ta đã "biểu diễn" ngắn gọn được toàn bộ máy trạng thái hữu hạn. Ngoài ra, nếu tinh ý, các bạn sẽ phát hiện ra rằng thuật toán xây dựng cạnh không khớp trên chính là thuật toán tính hàm Failure trong .  Nếu bạn đọc đã đọc phân tích của hàm Failure , có thể dễ dàng nhận thấy thời gian của thuật toán này là . Ở đây mình nhắc lại ngắn gọn ý tưởng: độ phức tạp của thuật toán có cùng tiệm cận với số phép so sánh bằng và số phép so sánh không bằng. Mỗi lần so sánh bằng () thì ta tăng cả hai biến  và  lên . Mỗi lần so sánh không bằng () thì ta lại giảm . Do số lần ta giảm  không thể vượt quá số lần ta tăng , số phép so sánh không bằng sẽ nhỏ hơn số phép so sánh bằng. Do đó, độ phức tạp của thuật toán có cùng tiệm cận với số phép so sánh bằng và là . 
Khi so sánh hai xâu  và , ta sẽ so sánh từng kí tự. Vấn đề mấu chốt là chúng ta sẽ xử lí như thế nào nếu  () khi ta đang so sánh hai kí tự tương ứng trong văn bản và trong xâu mẫu.  sẽ lùi một số đơ vị là  và tiếp tục so sánh  với . Do đó trong trường hợp xấu nhất, số phép so sánh là . Tuy nhiên, ta có thể nhận xét thấy là nếu ta đang so sánh  với , có nghĩa là . Hay nói cách khác,  là  của . Do đó, nếu , ta chỉ cần đi theo cạnh không khớp của nút  để lùi về nút . Theo luật cạnh không khớp,  là hậu tố của  và do đó cũng là hậu tố của  . Hay nói cách khác, . Do đó, ta chỉ cần so sánh  với  và đệ quy. Dựa vào những quan sát này, ta có thuật toán sau:    Code C:Phân tích thuật toán (giống như phân tích khi xây dựng FSM) coi như bài tập cho bạn đọc. Như vậy máy trạng thái hữu hạn cho chúng ta một cách nhìn khác và đơn giản hơn về thuật toán KMP.  Tuy nhiên, nếu chỉ có thể thì cũng không thể nói lên được hết tầm quan trọng của máy trạng thái hữu hạn trong tìm kiếm xâu. Trong bài tiếp theo, mình sẽ trình bày ứng dụng khác của máy trạng thái hữu hạn trong tìm kiếm đa mẫu (multiple patterns) mà cụ thể là thuật toán Aho-Corasick [2]. Code đầy đủ: .
[1]  Knuth, Donald E., James H. Morris, Jr, and Vaughan R. Pratt. . SIAM Journal on Computing 6.2 (1977): 323-350.
[2] Aho, Alfred V., and Margaret J. Corasick.  Communications of the ACM 18.6 (1975): 333-340.
[3] Jeff Erickson. , UIUC, 2014. , , , , Trackback link:  on                     trong chứng minh lemma1 : cái chỗ
Nếu F[i−1]=j0F[i−1]=j0, ta suy ra P[1,…,j0]P[1,…,j0] là hậu tố của P[1,2,i−1]P[1,2,i−1] (theo luật cạnh không khớp). Do đó nếu P[j0+1]=P[i]P[j0+1]=P[i] thì ta chỉ cần gán P[i]=j0+1   (ý của anh chỗ này là F[i]=j0+1 phải ko anh ) tại em lấn cấn chỗ này ,, mong anh giúp em thêm với ạ,,,,thank anh , on                     Đúng rồi đó bạn. Ý mình là . Mình gõ bị lỗi. Cám ơn bạn đã spot giúp.HùngPowered by  and 