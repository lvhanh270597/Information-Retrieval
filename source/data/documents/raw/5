Thuật toán  McCreight xây dựng cây hậu tố --  McCreight Algorithm
http://www.giaithuatlaptrinh.com/?p=451
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong , chúng ta đã làm quen với cây hậu tố (suffix tree) và thuật toán đơn giản xây dựng cây hậu tố trong thời gian . Mình khuyến khích bạn đọc xem lại các khái niệm của bài trước. Một số khái niệm mình sẽ không nhắc lại ở đây. Trong bài này chúng ta sẽ làm quen với thuật toán McCreight xây dựng cây hậu tố trong thời gian  giả sử bảng chữ cái có kích thước . Thuật toán McCreight được đề xuất vào năm 1976 bởi McCreight đơn giản hóa thuật toán  trước đó đề xuất bởi Weiner. Ngoài thuật toán McCreight, thuật toán Ukkonen xây dựng cây hậu tố cũng có thời gian  và có thể được áp dụng trong trường hợp online, có nghĩa là chúng ta có thể cập nhật lại cây hậu tố khi có thêm các kí tự mới. Tuy nhiên, so với thuật toán Ukkonen, thuật toán McCreight đơn giản hơn. Chúng ta sẽ làm quen với thuật toán Ukkonen trong bài sau.Mình nhắc lại khái niệm cây hậu tố ở đây: Ý tưởng của thuật toán McCreight có thể được coi là cải tiến của  sử dụng liên kết hậu tố (suffix link). Mỗi nút trong của cây hậu tố xây dựng trong thuật toán MacCreight ngoài các trường cơ bản  như đã mô tả ở  còn có thêm một trường là  (định nghĩa dưới đây), kí hiệu là .    Goi  là một nút trong với  trong đó  là kí tự đầu tiên trong  và  là một xâu ( có thể là một xâu rỗng).Hai trường hợp ở trên được minh họa ở hình dưới đây. Đường màu đỏ có mũi tên biểu diễn liên kết hậu tố:

Ví dụ xâu  có cây hậu tố và các liên kết hậu tố như hình sau:

Nếu coi nút gốc có liên kết hậu tố trỏ tới chính nó thì nhìn vào hình trên, ta sẽ thấy mọi nút trong đều có đúng 1 liên kết hậu tố. Tính chất này không dễ thấy nếu chúng ta chỉ nhìn vào định nghĩa của liên kết hậu tố.  
 Dựa vào định nghĩa của cây hậu tố và liên kết hậu tố, nếu một nút trong  có liên kết hậu tố tới một nút , nút  đó phải là duy nhất. Do đó, chúng ta chỉ cần chứng minh tồn tại nút  như vậy. Nút trong  được tại thành là do khi chèn hậu tố , với một số  nào đó thỏa mãn ,  là tiền tố của  và là xâu con chung lớn nhất (gọi tắt là tiền tố con chung lớn nhất) của  với cây hậu tố . Thêm nữa,  phải là tiền tố của một hậu tố  nào đó với . Xét , rõ ràng  là một tiền tố con chung  với cây hậu tố sau khi đã chèn . Giả sử nút  với  chưa tồn tại khi nút  được thêm vào cây hậu tố. Do  là tiền tố con chung lớn nhất của  với cây hậu tố hiện tại,  sẽ là tiền tố con chung lớn nhất của  với cây hậu tố . Do đó, nút  sẽ được tạo ra khi chièn , từ đó suy ra dpcm. Nếu một nút trong  được tạo ra khi chèn hậu tố , liên kết hậu tố của  có thể được cập nhật ngay tại bước sau đó.Tại sao liên kết hậu tố lại hữu dụng? Về mặt trực quan, nếu ta chèn hậu tố  có tiền tố con chung lớn nhất với cây hiện tại là  thì tiền tố chung lớn nhất của  và  ít nhất có chiều dài . Do đó, khi chèn , ta chỉ cần đi theo liên kết hậu tố để tiết kiệm được  phép so sánh kí tự so với thuật toán đơn giản. Thuật toán thực hiện trong  bước, bước thứ  chèn hậu tố  vào cây hiện tại . Việc chèn hậu tố  phụ thuộc vào bước trước. Khi chúng ta chèn :Để minh họa cho hai trường hợp trên, ta sẽ xét hai ví dụ được minh họa bởi hình dưới đây. Ví dụ thứ nhất (hình  của hình dưới đây), ta xây dựng cây hậu tố cho xâu . Khi chèn hậu tố  vào cây hậu tố , ta sẽ tìm thấy một nút  đã có liên kết hậu tố (như ở hình vẽ) và chèn nút lá tương ứng với hậu tố thứ 11 vào cây . Khi chèn , ta đi theo liên kết hậu tố của  đến nút , gọi là , và bắt đầu tìm so sánh  với cây con gốc tại . Trong trường hợp của ví dụ trong hình, ta chỉ việc tạo thêm một nút lá là con của  và gán hậu tố  là con của nút .Ví dụ thứ hai, khi ta chèn hậu tố  vào cây hậu tố , ta sẽ tìm được một nút  (như trong hình) và bẻ cạnh giữa  và nút cha  của nó để thêm một nút . Sau đó tạo một nút lá là con của  và gán  vào nút lá đó. Tiếp theo đó, ta chèn  . Lúc này nút  chưa có liên kết hậu tố, ta sẽ đi theo liên kết hậu tố của  để đến một nút  (như trong hình vẽ) và tìm kiếm  bắt đầu từ cây con gốc .  Tuy nhiên, ta đã biết trước đoạn khớp sẽ  là  do nhãn của cạnh  có chiều dài . Do đó, ta có thể nhảy cóc 2 nút như mũi tên trong hình vẽ để chèn . Cuối cùng, ta sẽ cập nhật liên kết hậu tố của .Trong giả mã dưới đây,  lưu giữ nút cần cập nhật liên kết hậu tố. Biến  lưu giữ nút cuối của liên kết hậu tố ở bước trước. Do đó, tại dòng  của giả mã dưới đây, ta luôn tìm kiếm bắt đầu từ nút  thay vì từ gốc. Biến  lưu giữ độ dài ít nhất của đoạn khớp khi tìm kiếm . Độ dài này ta tính được trong bước thứ  khi chèn . Quy luật cập nhật  đã được chỉ ra ở trên. Thủ tục () sẽ tìm kiếm đoạn khớp của  với cây con gốc tại  của cây hậu tố hiện tại khi biết trước độ dài đoạn khớp ít nhất là . Thủ tục này trả lại nút  sao cho tiền tố chung lớn nhất là xâu con của , độ dài vị trí khớp cuả  và vị trí khớp của văn bản. Xem thêm tại  với hàm tương tự  (). Điểm khác biệt chính với thủ tục () ở bài trước là ta kết hợp cập nhật liên kết hậu tố trong quá trình tìm kiếm.Giả mã của thuật toán như sau:  Code của giả mã bằng C. Code đầy đủ được đính ở cuối bài:Hàm  trả lại  nếu  và 0 nếu ngược lại. Các thủ tục khác của giả mã không trình bày ở đây tương tự như trong .  Việc phân tích thuật toán trên có thể được tách thành hai thành phần sau: tổng số phép so sánh kí tự (vòng while ở dòng ) và số lần "nhảy cóc" ( lệnh if ở dòng ). Do phép nhảy cóc, mỗi kí tự của văn bản được so sánh đúng 1 lần. Do đó tổng số phép so sánh kí tự là . Phần khó nhất là phân tích số lần "nhảy cóc". Với mỗi nút  của cây hậu tố, gọi  là số nút trong đường đi từ gốc tới  của cây hậu tố trừ đi 1. Ta có nhận xét sau: Do đó, nếu ta nhảy cóc  lần tại bước , nút  lại có  tăng lên  so với tree depth của nó tại bước thứ . Do  với mọi , tổng số lần nhảy cóc là không quá . Do đó ta có:   Code: [1] Weiner, Peter.  Switching and Automata Theory, 1973. SWAT'08. IEEE Conference Record of 14th Annual Symposium on. IEEE, 1973.
[2] McCreight, Edward M.  Journal of the ACM (JACM) 23.2 (1976): 262-272.
[3] Ukkonen, Esko. . Algorithmica 14.3 (1995): 249-260.
[4] Aluru, Srinivas.  Handbook of Data Structures and Applications (2004). , , , , Trackback link:  on                     Đã không viết thì thôi, viết thì viết cho đàng hoàng chứ. on                     Hi bạn,
Xin lỗi vì bạn có những trải nghiệm không hay với blog. Nếu bạn có comment cụ thể phần nào bạn cảm thấy chưa hài lòng thì xin để lại. Mình sẽ sửa cho bài viết chuẩn hơn!HùngPowered by  and 