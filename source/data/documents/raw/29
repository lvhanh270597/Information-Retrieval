Mảng hậu tố-- Suffix Array
http://www.giaithuatlaptrinh.com/?p=488
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Nhưng đã giới thiệu ở , cây hậu tố là một cấu trúc dữ liệu rất mạnh để thực hiện nhiều truy vấn văn bản với thời gian . Tuy nhiên, điểm yếu chính của cây hậu tố là bộ nhớ lớn do mỗi nút của cây phải lưu nhiều thông tin, mặc dù về mặt lý thuyết là . Nếu thực thi cây hậu tố tốt thì mỗi kí tự cũng phải mất trung bình bộ nhớ 20 bytes. Như vậy nếu ta có 1GB text thì cần 20GB bộ nhớ cho cây hậu tố.Mảng hậu tố (suffix array) được giới thiệu bởi Manber và Mayer [1] năm 1993 như là một thay thế cho cây hậu tố. Điểm mạnh của mảng hậu tố là tiết kiệm được nhiều bộ nhớ. Ngoài ra, nếu kết hợp mảng hậu tố với một vài mảng thông tin khác như mảng tiền tố chung lớn nhất (mảng LCP - Longest Common Prefix) thì có thể thực hiện hậu hết các truy vấn như cây hậu tố với cùng thời gian [5]. Do những lợi ích đó mà mảng hậu tố được rất nhiều nhà nghiên cứu quan tâm và rất nhiều giải thuật được phát triển để xây dựng cây hậu tố.  Trong [4], các tác giả phân loại hàng chục thuật toán cũng như các phân tích thời gian và bộ nhớ. Mình đính kèm phân loại đó ở phần phụ lục. Cho văn bản  với các kí tự trong bảng chữ cái . Ta quy ước $ là kí tự nhỏ nhất thuộc bảng chữ cái  và chỉ xuất hiện duy nhất một lần trong . Văn bản  có  hậu tố trong đó hậu tố thứ  là . Ta tập hợp các hậu tố thành một mảng . Để sử dụng mảng này thực hiện các truy vấn, thông thường ta muốn mảng này được . Do đó, ta sẽ gán  nếu hậu tố  (gọi là hậu tố thứ ) có vị trí thứ  trong mảng  hậu tố đã sắp xếp. Mảng  gọi là .Ví dụ: ,  mảng hậu tố của  như sau: 
Theo bảng trên,  có nghĩa là hậu tố thứ  (là ) đứng thứ 2 trong mảng các hậu tố đã sắp xếp theo thứ tự từ điển. Do $ là kí tự nhỏ nhất trong  theo thứ tự từ điển, ta luôn có . Đi kèm với mảng hậu tố là , gọi tắt là . Mảng LCP, kí hiệu là , là mảng trong đó  là chiều dài của tiền tố chung dài nhất của hai hậu tố  và . Giá trị  không xác định và quy ước là . Với ví dụ trên  vì chiều dài tiền tố chung dài nhất của hậu tố  (là ) và  (là ) là .Thuật toán đơn giản nhất ta có thể nghĩ tới để xây dựng mảng hậu tố là liệt kê tất cả các hậu tố và sau đó sắp xếp các hậu tố theo thứ tự từ điển. Có tất cả  hậu tố của xâu , do đó, sắp xếp các hậu tố có thể thực hiện trong  phép so sánh (ví dụ QuickSort). Do so sánh hai hậu tố có thể thực hiện trong thời gian , ta có thể xây dựng mảng hậu tố trong thời gian . Nếu bằng cách nào đó, chúng ta chỉ mất thời gian  cho mỗi phép so sánh hai hậu tố, chúng ta sẽ thu được thuật toán . Phần này mình giới thiệu hai thuật toán khác nhau thực hiện ý tưởng so sánh đó.Phương pháp này được trình bày trong lecture note [2]. Trước khi đọc tiếp, mình khuyến khích bạn đọc xem lại bài tìm kiếm xâu với thuật toán . Ý tưởng chính của thuật toán Rabin-Karp là biến mỗi xâu con thành một số nguyên không quá lớn (ví dụ 64 bit) sử dụng phép băm và việc so sánh hai xâu con được quy về so sánh hai số nguyên với thời gian . Giả sử (bằng cách nào đó mà ta sẽ mô tả sau) chúng ta có thể kiểm tra xem hai xâu con của văn bản  có bằng nhau hay không trong thời gian . Để so sánh hai hậu tố  và  của , ta sẽ sử dụng tìm kiếm nhị phân trong thời gian  để tìm số  sao cho:   và Khi đã tìm được , ta chỉ cần so sánh  và . Do đó, phép so sánh  hai hậu tố được thực hiện trong .Để phép kiểm tra hai xâu con có bằng nhau hay không trong thời gian , ta sẽ thực hiện tiền xử lí. Ta sẽ sử dụng hàm băm  trong đó  là một số nguyên tố được chọn ngẫu nhiên trong khoảng . Ta chọn ngẫu nhiên để đảm bảo, về mặt lý thuyết, xác suất đụng độ nhỏ (xem lại phân tích trong bài ). Trong thực tế ta chỉ cần chọn một số nguyên tố lớn. Ví dụ trong [2], tác giả chọn . Gọi  là cơ số, thường chọn là số kí tự trong bảng chữ cái. Gọi  là mảng trong đó . Định nghĩa mảng  như sau (quy ước ):  Mảng  và  có thể tính được trong thời gian  sử dụng . Ta chuyển mỗi xâu con  của  thành một số nguyên  (giá trị hash) có dạng:  Dễ thấy:  Do đó, giá trị  với  bất kì có thể tính được trong thời gian  nếu biết  và . Từ đó suy ra ta có thể kiểm tra xem hai xâu con có bằng nhau hay không trong thời gian  bằng cách so sánh hai giá trị hash. Giả mã như sau:   
Code của giả mã bằng C. Code đầy đủ được đính ở cuối bài.Với hai hậu tố cho trước, sửa đổi thủ tục   một chút, ta có thể tính được chiều dài tiền tố chung lớn nhất trong thời gian . Do đó, ta có thể xây dựng mảng LCP trong thời gian . Chi tiết coi như bài tập cho bạn đọc. Tổng kết lại ta có: Thuật toán nhân đôi tiền tố (prefix doubling) được đề xuất bởi Uber và Mayer [1] có thời gian  sử dụng thuật toán đếm phân phối. Trong phần này mình trình bày một biến thể [2]  sử dụng Quick Sort. Trước hết coi văn bản đầu vào  có chiều dài vô hạn bằng cách thêm vào cuối văn bản  vô hạn kí tự $. Gọi văn bản vô hạn là . Chú ý là $ là kí tự nhỏ hơn ( theo thứ tự từ điển) tất cả các kí tự khác trong bảng chữ cái   và chỉ xuất hiện trong văn bản  đúng một lần tại vị trí cuối cùng. Do  vô hạn, với mỗi số  ta có đúng  xâu con của  chiều dài , mỗi xâu bắt đầu bằng một kí tự của . Thuật toán thực hiện theo  bước như sau:Ta có nhận xét sau: Thứ tự của các xâu con thu được sau bước cuối cùng chính là thứ tự đã sắp xếp của các hậu tố bắt đầu bằng kí tự đầu tiên của các xâu con đó.Nhận xét đó là do các kí tự $ là kí tự nhỏ nhất theo thứ tự từ điển. Chi tiết chứng minh của nhận xét đó coi như bài tập cho bạn đọc. Ta sẽ chứng minh rằng nếu sử dụng Quick Sort để sắp xếp thì mỗi bước của thuật toán có thể được thực thi trong thời gian . 
 Bước đầu tiên ta có thể thực hiện trong thời gian  sử dụng Quick Sort. Tại bước thứ , ta sẽ sắp xếp các xâu con có độ dài  sử dụng Quick Sort. Để ý rằng tại bước , ta đã có thứ tự tương đối giữa các xâu con độ dài . Nếu coi xâu con độ dài  là ghép của hai xâu con độ dài , xâu con độ dài  thứ nhất gọi là  và xâu con độ dài  thứ hai gọi là , thì ta chỉ việc so sánh hai khóa cua hai xâu độ dài  thay vì so sánh trực tiếp. Do đó, việc so sánh có thể thực hiện trong thời gian  thay vì . Như vậy ta sẽ có thuật toán .Tuy nhiên, đó vẫn chưa phải là tất cả chúng ta cần. Ta cần thêm một cách mã hóa để mã hóa vị trí tương đối giữa các xâu con. Do mỗi bước ta có đúng  xâu con, ta gán cho mỗi xâu con một số trong tập   để khi so sánh hai xâu, ta chỉ cần so sánh hai số tương ứng. Chú ý là hai xâu giống nhau ta phải gán cho hai số giống nhau. Ta có thể làm như sau:Tại bước , sau khi sắp xếp, mỗi xâu độ dài  sẽ được gán cho một số là vị trí của nó trong mảng đã sắp xếp. Ta sẽ thực hiện duyệt qua mảng để một lần để gán lại, đảm bảo . Bước duyệt này chỉ mất . Như vậy, ta có thể thực hiện mỗi bước trong thời gian Trước khi trình bày giả mã của thuật toán, mình sẽ nói qua đôi chút về tổ chức dữ liệu (theo [2]). Với mỗi xâu con  độ dài , ta sẽ lưu 3 giá trị:Ta cũng sử dụng mảng hai chiều  trong đó hàng  lưu mã của xâu con bắt đầu từ  độ dài  như mô tả trong chứng minh của Lemma 1.Giả mã như sau: 
Code của giả mã bằng C. Code đầy đủ được đính kèm ở cuối bài:Dựa vào mảng , ta có thể tính được chiều dài cuả tiền tố chung dài nhất của hai hậu tố trong thời gian  bằng cách chia nhị phân. Do đó, mảng LCP có thể tính được trong thời gian . Giả mã như sau: 
Code của giả mã bằng C:  Mình khuyến khích bạn đọc code và submit bài tại . Cả hai thuật toán trên sẽ được khoảng 60 điểm. Code submit mình đính kèm dưới đây.Code đầy đủ của giả mã: , ,, . 
[1] Manber, Udi, and Myers, Gene.  Siam Journal on Computing 22.5 (1993): 935-948.
[2] Daniel Sleator. . CMU, Fall 2012.
[3] Vladu, Adrian, and Cosmin Negruşeri.  (2005).
[4] Puglisi, Simon J., William F. Smyth, and Andrew H. Turpin.  ACM Computing Surveys (CSUR) 39.2 (2007): 4.
[5] Abouelhoda, Mohamed Ibrahim, Stefan Kurtz, and Enno Ohlebusch.  Journal of Discrete Algorithms 2.1 (2004): 53-86.
[6] Kasai, Toru, Gunho Lee, Hiroki Arimura, Setsuo Arikawa, and Kunsoo Park.  In Combinatorial pattern matching, pp. 181-192. Springer Berlin Heidelberg, 2001.Phân loại các thuật toán xây dựng mảng hậu tố [4]: , , , Trackback link:  on                     Wow! This could be one particular of the most helpful blogs We have ever arrive across on this subject. Actually Fantastic. I am also an expert in this topic therefore I can understand your effort.Powered by  and 