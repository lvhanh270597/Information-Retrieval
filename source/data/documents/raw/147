Cấu trúc Union-Find -- Union-Find data structure
http://www.giaithuatlaptrinh.com/?p=218
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Nếu bạn đã từng thực thi thuật toán Kruskal tìm cây khung nhỏ nhất, chắc bạn sẽ biết cấu trúc union-find. Đó là một trong số rất nhiều ứng dụng của cấu trúc này. Trong phần này mình trình bày cấu trúc đó góc độ một cấu trúc dữ liệu để lưu trữ các tập hợp rời nhau (disjoint sets). Do đó, cấu trúc này còn gọi là . Bài toán của chúng ta như sau:Hãy thiết kế một cấu trúc dữ liệu cho thuật toán  sao cho các thao tác này được thực hiện một cách hiệu quả nhất.
 Trong cấu trúc này, mỗi tập hợp được lưu trữ bởi môt danh sách liên kết, và mỗi phần tử của danh sách sẽ có một con trỏ  chỉ đến đầu của danh sách (có thể coi là id của danh sách vì mỗi phần tử chỉ xuất hiện trong tối đa 1 danh sách).

Các thao tác () và () có thể được thực hiện trong thời gian  như sau: 
 
Với cấu trúc lưu trữ này, ta có thể thực hiện thao tác gộp hai tập  với chiều dài tương ứng  trong thời gian  như sau: Ta có thể áp dụng một vài kĩ thuật như sau để cải tiến ý tưởng của thuật toán ở trên:Do đó: Ở đây chú ý là chúng ta phải thay đổi thủ tục () khởi tạo thông tin  và contrỏ  (chi tiết coi như bài tập). Giả mã của thao tác  như sau: 
Thao tác union được minh họa trong hình dưới đây:
Trong trường hợp xấu nhất, ta sẽ mất thời gian  để gộp hai danh sách có kích thước cỡ . Tuy nhiên, những trường hợp như vậy sẽ "không thường xuyên" xảy ra vì sau khi gộp ta thu được danh sách kích thước .   Nếu phân tích kĩ hơn ta sẽ thấy trung bình mỗi thao tác () chỉ tốn cỡ . 
 Dễ thấy  bước union sẽ thao tác trên tập  có kích thước  vì mỗi thao tác union chỉ thao tác trên tối đa  phần tử mới. Xét một phần tử , ta sẽ phân tích xem bao nhiêu lần con trỏ  của  được cập nhật. Từ bổ đề 1, mỗi lần cập nhật con trỏ , kích thước của tập hợp chứa  tăng lên ít nhất 2 lần. Do đó, con trỏ  của  được cập nhật tối đa  lần. Từ đó, ta thu được định lý 1.Từ định lý 1, ta thu được hệ quả sau: 
Do đó, có thể coi thời gian "khấu trừ" (amortized time) của mỗi thao tác  là . Trong cấu trúc cây, mỗi tập hợp sẽ được biểu diễn bởi một cây và mỗi nút của cây có một con trỏ chỉ tới một nút cha (parent -- người viết không có ý phân biệt cha/mẹ, chỉ là thấy nghe cha "xuôi hơn"). Id của tập hợp là id của nút gốc của cây. Ngoài ra, gốc của mỗi cây lưu thông tin  là chiều cao của cây biểu diễn tập hiện tại. Trong cấu trúc cây, thao tác  vẫn có thời gian hằng số , tuy nhiên thao tác  sẽ không còn là hằng số nữa. Sự linh động đó cũng dẫn đến nhiều phương pháp cải tiến cấu trúc này. Trước hết mình trình bày cấu trúc cây đơn giản, là cơ sở cho các cải tiến sau này. Hai thao tác  và  trong cấu trúc cây như sau:  
Để phép  được hiệu qủa, chúng ta thiết kế sao cho chiều cao của cây càng nhỏ càng tốt. Mặt khác chúng ta phải duy trì cấu trúc cây sao cho phép  thực hiện được hiệu qủa. Trong cấu trúc cây, phép  sẽ gộp cây có chiều cao nhỏ vào cây có chiều cao lớn hơn (gốc của cây nhỏ hơn sẽ trở thành nut con của gốc của cây lớn hơn). Khác với cấu trúc danh sách, trong cấu trúc cây, chúng ta không cần phải thay đổi con trỏ của các nút của cây khi gộp ngoại trừ nút gốc, do đó, phép  có thể được thực hiện nhanh hơn. Giả mã như sau: 
 
 Gọi  là cây có chiều cao lớn nhất . Có thể chứng minh được bằng quy nạp số lượng nút trong cây có gốc  ít nhất là . Do đó .Ý tưởng cải thiện cấu trúc cây cơ bản như sau: mỗi lần thực hiện thao tác (), ta kết hợp với cập nhật con trỏ của các nút trên đường đi từ nút  tới nút gốc  của cây chứa  để trỏ tới nút gốc. Không khó để nhận thấy nếu thao tác () mất thời gian  thì việc thêm thao tác cập nhật con trỏ trên đường đi (còn gọi là nén đường đi -- path compression) mất thời gian . Do đó, về mặt tiệm cận, thời gian của thao tác () không thay đổi.  

Do kết hợp với nén đường đi mỗi lần tìm kiếm, thông tin  của nút gốc sẽ bị thay đổi. Cập nhật thông tin này rất tốn kém. Do đó, ta có thể thay đổi một chút, thay vì gộp cây theo độ sâu (depth), ta sẽ gộp cây theo . Thủ tục  và  vẫn tương tự như trường hợp cây cơ bản.   
Một số tính chất của hạng chúng ta có thể liệt kê ra như sau: 
Tính chất cuối cùng không dễ để nhận thấy, tuy nhiên chúng ta có thể lập luận như sau: để ý thấy nếu một nút thay đổi hạng từ  lên  (trường hợp này xảy ra khi gộp hai cây có gốc có cùng hạng ), cây mới có ít nhất  nút. Theo tính chất 2, hạng của các nút không phải là gốc sẽ không bao giờ thay đổi, ta có thể gán cho mỗi nút  hạng  một tập hợp  chứa  có kích thước . Do với hai nút  có cùng hạng , . Do đó, có tối đa  nút có hạng .Ta sẽ phân tích thời gian tính toán của thao tác  vì thao tác  tốn thời gian bằng 2 thao tác  cộng với một hằng số. Trước hết ta định nghĩa hàm .   
Hàm  tăng cực chậm, với , , do đó, có thể coi thực tế  nhỏ hơn hoặc bằng  ( mới có cỡ ~ hạt cơ bản). Một hàm tăng chậm khác dùng trong phân tích union-find là hàm Ackerman ngược, kí hiệu . Hàm này còn chậm hơn rất nhiều so với hàm . Tarjan [4] chứng minh rằng mỗi thao tác find trong cấu trúc cây kết hợp nén đường đi có thời gian khấu trừ . Trong bài này, mình chứng minh kết quả yếu hơn:  
 Ta có thể tính thời gian cho mỗi thao tác () bằng cách đếm "chi phí" như sau:Cuối cùng,  phải trả chi phí là số tiền mà nó nợ. Nếu  ở độ sâu càng lớn, chi phí  phải trả cuối cùng càng nhiều. Tuy nhiên, sau khi đã thực hiện thao tác find đối với  và nén đường đi, các thao tác tìm kiếm các nút trên đường đi từ  tới nút gốc sau đó sẽ rẻ hơn rất nhiều. Do đó, các nút trên đường đi đó được hưởng lợi từ . Để cho công bằng giữa các nút, chúng ta sẽ tìm cách nào đó để "khấu trừ" chi phí khi thực hiện (), hay nói cách khác, các nút trên đường đi từ  tới gốc cũng phải trả bớt tiền mà  nợ.Trước hết ta sẽ phân các nút thành các nhóm như sau:Ở đây kí hiệu , dấu mũ lặp lại  lần. Tóm lại mỗi nhóm có hạng từ  tới . Một vài điểm quan trọng ở đây là:Xét một đường đi  từ  tới nút gốc trong thao tác (). Giả sử  đi qua hai nút  và  trong đó nút  là cha của nút . Nếu  và  nằm trong cùng một nhóm, ta lấy  đồng từ  thay vì từ  (vì  được hưởng lợi). Nếu  nằm trong nhóm cao hơn (là nhóm có số thứ tự cao hơn), ta sẽ lấy  đồng từ . Do đó:  chỉ phải trả  đồng vì chúng ta chỉ có  nhóm khác nhau.Bây giờ sẽ là phần khó nhất, đó là trung bình mỗi nút  như trên phải trả bao nhiêu đồng? Thứ nhất, nút  sẽ không bao giờ thay đổi hạng, theo tính chất 2 của hạng. Thứ hai, mỗi lần nút  trả bớt  đồng cho một nút nào đó, hạng của cha của  tăng ít nhất lên 1, và cha của  phải nằm trong cùng một nhóm với . Do đó, nếu hạng của cha của  tăng đến mức của nhóm tiếp theo,  sẽ không bao giờ phải trả tiền cho bất kì một nút nào khác. Như vậy,  phải trả tối đa số tiền là phạm vi của hạng trong nhóm chứa  ( là  nếu  trong nhóm có hạng bắt đầu từ  đến ). Nhóm chứa  có kích thước là , do đó, tổng số tiền mà tất cả các nút trong nhóm này phải "trả hộ" nút khác là:  Do đó, tổng số tiền "trả hộ" của tất cả các nút là  vì số nhóm là . Tổng kết lại như sau: nếu ta có  thao tác  (), số tiền tất cả các nút phải trả cuối cùng là . Trong hầu hết các thuật toán , do đó thời gian khấu trừ cho mỗi thao tác  là .Với cấu trúc danh sách liên kết, cách thực thi hiệu qủa có lẽ cũng là sử dụng danh sách liên kết. Tuy nhiên với cấu trúc cây, chúng ta không nhất thiết phải sử dụng cây để thực thi. Phần này mình sẽ giới thiệu phương pháp thực thi bằng mảng (array). Ta sử dụng hai mảng:Các thao tác cơ bản như sau:  
 
Union-Find có rất nhiều ứng dụng mà nổi tiếng là trong thực thi thuật toán Kruskal tìm cây khung nhỏ  nhất. Trong phần này mình sẽ giới thiệu ứng dụng của Union-Find trong việc thiết kế giải thuật  cho bài toán lập lịch có thời hạn đã giới thiệu trọng bài . Chi tiết xem thêm tại bài trước. Ở đây mình nhắc lại đề bài và thuật toán tham lam :  Giải thuật : 
Trong thuật toán trên, thời gian để tìm một vị trí để chèn một tác vụ mới mất cỡ . Bằng Union-Find, sử dụng cấu trúc cây kết hợp nén đương đi, chúng ta có thể giảm thời gian này xuống , do đó, thuật toán sẽ có tổng thời gian là  (nếu không tính bước sắp xếp mất ). Giả sử thời điểm hiện tại ta có mảng  là mảng lưu trữ lịch trình của các tác vụ chúng ta đã được vào lời giải tối ưu trong các bước trước. Mỗi tập hợp của chúng ta sẽ biểu diễn một dãy liên tục và tối đại (maximal) các phần tử khác 0   của mảng . Nói cách khác, với mỗi tập hợp chứa các phần tử , ta luôn đảm bảo điều kiện: Ngoài ra, gốc của mỗi tập hợp sẽ lưu trữ số , là vị trí trái nhất (left-most) còn trống của dãy liên tục này. Để kiểm tra xem tác vụ  với thời hạn  có thể chèn vào lịch trình  hiện tại được không, ta làm như sau:Chi tiết giả mã như sau:   
Code bằng C của giả mã:Thủ tục () không thay đổi so với ở trên. Mảng  là mảng lưu trữ phần tử trái nhất còn trống của một tập. Một điểm chú ý là thứ tự của  và  trong () là quan trọng, vì theo tứ tự đó, phần tử trái nhất còn trống của tập chứa  nhỏ hơn của tập chứa . Thứ nữa đó là trong hàm (), phần tử ngay sau  có thể khác 0 (do đó trong comment mình để "supposed empty"). Nếu phần tử này khác 0, phép gộp trong hàm  luôn đảm bảo tập hợp chứa  sẽ được gộp với tập hợp chứa . Code: .
[1] Avrim Blum. , CMU, 2011.
[2] Jeff Erickson. , UIUC, 2013.
[3] Jon Kleinberg and Eva Tardos. , Chapter 4. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA,2005.
[4] Robert Endre Tarjan.  J. ACM 22, 2 (April 1975), 215-225. DOI=10.1145/321879.321884 
[5] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 21 . MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7.  , , Trackback link: Powered by  and 