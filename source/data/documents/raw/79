Tìm kiếm đa mẫu bằng thuật toán Aho-Corasick --  Aho-Corasick Algorithm
http://www.giaithuatlaptrinh.com/?p=703
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Thuật toán Aho-Corasick được phát triển bởi Alfred Aho và Margaret Corasick vào năm 1975 cho bài toán tìm kiếm đa mẫu sau:  Với mỗi từ khóa , ta có thế áp dụng thuật toán tuyến tính (ví dụ  hoặc ) để tìm kiếm sự xuất hiện của  trong . Mỗi lần tìm kiếm như vậy ta mất thời gian  và do đó, tổng thời gian tìm kiếm  từ khóa là . Nếu cả  và  đều lớn thì thuật toán này thực sự không hiệu quả. Aho-Corasick dựa trên ý tưởng của thuật toán KMP và  đã phát triển giải thuật với thời gian  trong đó  là số kí tự trong bảng chữ cái sử dụng. Thông thường,  là một hằng số, do đó, thuật toán có thể coi là có thời gian tuyến tính. Trọng tâm bài này là định lý sau: Trong bài  (finite-state machine - FSM), chúng ta đã làm quen với một máy trạng thái hữu hạn định nghĩa cho một xâu mẫu  và cách xây dựng máy trạng thái đó trong thời gian . Bây giờ chúng ta sẽ mở rộng khái niệm đó cho tập các từ khóa . Mình khuyến khích bạn đọc xem lại bài máy trạng thái hữu hạn trước khi đọc tiếp phần dưới đây.Một máy trạng thái hữu hạn của tập các từ khóa  là một đồ thị có hướng  và có các đặc điểm sau:Trong hình dưới đây mô tả một cây Trie với tập từ khóa  (hình (a)) và máy trạng thái hữu hạn tương ứng (hình (b)). Các cạnh màu đỏ là các cạnh không khớp.     Với mỗi nút  của cây Trie, ta gọi xâu tạo bởi các kí tự trên đường đi từ  tới  là  (path label) của nút . Có thể thấy cây Trie cho một tập các từ khóa có các đặc điểm sau:Các cạnh không khớp trong máy trạng thái được xây dựng dựa trên luật cạnh không khớp sau: Nút  có một cạnh không khớp tới nút  khi và chỉ nhãn đường đi của nút  là hậu tố dài nhất của nhãn đường đi của nút .Ví dụ trong hình (b) ở trên, nút  có một cạnh không khớp tới nút  vì nhãn đường đi của  (xâu ) là hậu tố dài nhất của nhãn đường đi của  (xâu ). Bạn đọc có thể kiểm tra luật này với các nút khác. Gọi  là số trạng thái của FSM. Ta sẽ dùng một mảng hai chiều  để biểu diễn cây Trie, trong đó  nếu như nút  là con của nút  và cạnh  có nhãn là . Ta sẽ xây dựng Trie bằng cách "chèn lần lượt" từng từ khóa của  vào cây Trie. Ví dụ các bước xây dựng cây Trie cho  được minh họa bởi hình sau:
Giả mã của thuật toán xây dựng cây Trie như sau: 
Code C:Sau khi đã xây dựng cây Trie, ta phải xây dựng các cạnh không khớp. Để biểu diễn cạnh không khớp của mỗi nút, ta sẽ sử dụng mảng  trong đó  nếu có một cạnh không khớp từ nút  đến nút . Hiển nhiên sử dụng luật cạnh không khớp, ta có thể xây dựng mảng  trong thời gian  bằng cách với mỗi nút , ta sẽ duyệt các nút có độ sâu nhỏ hơn  (sử dụng -- BFS) và tìm ra nút thỏa mãn luật cạnh không khớp. Duyệt như vậy mất thời gian  cho mỗi cạnh không khớp, và do đó, tổng thơi gian là .Tuy nhiên, sử dụng ý tưởng quy hoạch động trong xây dựng FSM ở , ta có thể xây dựng mảng  trong thời gian  như sau. Ta sẽ xây dựng cạnh không khớp cho các nút theo thứ tự tằng dần của chiều sâu (thứ tự BFS). Ban đầu . Giả sử ta đang xây dựng cạnh không khớp cho một nút   ở chiều sâu  (chiều sâu của một nút là khoảng cách từ nút đó đến gốc của cây Trie), và ta đã xác định được cạnh không khớp cho các nút ở chiều sâu nhỏ hơn . Gọi  là nút cha của  trong cây Trie và  là nhãn của cạnh  trong cây Trie. Xét nút  (giá trị này đã xác định theo giả thiết quy nạp vì  có chiều sâu nhỏ hơn ), nhãn của nút  là hậu tố của nhãn của nút . Do đó, nếu , thì ta chỉ việc gán  do nhãn của nút  là hậu tố của nhãn của nút  (hình (a)). Nếu không (), ta tiếp tục xét nút  và lặp lại tương tự, so sánh  với  (hình (b)). Trường hợp xấu nhất ta sẽ trở lại nút  và lúc này ta sẽ gán . Giả mã như sau: 
Code C:Từ các thảo luận ở trên, ta có: Giả sử trong tập từ khóa , không có hai từ khóa  nào sao cho  là xâu con của . Ta gọi bộ từ khóa  là bộ . Bộ từ khóa trong ví dụ trên là không độc lập vì từ khóa  là xâu con của từ khóa .
Ta có định lý sau: Ta có thể dễ dàng chứng minh định lý trên bằng phản chứng (và coi như bài tập cho bạn đọc). Định lý trên cho phép chúng ta tìm kiếm trong văn bản  giống như thuật toán KMP. Ta sẽ sử dụng FSM để tìm kiếm trong  như sau. Mỗi bước của thuật toán ta xét một kí tự và một trạng thái của máy FSM. Ban đầu ta xét kí tự  và trạng thái (nút)  của máy FSM. Gọi  và  lần lượt là kí tự hiện tại ta đang xét của  và trạng thái hiện tại ta đang xét của FSM.  Giả mã của thuật toán như sau: 
Code C: Bên cạnh thời gian để xây dưng FSM, thời gian chạy của thuật toán tỉ lệ với phép so sánh bằng () cộng với số phép so sánh không bằng  () cộng với số lần từ khóa xuất hiện trong văn bản  (mỗi khi  là nút lá). Số lần xuất hiện trong văn bản được cố định là , do đó ta không cần phân tích thêm nữa về đại lượng này. Mỗi lần , ta sẽ tăng biển  lên  đơn vị và  sẽ được tăng lên trạng thái ở độ sâu cao hơn. Do đó, có tối đa  phép so sánh bằng.  Mỗi lần so sánh bằng,  giữ nguyên còn  sẽ được giảm về trạng thái ở độ sâu thấp hơn. Do số lần giảm độ sâu của  không thể vượt quá số lần tăng độ sâu của , do đó, số phép so sánh bằng không thể vượt quá số phép so sánh không bằng. Như vậy, thời gian của thuật toán bằng thời gian để xây dưng FSM + . Kết hợp với Lemma 1, ta suy ra Theorem 1 trong trường hợp bộ từ khóa độc lập.Nếu bộ từ khóa  có hai từ khóa  sao cho  là xâu con của  thì việc tìm kiếm sẽ trở nên khó khăn hơn nhiều. Ví dụ bộ từ khóa gồm 3 từ  và văn bản . Khi tìm kiếm theo thuật toán với khóa độc lập, ta sẽ tìm thấy khóa  đầu tiền, sau đó đi theo cạnh không khớp và tiếp tục tìm được từ khóa . Mặc dù  có trong văn bản nhưng ta sẽ không tìm ra nó. trong hình dưới đây, mình lược bỏ một số cạnh không khớp để hình nhìn đỡ rối hơn.
Nếu làm theo từng bước của thuật toán trên, khi ta so sánh kí tự  với trạng thái 5 của FSM, ta nên đi tới cạnh không khớp để tìm ra từ  và sau đó tiếp tuc so sánh  với trạng thái 6 của FSM. Tuy nhiên, làm như vậy thì mỗi lần so kí tự, ta lại phải kiểm tra (bằng cách đi theo cạnh không khớp) xem có từ khóa nào xuất hiện trong  hay không. Đó là chưa kể, nếu đi theo cạnh không khớp của nút  tới nút , ta phải tiếp tục đi theo . Ví dụ với bộ  và ,

Khi ta so sánh  với trạng thái , ta phải đi theo cạnh không khớp tới trạng thái 2 để in ra  và sau đó tiếp tục đi theo cạnh không khớp của 2 đi tới 14 để in ra , và sau đó mới tiếp tục so sánh  và trạng thái 6. Để giải quyết vấn đề này, ta sẽ dùng một mảng  trong đó  là một tập các từ khóa sao cho mỗi từ khóa trong  là hậu tố của nhãn đường đi của trạng thái . Ví dụ trạng thái  sẽ có  vì cả hai từ khóa này đều là hậu tố của  (là nhãn đường đi của ). Trong hình dưới đây, các từ khóa tương ứng với các nút là danh sách  của nút đó. Các nút không có gì là các nút có danh sách  rỗng.Giả sử ta đã tính được  ta chỉ cần thay đổi một chút thủ tục tìm kiếm với bộ từ khóa độc lập ở trên như sau: 
Code C:Để tính mảng  , ta sẽ sửa đổi thủ tục   và  như sau: 
Code C: 
Code C:Sử dụng danh sách liên kết, ta có thể thực hiên   trong thời gian . Từ đó ta suy ra Theorem 1.Code của bài viết: ,.[1] Aho, Alfred V., and Margaret J. Corasick. . Communications of the ACM 18.6 (1975): 333-340.  , , , , Trackback link: Powered by  and 