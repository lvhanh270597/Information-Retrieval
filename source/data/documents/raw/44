Tính tổng, tích modulo và bán tổng-- computing modulo sum, modulo product and semi-sum
http://www.giaithuatlaptrinh.com/?p=1117
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Đây là bài trả lời cho bài toán bug bug bug trên  mà mình post mấy hôm trước. Xin vui lòng để lại comment nếu bạn có lời giải tốt hơn; mình sẽ cập nhật vào bài viết chính (tất nhiên cả thông tin của tác giả). Bài toán như sau: Thông thường, khi bạn được yêu cầu viết code cho các câu hỏi trên, bạn có thể sẽ làm như sau: Các đoạn code này thoạt nhìn có vẻ đúng nhưng bên trong nó tiềm ẩn những lỗi nghiêm trọng. Trong hai đoạn code trả lời câu hỏi (1) và (2), lỗi cơ bản mà ta có thể gặp đó là tràn số. Ví dụ  thì tổng  và tích  không còn có thể biểu diễn được bằng kiểu  nữa. Trong đoạn code cho câu hỏi (3), ngoài lỗi tràn số, kết quả trả về sẽ bị sai khi  < . Ví dụ , đoạn mã sẽ trả về  thay vì .Một nhận xét đơn giản mà ta dễ thấy đó là kết quả đầu ra của các câu hỏi trên có thể biểu điên được bằng kiểu . Tuy nhiên, khi bạn nghĩ sâu hơn về làm thể nào để tránh tràn số, bạn sẽ thấy trả lời câu hỏi này một cách trọn vẹn không hề đơn giản.Ngược lại với bài toán tổng modulo, bài toán hiệu modulo có thể tính được dễ dàng mà không sợ tràn số. Ta có thể giả sử  đều nhỏ hơn  bằng cách lấy mod trước khi tính hiệu.  Hiệu số  luôn có thể biểu diễn được bằng kiểu int. Do đó, nếu () ta tính tính . Nếu  < , ta sẽ tính . Chú ý ở đây ta giả sử a, b đều nhỏ hơn , do đó  < . Code: Bài toán tổng modulo có thể quy về hiệu modulo bằng mẹo sau:   Trước khi ta chuyển về tính hiệu, ta đảm bảo  đều nhỏ hơn  bằng cách lấy modulo . Code: 
Tính tích , ta sử dụng ý tưởng  trong bài tính lũy thừa . Ta sẽ gọi đệ quy để tính  và sử dụng thủ tục tính tổng modulo để tính tổng. Code  Thủ tục đệ quy có độ sâu . Mỗi lần gọi đệ quy, ta mất  thao tác bít để tính  từ kết quả của lời gọi đệ quy. Do đó, tổng số thao tác bít là:   Nếu tràn số không xảy ra, thủ tục semi_sum ở phần giới thiệu sẽ trả lại kết quả  đúng nếu  và trả lại  nếu ngược lại. Ta sẽ sử dụng công thức cơ bản sau để biến đổi nửa tổng về dạng mà ta có thể tính đơn giản được:    Trường hợp  khác dấu, tràn số sẽ không bao giờ xảy ra. Do đó, ta chỉ cần kiểm tra xem nếu , ta sẽ áp dụng thủ tục semi_sum, và áp dụng  nếu ngược lại.  Trường hợp  cùng dấu, ta giả sử . Ta có:  Do , phần nguyên theo (4)  có thể tính như trong semi_sum (mà không lo tràn số vì  cùng dấu). Code: Code ở trên ta sử dụng phép XOR () để kiểm tra xem hai số có cùn dấu hay không. Hai số nguyên  cùng dấu khi và chỉ khi , ở đây  là phép XOR bit. Code ở trên chỉ mang tính minh họa. Để code hiệu quả hơn, ta có thể thay thế một số thao tác đại số (kể cả lệnh rẽ nhánh if, then) bằng các thao tác bít. Ví dụ , , .... Xem thêm tại bài các .Code đầy đủ: .
[1] Ruggieri, Salvatore.  Information Processing Letters 87.2 (2003): 67-71. , Trackback link: Powered by  and 