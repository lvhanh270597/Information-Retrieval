Quay lui---Backtracking
http://www.giaithuatlaptrinh.com/?p=58
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Quy lui là một kĩ thuật thiết kế giải thuật dựa trên đệ quy. Ý tưởng của quay lui là tìm lời giải từng bước, mỗi bước chọn một trong số các lựa chọn khả dĩ và đệ quy. Ok. Có vẻ vẫn chưa được rõ ràng lắm. Giờ chúng ta xem xét một vài ví dụ và khái quát hóa phương pháp quay lui.  Bài toán như sau: : ta thấy để các quân hâu không ăn được nhau, ta phải xếp  quân hậu trên  hàng của bàn cờ. Ta dùng mảng , trong đó  nếu quân hậu ở hàng thứ  được đặt ở cột .: giả sử chúng ta đã đặt được  quân hậu, ,  trên  hàng đầu tiên sao cho không có 2 quân hậu nào ăn được nhau. Cụ thể các phần tử  sẽ khác  và các phần tử  đều bằng . Chúng ta tìm cách đặt một quân hậu trên hàng thứ . Ta sẽ thử lần lượt đặt vào cột thứ . Nếu đặt vào cột thứ  mà bị một trong  quân hậu đã đặt trước đó ăn, ta sẽ thử cột thứ . Nếu ta tìm được một ví trí đặt khả dĩ (a feasible position), ta sẽ đặt vào đó và gọi đệ quy để đặt hàng thứ . Giả mã như sau:


 
Code của giả mã bằng C. Code đầy đủ được cho ở cuối bài. 
 là một cách nhìn khác của thuật toán. Tưởng tượng ta có một cây với gốc tượng trưng cho cấu hình ban đầu của bàn cờ (mảng  gồm toàn 0). Nút con của gốc, gọi là nút level 1, là các cách đặt một quân hậu vào hàng thứ 1.  Nút con của một nút level 1, gọi là nút level 2, là các cách đặt khả dĩ một quân hậu vào hàng thứ 2. Cứ như thế đến nút level  () ta sẽ thu được một cây gọi là cây đệu quy. Có thể thấy rằng thuật toán quay lui ở trên thực ra chính là một cách duyệt cây theo chiều sâu cho đến khi tìm được một nút ở level .  Hình minh họa sau với  được lấy từ []

Có thể thấy thuật toán trên có thời gian cỡ . Tuy nhiên nếu bạn cần một lời giải bất kì, bài toán này có công thức giải và bạn chỉ mất thời gian để in lời giải ra ()[]. Sudoku là một trò chơi khá phổ biến và chắc ai (readers of this bog) cũng biết. Trò chơi như sau: có một hình vuông được chia thành 9x9 ô vuông con. Mỗi ô vuông con có giá trị trong khoảng từ 1 đến 9. Ban đầu hình vuông có một số ô vuông con cho trước (có điền sẵn số) và còn lại là trống. Hãy điền các số từ 1-9 vào các ô con lại sao cho: hàng ngang là các số khác nhau từ 1 đến 9, hàng dọc là các số khác nhau từ 1 đến 9, và mỗi khối 3x3 chính là các số khác nhau từ 1 đến 9. Ví dụ một câu đố và lời gải tương ứng như sau (hình được lấy từ ):
Trong bài này mình sẽ giới thiệu cách giải sudoku bằng thuật toán quay lui. Ý tưởng của thuật toán cũng giống bài toán  quân hậu. Mỗi bước tìm tập các giá trị khả dĩ để điền vào ô trống, và sau đó đệ quy để điền ô tiếp theo. Giả mã của thuật toán (ở đây chú ý mảng chỉ có kích thước ). Thủ tục  kiểm trả xem giá trị  có khả dĩ với ô  không.  
Code của giả mã trên bằng C: 
Giả mã của thủ tục  như sau: 
Code bằng C của giả mã (code đầy đủ được cho ở cuối bài): Subset Sum là một trong những . Trong bài này chúng ta sẽ thiết kế thuật toán quay lui để giải bài toán Subset Sum.  
Ví dụ:  và . Lời giải là true vì tập con  của  có tổng bằng 12.Ý tưởng của thuật toán quay lui dựa trên quan sát sau: xét một phần tử , tồn tại một dãy con có tổng bằng  nếu một trong hai điều kiện sau là đúng:Giả mã như sau: 
Code của giả mã bằng C:  Ở mỗi bước của thuật toán quay lui, ta gọi đệ quy hai lần trên mảng con của  với kích thước nhỏ hơn 1. Ta có:   Code: , , ,   , UIUC.
 
 Cho một mảng  phần tử . Tìm một dãy dài nhất ( lớn nhất) các chỉ số    . Cho một dãy , tìm dãy con gia tốc dài nhất của . Tìm công thức đệ quy cho bài toán, dựa vào đó thiết kế giải thuật quay lui. Hãy sửa đổi thuật toán quay lui ở trên của bài toán Subset Sum để in ra ít nhất một dãy con có tổng bằng  của .  , , , , Trackback link:  on                     Chào anh, em đọc code giải sudoku của anh có đoạn em không hiểu lắm ạ:if(feasible(S, x, y, k) != 0) {
				S[x][y] = k;
				solve_sudoku(S, x, y+1);
				S[x][y] = 0;
			}tại sao sau khi gọi lại hàm solve_sudoku(S, x, y+1) lại phải gán S[x][y] = 0 vậy ạ? on                     Hi bạn MuaXuan,
Nếu bạn để ý kĩ, hàm feasible(S,x,y,k) của mình đúng nếu đầu vào là ô . Do đó sau mỗi lần thử đặt  vào ô , mình gán lại ô này bằng . Thực ra, nếu để ý kĩ, bạn sẽ thấy ta không nhất thiết phải làm như vậy. Bạn có thể đặt lệnh gán  ra ngoài vòng lặp for(k = 1; k <= 9; k++). Lý do ta phải gán bằng 0 là như sau:

Giả sử ô trước khi gán giá trị cho  là ô  (cả hai ô   ban đầu là rỗng). Nếu bạn vẽ cây đệ quy ra, bạn sẽ thấy mỗi lần thử , bạn sẽ gán mọi giá trị có thể có cho ô tiêp theo . Sau khi thử , bạn thử . Khi thử , bạn lại phải thử lại toàn bộ giá trị có thể của . Do đó, trước khi thử gán , bạn phải đảm bảo  để code chạy đúng.

Hi vọng mình trả lời đúng câu hỏi của bạn. Nếu bạn vẫn thấy chưa hoàn toàn trả lời được, bạn có thể comment mình sẽ giải thích thêm.
 on                     Nếu như vậy thì sau lần cuối cùng thế k vào hàm feasible(lần lặp cuối cùng) thì S[x][y] cũng dc gán = 0 thì đáng lý ra các ô S[x][y] = rỗng ban đầu sau đó cũng đều = 0 hết chứ sao nó lại lưu lại được 1 giá trị khác 0 vậy bạn ? Mình vẫn chưa hiểu lắm, mong bạn giúp đỡ mình. Cảm ơn nhiều nhé bạn. on                     Khi lần cuối cùng bạn gán một giá trị vào, và gọi đệ quy lần cuối thì lúc đó thủ tục sẽ in ra luôn (2 câu lệnh if đầu tiên của thủ tục SUDOKU). Sau khi đã in ra rồi thì thủ tục sẽ exit. Nếu để ý phần code bằng C minh họa thì sẽ có câu lệnh exit(0) để thoát luôn khỏi chương trình ngay sau khi nó tìm được lời giải. on                     Ohhhh ra là vậy, mình hiểu r, cảm ơn bạn nhiều nha. on                     Ban đầu em cũng nghĩ như vậy nhưng không chắc nên đã hỏi, cảm ơn anh đã trả lời 🙂 on                     Không có gì! Cám ơn bạn đã ghé thăm. on                     Ở phần giả mã của bài "n Queens": Không biết có phải là e hiểu sai không nhưng nghĩ vòng lặp lớn phải cho "j" chạy từ 1  -> n chứ sao lại là "i" ạ? on                     Đúng rồi bạn. Mình gõ sai. Trong phần code thật thì mình để là j. Cám ơn bạn đã chỉ ra lỗi. on                     anh có thể gợi ý bài dãy gia tốc được không ạ ? on                     cho mình hỏi có thể áp dụng giải thuật quay lui này để giải bài toán mã đi tuần được không? on                     Hi bạn,
Câu trả lời là có nhé. Quay lui có thể áp dụng cho tất cả các bài toán mà bạn gặp trong thực tế. Vấn đề chỉ là nhanh hay chậm mà thôi.Hùng on                     Em chào anh , em cũng đang bắt đầu làm quen với các thuật toán cơ bản này. Anh cho em hỏi ở bài nQueens tại sao lại là Q[i]=j+r-i và Q[i]=j-r+i vậy ạ ? on                     Hi Châu,
Đó là điều kiện kiểm tra xem nếu đặt vào ô [r,j] thì ở đường chéo xuôi và ngược giao nhau tại [r,j] đã đặt quân hậu nào trước đó hay chưa.Best,
Hùng on                     Anh có thể đưa bài giải của phần bài tập không ạ? Em mần nát óc mấy hôm nay mà chưa giải nổi on                     Hi bạn,
Cụ thể bạn muốn gợi ý bài  nào? Mình có lẽ sẽ không có lời giải hoàn chỉnh nhưng sẽ gợi ý đến mức cụ thể nhất có thể.Hùng on                     Bài 1 anh ơi. Em không biết phải làm thế nào để nó quay lui trong bài toán này. Em cảm ơn anh trước on                     Hmm,
Mình không biết gợi ý này có hữu dụng hay không, bạn có thể thử ngẫm nghĩ. Bạn dùng thêm một biến $j$ để lưu trữ phần tử cuối cùng trong dãy con tăng đã tìm được khi tới bước đệ quy hiện tại. Sau đó xét thêm một phần tử mới $A[i]$ trong bước đệ quy hiện tại và so sánh $A[i]$ với $A[j].$ Nếu $A[i] \geq A[j]$ thì bạn có thể lựa chọn cho $A[i]$ vào dãy con tăng hay không và đệ quy tiếp. Nếu không thì bạn bỏ qua $A[i]$ và xét $A[i+1]$Best,
Hùng on                     Bài toán Subset sum hình như thiếu điều kiện mảng X là mảng không âm.
Thanks on                     Đúng rồi, cám ơn bạn. Mình đã bổ sungPowered by  and 