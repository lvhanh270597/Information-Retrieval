Heap nhị phân và thuật toán Heapsort -- Binary Heap and Heapsort
http://www.giaithuatlaptrinh.com/?p=736
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Bài này mình sẽ giới thiệu với các bạn cấu trúc dữ liệu Heap nhị phân. Đây là một cấu trúc dữ liệu đơn giản, dễ thực thi (you will see that!) và hiệu quả. Điểm yếu chính của cấu trúc này hầu hết các thao tác hỗ trợ có thời gian . Heap thường được dùng để thực thi  (priority queue). Nếu các bạn tìm kiếm , bạn sẽ thấy một bảng so sánh các loại Heap khác nhau. Mỗi loại Heap đều có một đặc điểm riêng và lĩnh vực ứng dụng cụ thể. Một số loại Heap như Fibonacci Heap, Rank-Pairing Heap, Brodal Heap, etc., có thời gian tiệm cận  cho hầu hết các thao tác. Tuy nhiên, điểm yếu của chúng là thực thi rất phức tạp, tốn bộ nhớ (do phải lưu trữ các con trỏ hỗ trơ) và mặc dù tiệm cận là  hay , hằng số ẩn sau kí hiệu  là khá lớn. Nếu chúng ta chấp nhận các thao tác trong thời gian , heap nhị phân là một cấu trúc hoàn hảo.Ngữ cảnh ứng dụng của Heap nhị phân thường có dạng như sau: Ta có một tập  các phần tử  trong đó phần tử thứ  có giá trị . Thao tác mà chúng ta quan tâm nhất đối với tập này là tìm và lấy ra một phần tử có giá trị nhỏ nhất (hoặc lớn nhất) của tập hợp. Ngoài ra, chúng ta cũng muốn hỗ trợ các thao tác để thay đổi tập hợp đó. Danh sách một số các thao tác mà chúng ta thường quan tâm như sau:Ta sẽ sử dụng cấu trúc Min-Heap để thực hiện các thao tác trên trong thời gian :  Tại thời điểm này mình vẫn chưa định nghĩa Heap nhị phân trong như thế nào cả. Mình sẽ định nghĩa ở dưới. Trong phần ứng dụng dưới đây, bạn đọc chỉ cần quan tâm đến các thao tác và thời gian thực hiện mỗi thao tác mà cấu trúc này hỗ trợ mà chưa cần quan tâm đến cấu trúc Heap sẽ được tổ chức như thế nào.Ứng dụng nổi bật nhất của cấu trúc Heap nhị phân là trong sắp xếp mà ta gọi là thuật toán Heapsort. Giả sử ta có một mảng các số nguyên  mà ta muốn sắp xếp nó theo chiều tăng dần của giá trị. Ta sẽ xây dựng một min-Heap nhị phân  cho mảng này.  hỗ trợ các thao tác liệt kê ở trên với thời gian trong Theorem 1. Để sắp xếp mảng ta làm theo các bước sau:Giả mã của Heapsort: 
Code C: Do mỗi thao tác  mất thời gian , tổng thời gian để sắp xếp mảng là . Một ứng dụng khác của min-Heap là trong thuật toán Dijsktra tìm đường đi ngắn nhất từ một đỉnh trong đồ thị có trọng số không âm. Mình sẽ blog về thuật toán này sau.  Cấu trúc biểu diễn đơn giản nhất là danh sách liên kết. Nếu sử dụng cấu trúc đó, các thao tác ,  mất  nhưng ,  có thể thực hiện . Nếu sửa đổi một chút bằng cách luôn lưu phần tử nhỏ nhất của tập hợp ở đầu danh sách và luôn chèn phần tử mới vào cuối danh sách, thì ta có thể thực hiện  trong  còn  vẫn là  do khi ta xóa phần tử nhỏ nhất khỏi danh sách, ta phải tìm phần tử nhỏ nhất trong số các phần tử còn lại và đưa nó về đầu danh sách. Cách khác là dùng mảng, tuy nhiên cách này cũng không ổn vì cho dù có làm thế nào thì một trong số các thao tác trên cũng là .Nếu chúng ta muốn các thao tác trong trường hợp tồi nhất là , ta phải nghĩ ngay đến cấu trúc cây. Ở đây mình sẽ dùng cấu trúc cây nhị phân (do đó gọi là heap nhị phân). Trước hết để đảm bảo , cây của chúng ta phải cân bằng (do đó độ sâu của cây là ). Ta sẽ lưu phần tử nhỏ nhất tại gốc của cây, do đó  có thời gian . Cũng từ đó ta suy ra khóa của nút gốc nhỏ hơn khóa của hai nút con của nó. Ta sẽ đảm bảo tính chất này cho mọi nút của cây Heap. Như vậy hai tính chất cần thiết của cây Heap là:Ví du tập các giá trị  có cấu trúc Heap biểu diễn minh họa trong hình dưới đây:Từ tính chất Heap, bằng quy nạp, ta có thể chứng minh được: 
Gọi  (depth) của một nút là số cạnh trên đường đi từ nút gốc đến nút đó. Gọi  là số cạnh đi từ gốc đến một nút lá tại mức cao nhất của cây đó. Từ tính cân bằng mạnh, ta suy ra: 
 mặc dù ta nói  nhưng thực ra ta có thể biểu diễn "cây" đó bằng một mảng . Ta sẽ biểu diễn các nút của cây Heap như sau:Ví dụ mảng tương ứng với cây Heap ở hình trên được minh họa trong hình dưới đây. Các mũi tên màu đỏ gạch là các mũi tên nối từ nút cha tới một nút con.Trong thực tế cài đặt, nếu số lượng phần tử chèn vào vượt quá kích thước của mảng, ta phải cấp phát lại bộ nhớ cho mảng. Chiến lược cấp phát bộ nhớ có thể áp dụng là gấp đôi kích thước của mảng mỗi lần ta phải cấp phát bộ nhớ (giống  trong Java). Trong trường hợp chúng ta biết được kích thước tối đa của mảng trong mọi thời điểm thì bài toán sẽ đơn giản hơn nhiều.Để chèn một khóa  vào Heap, ta sẽ tìm  của cây, là nút lá cuối cùng theo thứ tự từ trái sang phải. Gọi nút là đó là .  Để đảm bảo tính cân bằng mạnh, ta sẽ chèn  vào nút anh em (sibling) gần nhất bên phải của . Nếu cây nhị phân là cân bằng, ta sẽ chèn  vào mức tiếp theo, ngoài cùng bên trái.  Thao tác này được minh họa trong hình (a) và (b) của hình dưới đây. Vấn đề còn lại là đảm bảo tính chất Heap. Nếu nút mới chèn vào có khóa nhỏ hơn nút cha nó, ta phải thay thế chỗ của nó với cha nó. Sau khi đổi chỗ, khóa của nút này vẫn có thể nhỏ hơn khóa của nút cha mới. Do đó, ta tiếp tục gọi đệ quy cho đến khi nào khóa của nó nhỏ hơn khóa của nút cha mới thì dừng lại. Ta gọi thủ tục đẩy một nút lên là thao tác  (Up-Heapify). Thao tác đó được minh họa trong hình (c), (d), (e) của hình dưới đây:Với biểu diễn mảng,  của cây chính là  và do đó, anh em gần nhất bên phải của nó là . Giả mã:   
Code C: Thủ tục vun đống ngược lên trên có thời gian  vì theo Fact 2, cây Heap có độ sâu . Do đó, ta có thể chèn một nút vào trong Heap trong thời gian .Khi giảm giá trị khóa của một nút mà ta gọi là , giá trị mới của  có thể nhỏ hơn giá trị khóa của nút cha của nó (tại sao ta không cần quan tâm đến các nút con của nó). Do đó, ta sẽ sử dụng thủ tục vun đống ngược lên trên Up-Heapify để đảm bảo tính cân bằng. Thao tác này mất thời gian  do chiều cao của cây là . Hình minh họa:
Giả mã như sau: 
Code C:Thủ tục này phức tạp hơn cả vì ta cần phải xóa phần tử nhỏ nhất ra khỏi Heap và cùng một lúc đảm bảo các tính chất của Heap. Chú ý phần tử nhỏ nhất là gốc của cây Heap. Do đó, để đảm bảo tính cân bằng mạnh, đầu tiên ta sẽ đưa nút lá cuối cùng lên làm gốc, thế chỗ cho nút có khóa nhỏ nhất. Do nút gốc mới này có giá trị có thể lớn hơn nút con của nó, ta sẽ đổi chỗ cho  của nó. Sau đó tiếp tục gọi đệ quy vì sau khi đổi chỗ, khóa của nó có thể vẫn lớn hơn khóa của các nút con mới. Ta gọi thủ tục này là  (Down-Heapify). Do độ cao của cây Heap là , thủ tục này mất thời gian . Thao tác đó được minh họa trong hình dưới đây:
Giả mã:  
Code C:Giả sử ta có đầu vào là một mảng , ta muốn xây dựng Heap với khóa là các phần tử của mảng. Ta có thể xây dựng bằng cách bắt đầu từ một Heap rỗng và lần lượt chèn các phần tử vào Heap. Mỗi lần chèn ta mất thời gian , do đó, ta có thể xây dựng Heap trong thời gian . Tuy nhiên, ta có thể xây dựng Heap trong thời gian  như sau:Thao tác đó được minh  họa trong hình sau. Các nút được đánh dấu là các nút ta sẽ thực hiện Down-Heapify.
Giả mã: Code C: Ta có các nhận xét sau:Do đó, tổng thời gian của thuật toán là:  Đặt , sử dụng  của đẳng thức  theo  và thay thế , ta suy ra . Do đó, ta có:   Cấu trúc Heap nhị phân không bắt buộc quan hệ giữ con trái và con phải của một nút, có nghĩa là con trái có thể lớn hơn con phải và ngược lại. Do đó, ta có thể "tích hợp" thêm quan hệ giữa con phải và con trái. Cấu trúc sử dụng ý tưởng này chính là  mà mình đã viết ở bài trước. Code đầy đủ của bài viết: .
[1] Binary Heap on Wikipedia, , Accessed 11/01/2016. , , , , Trackback link:  on                     Mình thắc mắc chỗ DecreaseKey
Giả sử dãy ban đầu của mình là a[1..n]
Sau đó mình xây dựng min heap H[1..n] từ mảng a
Bây giờ mình thay đổi giá trị của phần tử thứ i trong a thì làm cho Heap nó thay đổi như thế nào?
Ví dụ: a = 4 2 3 1 => H = 1 2 3 4
Khi này mình thay đổi a[1] = 2
=> Heap sẽ thành H =  1 2 5 2 (chưa hiệu chỉnh)
Hiệu chỉnh thành => H = 1 2 2 5 on                     Hi
Mình không hiểu ví dụ của bạn lắm. Tại sao thay đổi phần tử a[1] = 2 lại thay đổi được toàn bộ Heap như ví dụ của bạn? Về cơ bản, bạn muốn thay đổi một khóa. có thể hiểu là bạn muốn tăng hoặc giảm giá trị của khóa đó. Giảm giá trị khóa và duy trì Heap sau khi giảm mình đã mô tả trong phần DecreaseKey. Nếu bạn muốn tăng giá trị của một khóa, làm tương tự, nhưng bạn sẽ gọi DownHeapify thay vì UpHeapify.Hùng on                     Về thay đổi giá trị của heap mình đã hiểu.
- Nhưng giả sử ban đầu mình có mảng a.
- Sau đó mình xây dựng heap từ mảng a đó => mảng a có n phần tử thì mảng heap cũng có n phần tử thôi
- Bây giờ bài toán thay đổi giá trị của phần tử trong mảng a, điều đó cũng có nghĩa mình phải cho heap phải thay đổi tương ứng, thì mình sẽ code để heap thay đổi ntn?
- Ý bạn là thay đổi key trên heap, nhưng thay đổi a[1] = 2 chẳng hạn thì lúc này a[1] ở chỗ nào trong heap để mà thay đổi. on                     Trong trường hợp này, có lẽ bạn cần thêm một mảng nữa, ví dụ pos[1,...,n] để xác định xem phần tử A[i] ở vị trí nào trong Heap. Ví dụ pos[1] = 5 nghĩa là A[1] ở vị trí thứ 5 trong mảng Heap.  Khi thực hiện các thao tác của Heap, ngoài các khung cơ bản như trên thì bạn cần phải cập nhật mảng post. HùngPowered by  and 