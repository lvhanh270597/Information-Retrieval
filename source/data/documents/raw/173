Cây Splay -- Splay Tree
http://www.giaithuatlaptrinh.com/?p=613
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong bài này mình sẽ giới thiệu về cấu trúc dữ liệu splay tree (do không tìm được thuật ngữ Tiếng Việt nên mình giữ nguyên thuật ngữ tiếng anh). Splay Tree được giới thiệu bởi Sleator và Tarjan vào năm 1985 [1]. Cấu trúc Splay Tree thuộc về lớp các cây tìm kiếm nhị phân tự cân bằng (Self-Adjusting Binary Search Tree - BST), có nghĩa là nó sẽ tự điều chỉnh cấu trúc của nó mỗi khi có một thao tác thực hiên trên cây. So với cây cân bằng AVL Tree và Red Black Tree (mình sẽ blog về cây này vào một ngày đẹp trời nào đó), Splay Tree có một số ưu điểm sau [2]:Tuy nhiên, điểm yếu của Splay Tree là chiều cao của cây có thể  và một số thao tác có thể rất tốn kém (nhưng trung bình sẽ là ). Ok, tóm lại Splay Tree tốt hơn về một số mặt. Bây giờ chúng ta sẽ tìm hiểu cụ thể hơn. Cây Splay Tree là một cây nhị phân tự cân bằng. Các thao tác cơ bản bao gồm:Ngoài 3 thao tác trên, cây Splay Tree cung cấp thêm thao tác . Một nút được splay sẽ được đưa lên làm gốc của cây splay tree thông qua một loạt các thao tác quay cây (tree rotations) mô tả dưới đây. Trọng tâm của bài viết là định lý sau: Trong giả các giả mã dưới đây, mình sẽ sử dụng cấu trúc dữ liệu  cho mỗi nút của cây. Cấu trúc này bao gồm các trường sau:Biểu diễn trong C: Có một phiên bản thực thi khác của cây Splay Tree mà không cần trường parent, do đó tiết kiệm được thêm bộ nhớ và thời gian (để cập nhật trường parent sau mỗi thao tác). Tất nhiên là thực thi cũng sẽ phức tạp hơn một chút. Bạn đọc tham khảo cách thực thi này bằng Java tại [4].Cũng như AVL và Red Black Tree, cây Splay Tree cũng sử dụng các thao tác quay để làm cho cây trở nên cân bằng. Hai thao tác quay cơ bản là  và . Hai thao tác này được minh họa trong hình dưới đây:Từ cây bên trái, để thu được cây ở hình bên phải, ta thực hiện . Tương tự như vậy, từ cây bên phải, để thu được cây ở hình bên trái, ta thực hiện . Chú ý cây con màu đỏ của  và của  trong hai hình đổi chỗ khi thực hiện quay. Gọi  là cha của$  và  là con phải của . Để quay phải, ta làm theo các bước sau:Giả mã quay phải tại  như sau: Code C:Quay trái ta làm tương tự như quay phải, cập nhật các con trỏ. Giả mã quay trái tại  như sau: 
Code C: Khi thực thi bằng code, các bạn chú ý check null. Để giả mã sáng sủa, mình bỏ qua các bước check null.Ta dễ thấy: Ngoài ra, khác với AVL Tree, Splay Tree còn sử dụng hai phép:  và 
Phép Zig-Zag có hai dạng là Zig-Zag trái và Zig-Zag phải. Hai phép zig-zag trái và phải  được minh họa  trong hình dưới đây: 
Trong cả hai phép, nút  sẽ được đưa lên làm gốc thay cho . Phép zig-zag trái gồm hai phép: quay trái tại , sau đó quay phải tại . Phép zig-zag phải gồm hai phép: quay phải tại , sau đó quay trái tại . Chú ý sự thay đổi cha của các cây con được tô màu của .Giả mã của phép zig-zag trái tại : 
Code C:Giả mã của phép zig-zag phải tại : 
Code C:Tương tự như zig-zag, có hai phép Roller-Coaster là phải và trái, được minh họa trong hình dưới đây:
 Phép roller-coaster phải tại  gồm hai phép: quay rollaer-coaster phải tại , sau đó quay phải tại . Phép roller-coaster trái tại  gồm hai phép: quay trái tại , sau đó quay trái tại . Chú ý sự thay đổi cha của các cây con được tô màu của .Giả mã của phép roller-coaster phải tại : 
Code C:Giả mã của phép roller-coaster trái tại : 
Code C:Phần tiếp theo chúng ta sẽ thực hiện phép Splay. Các thao tác chèn, xóa, tìm kiếm đều sử dụng phép Splay như là một thủ tục con. Như đã nói ở trên, phép splay một nút sẽ thực hiện đưa một nút con lên làm nút gốc của cây Splay Tree. Phép Splay được thực hiện thông qua một loạt các phép quay, zig-zag và roller-coaster phụ thuộc vào cấu trúc của cây tại nút đó. Ưu tiên thực hiện zig-zag và roller-coaster trước. Phép quay nếu có thực hiện thì sẽ chỉ thực hiện một lần và là lần cuối khi đưa  lên làm gốc. Ví dụ ta muốn splay nút  của cây trái nhất trong hình sau (hình được lấy từ [3]):
Ta có các bước sau:Giả mã của phép Splay như sau: 
Code C:Ta sẽ chứng minh bổ đề dưới đây ở phần phân tích cuối bài. Bây giờ ta có thể thực hiện được các thao tác cơ bản.Khi thực thi splay, thông thường đầu vào là một khóa  và chúng ta phải tìm nút  có khóa  đó và splay  thành gốc của cây Splay Tree.Để tìm kiếm một nút có khóa , ta sẽ tìm kiếm nút  có khóa  trong cây như tìm kếm trên Binary Search Tree. Nếu ta tìm thấy  có khóa  thì ta sẽ Spaly .  Nếu nút  đó không tồn tại, ta sẽ splay . Ví dụ với hình vẽ ở phần Splay, nếu đầu vào là khóa có giá trị  thì ta sẽ splay nút  vì khi ta tìm kiếm từ gốc đến  thì ta sẽ thấy khóa  sẽ không có ở trông cây và  là nút cuối cùng trên đường đi tìm kiếm đó. Giả mã như sau ( ở đây là nút gốc của Splay Tree): 
Code C:Thủ tục  tìm kiếm khóa  và trả lại nút  như mô tả ở trên. Chú ý là khóa của  có thể không bằng  trong trường hợp  không có trong cây Splay. Giả mã của thủ tục này như sau: 
Code C: Do mỗi khi tìm kiếm một nút , ta splay nút đó lên làm gốc. Do đó, các thao tác tìm kiếm tiếp theo đó sẽ ít tốn kém hơn.Bổ đề sau là hệ quả trực tiếp của Lemma 2: Để chèn một nút có khóa , trước hết ta sẽ chèn khóa vào cây như chèn cây nhị phân và sau đó splay nút vừa chèn.   
Code C:Bổ đề sau là hệ quả trực tiếp của Lemma 2: Để xóa một nút có khóa , ta làm theo các bước sau:   , , , Trackback link: Powered by  and 