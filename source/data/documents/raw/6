Giải thuật tham lam -- Greedy Algorithms
http://www.giaithuatlaptrinh.com/?p=198
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Tham lam là một trong những phương pháp phổ biến nhất để thiết kế giải thuật. Rất nhiều thuật toán nổi tiếng được thiết kế dựa trên tư tưởng của tham lam, ví dụ như thuật toán tìm đường đi ngắn nhất của Dijkstra, thuật toán cây khung nhỏ nhất của Kruskal, v.v. Trong bài này chúng ta sẽ tìm hiểu phương pháp thiết kế giải thuật này.  Bài toán như sau:  Tìm cách lưu trữ file sao cho việc truy xuất được hiệu quả nhất, biết rằng các file có xác suất truy cập như nhau.
 
Vì các file có xác suất truy cập như nhau, với một cách lưu trữ  cho trước, chi phí để truy xuất ngẫu nhiên một file có kì vọng là:  Cách lưu trữ file mà chúng ta có thể nghĩ đến ngay đó là các lưu các file nhỏ ở đầu đĩa từ và lưu các file lớn ở cuối đĩa từ. Vấn đề còn lại là chứng minh rằng cách lưu này là một cách lưu file tối ưu ( nhỏ nhất).  
 Giả sử tồn tại một cách lưu trữ tối ưu  và chỉ số  sao cho . Gọi  là hoán vị thu được từ  bằng cách đổi chỗ  và . Ta có:  Do đó, , trái với giả thiết  là cách lưu trữ tối ưu. 
Bằng cách sắp xếp theo chiều tăng của kích thước file, chúng ta có thể thực thi thuật toán trên trong thời gian . Bây giờ chúng ta hãy thay đổi bài toán một chút như sau:   Tìm cách lưu trữ file sao cho việc truy xuất được hiệu quả nhất.
 Với bài toán này, tổng chi phí để truy xuất file là:  Ta sẽ tổng quát hóa thuật toán ở Problem 1 như sau: lưu file theo tỉ lệ  tăng dần. Ta sẽ chứng minh rằng cách lưu file này có tổng chi phí nhỏ nhất:  
 Tương tự như chứng minh ở Theorem 1, ta giả sử tồn tại một cách lưu trữ tối ưu  và chỉ số  sao cho . Gọi  là hoán vị thu được từ  bằng cách đổi chỗ  và . Ta có:  Do đó, , trái với giả thiết  là cách lưu trữ tối ưu. 
Ta xét bài toán phức tạp hơn sau: 
Ví dụ: ở hình dưới đây (lấy từ [1]), mỗi môn học được biểu diễn bởi một thanh ngang có chiều dài . Tập các thanh màu xanh chính là một tập có số lượng lớn nhất các môn học không gối lên nhau:

Bài toán này có thể giải bằng phương pháp  với thời gian . Chi tiết coi như bài tập cho bạn đọc.  Ở đây mình đưa ra cách giải bằng phương pháp tham lam. Có 3 cách lựa chọn lớp học tham lam mà bạn có thể nghĩ đến:Thuật toán như sau: 
Code của giả mã bằng C:Dễ dàng thấy thuật toán trên có thể được thực thi trong thời gian . Việc còn lại của chúng ta là chứng minh thuật toán trên cho chúng ta tập các lớp không gối lên nhau có kích thước lớn nhất. 
 Giả sử  là tập các lớp học đầu ra của thuật toán tham lam và  là một phương án tối ưu (), sắp xếp theo chiều tăng dần của thời gian hoành thành. Gọi  là tập  phần tử đầu tiên của . Trong số các phương tối ưu, chọn phương án  sao cho  là lớn nhất. Nếu , ta có  vì nếu không, ít nhất một lớp học nữa sẽ được thêm vào . Do đó,  là một phương án tối ưu. Giả sử . Suy ra tồn tại  sao cho .  Ta chọn  nhỏ nhất thỏa mãn . Như vậy . Do  là lớp học có thời gian hoành thành sớm nhất sau khi  đã hoàn thành, thời gian hoành thành của  sớm hơn . Suy ra  kết thúc trước khi  bắt đầu. Ngoài ra,  (chứng minh coi như bài tập cho bạn đọc, xem lời giải trong phần ). Xét , i.e,   Dễ thấy,  và các lớp trong  không gối lên nhau. Do đó  là một phương án tối ưu. Tuy nhiên , trái với cách chọn  là phương án có  lớn nhất. Do đó,  là phương án tối ưu. Phương pháp chứng minh bằng phản chứng cho bài toán chọn lớp học cũng là một phương pháp chứng minh phổ biến để chứng minh thuật toán tham lam là tối ưu. Ta có thể rút ra các bước như sau:Bạn có thể thử phương pháp trên cho bài toán lưu trữ file trên đĩa từ. Giờ chúng ta thử áp dụng ý tưởng đó vào bài toán sau: 
Ví dụ bạn có 5 tác vụ với thông tin như sau:Phương án tối ưu là (theo trình tự thực thi)  với tổng tiền thưởng thu được là 142.Tư tưởng tham lam của bài toán này rất đơn giản như sau: Trong tập các tác vụ chưa được chọn, chọn tác vụ có tiền thưởng lớn nhất nếu tác vụ này vẫn còn thực thi được. Ở đây ta luôn duy trì một danh sách các tác vụ đã chọn và một tác vụ gọi là thực thi được nếu ta thêm tác vụ này vào danh sách đó, vẫn tồn tại một cách thực thi sao cho tất cả các tác vụ được hoàn thành trước thời hạn.Áp dụng với ví dụ trên, đầu tiên ta chọn tác vụ , sau đó là chọn tác vụ  với trình tự . Ứng viên tiếp theo là , tuy nhiên ta không thể thực thi toàn bộ  trước thời hạn, do đó ta bỏ qua . Tương tự như vậy, tác vụ  cũng không thể được chọn và cuối cùng ta chọn . Như vậy, thuật toán tham lam sẽ cho ta các tác vụ  theo đúng trình tự thực hiện này. Giả mã như sau: 
Code của thuật toán bằng C:Dễ thấy thuật toán trên có thể được thực thi trong thời gian . Trong bài , mình sẽ giới thiệu phương pháp sử dụng cấu trúc Union-Find để giảm thời gian xuống còn . Nếu các tác vụ đầu vào đã được sắp xếp theo chiều giảm dần của tiền thưởng, chúng ta còn có thể giảm  thời gian xuống còn  trong đó  là hàm Ackerman ngược. Hàm  tăng cực kì chậm và  với mọi giá trị thực tế của . Do đó có thể coi   xấp xỉ .Vấn đề còn lại là chứng minh rằng thuật toán tham lam cho lời giải tối ưu. 
 Chúng ta sẽ chứng minh theo các bước đã chỉ ra ở trên. Gọi  là tập các tác vụ đầu ra của thuật toán tham lam, sắp xếp theo chiều giảm dần cuả tiền thưởng. Gọi  là tập các tác vụ tối ưu, sắp xếp như . Các tác vụ có phần thưởng bằng  nhau trong  sẽ được sắp xếp ưu tiên theo thứ tự trong . Ví dụ  chứa  tác vụ  mà , trong đó  xuất hiện trong  và tác vụ  được chọn trước  trong  thì ta sắp xếp chúng theo thứ tự  trong .Nếu , ta suy ra  vì nếu không, thuật toán tham lam sẽ chọn thêm ít nhất một phần tử nữa vào . Chọn  sao cho  là lớn nhất. Gọi  là chỉ số nhỏ nhất sao cho . Ta có  vì nếu không thuật toán tham lam sẽ chọn . Theo cách sắp xếp , ta suy ra . Giả sử tồn tại một tác vụ  có thời hạn sớm hơn hoặc bằng . Nếu , ta có thể đổi chỗ  và , qua đó thu được phản chứng theo như lập luận ở trên. Do đó, , nhưng điều đó có nghĩa là . Suy ra, không có tác vụ nào trong  có thời hạn sớm hơn hoặc bằng . Gọi  là một lịch trình thực thi các tác vụ trong  và gọi  là số nhỏ nhất sao cho . Do đó, theo như lập luận ở trên, ta có  và . Vì  có một lịch trình thực thi sao cho mọi tác vụ đều trước thời hạn, bằng cách thay thế  bởi , ta thu được lời giải tối ưu khác  với , qua đó thu được phản chứng.Code: , .[1] Jeff Erickson. , UIUC.
[2] George Kocur, MIT OWC , MIT.
[3] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. . MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7. , Trackback link:  on                     Bài toán lập lịch có vấn đề trong chứng minh rồi. Phản ví dụ :1   100  3
2    80   3
3     1    1Nếu theo trình tự thì đc 180 đồng. Nhưng theo trình tự 3-2-1 thì đc 181 đồng cơ on                     Hi bạn.
Hình như bạn hiểu sai thuật toán. Khi thuật toán chọn một việc để đưa vào tập lời giải, nó sẽ không thực thi ngay. Theo ví dụ của bạn, thuật toán sẽ chọn Job 1 và 2 trước (nhưng nó sẽ không thực thi ngay). Khi xét Job 3, thuật toán sẽ kiểm tra xem có lịch nào để thực thi được cả 1,2,3 hay không (trong trường hợp này là có). Do đó, nó sẽ chọn Job 3 đưa vào lời giải. Cuối cùng kết quả vẫn là 181. Mình trích lại thuật toán: "Trong tập các tác vụ chưa được chọn, chọn tác vụ có tiền thưởng lớn nhất nếu tác vụ này vẫn còn thực thi được. Ở đây ta luôn duy trì một danh sách các tác vụ đã chọn và một tác vụ gọi là thực thi được nếu ta thêm tác vụ này vào danh sách đó, vẫn tồn tại một cách thực thi sao cho tất cả các tác vụ được hoàn thành trước thời hạn"Hùng on                     Vâng ạ em đã hiểu, em đã đọc kỹ bài này thì duy chỉ có cái chứng minh Theorem 4 em thấy nó hơi tối với khó hiểu một tý, anh có thể xem lại và chỉnh sửa cho nó sáng sủa một tý không ạ. Chẳng hạn chỗ P[y_i] <= P[x_i] rồi suy ra x_i không thuộc Y là chưa chặt chẽ. Nếu dấu bằng xẩy ra P[y_i] = P[x_i] thì có thể có x_i thuộc Y chứ. on                     Đúng là phần suy diễn  chưa chặt chẽ. Ở đây mình sẽ phải sửa lại cách sắp xếp  sao cho nếu  thì  sẽ không phải là chỉ số lớn nhất mà . Cám ơn bạn đã chỉ ra lỗi này. on                     Mình lại phát hiện ra một lỗi sai rất tinh vi trong chứng minh Theorem 3 của anh. Ở cái chỗ Xét Y' ..... ấy. Lỡ y_i thuộc vào tập X thì sao, lúc đó anh bỏ đi y_i rồi lại thêm vào x_i sẽ không làm tăng số phần tử chung lên.Vì vậy ta phải thêm lý luận sau : Nếu y_i thuộc vào X thì mút trái của nó phải lớn hơn mút phải của x_i, do cách thuật toán tham lam chọn x_i. Vì vậy ta có thể bổ sung phần tử x_i vào giữa 2 phần tử y_i-1 và y_i trong phương án tối ưu để tạo ra một phương án còn lớn hơn, mâu thuẫn. on                     Hi bạn,
Đúng là chứng minh đầy đủ cần phải có phần lập luận của bạn. Cám ơn bạn đã chỉ ra. Mình sẽ link vào phần chứng minh coi như bài tập nhỏ.HùngPowered by  and 