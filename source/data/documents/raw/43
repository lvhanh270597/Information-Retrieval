Thuật toán Pollard-Rho phân tích ra thừa số-- Pollard-Rho algorithm
http://www.giaithuatlaptrinh.com/?p=393
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Bài này là tiếp nối của  về bài toán phân tích ra thừa số. Trong bài này, chúng ta sẽ thảo luận thuật toán Pollard-Rho được đề xuất bởi Pollard [1] và năm 1975. Độ phức tạp của thuật toán là .  Chúng ta tạm quên bài toán phân tích ra thừa số để xét hai bài toán thú vị sau: Như ta đã biết theo nguyên lý Dirichlet (hay ), trong 366 người thì sẽ có ít nhất hai người có cùng ngày sinh (không tính năm nhuận nhé). Không có gì đặc biệt trong phát biểu này. Tuy nhiên nhìn dưới quan điểm của xác suất thì mở rộng của phát biểu này có những tính chất rất thú vị.  Theo quan điểm của xác suất, phát biểu trên có thể được phát biểu lại như sau: trong 366 người, xác suất tìm được hai người có cúng ngày sinh  là . Giả sử xác xuất một người bất kì có ngày sinh vào một ngày nào đó trong năm là .  Ta mở rộng phát biểu đó ra bài toán sau: 
Lời giải của bài toán trên vô cùng kinh ngạc: chỉ cần 23 người. Lời giải đó minh họa cho một nghịch lí mà người ta gọi là ngịch lí ngày sinh nhất (). Gọi  là sự kiện trong  người không có hai người nào có cùng ngày sinh. Cố định ngày sinh của người thứ nhất. Ta có:Do đó, ta có:  Với , ta có () , do đó, xác suất để ít nhất hai người có cùng ngày sinh là .  
 Bằng phân tích tương tự như trên, xác suất để không có hai người nào trong số  người có cùng ngày sinh trong thế giới  là:  Giả sử  nhỏ hơn nhiều so với  (như  với  cũng là nhỏ hơn nhiều rồi), sử dụng xấp xỉ , ta có:  Thay  thì ta có . Từ đó suy ra xác suất tìm được hai người có cùng ngày sinh ít nhất là .  Để giải bài toán này, chúng ta có thể tiến hành duyệt danh sách từ phần tử , lưu giữ thông tin về những phần tử đã duyệt qua. Mỗi lần duyệt đến phần tử mới, ta lại so sánh với các phần tử đã duyệt qua để phát hiện vòng. Thuật toán này sẽ mất thời gian  và bộ nhớ .
Tuy nhiên, thuật toán rùa và thỏ (, hay còn gọi thuật toán Floy) sẽ cho ta lời giải với thời gian  và bộ nhớ .  Như cái tên của thuật toán, ta sẽ sử dụng hai con trỏ. Một con trỏ "chạy" với vận tốc  và con kia "chạy" với vận tốc . Nếu hai con trỏ gặp nhau thì danh sách có vòng. Giả mã như sau: 
Bây giờ chúng ta sẽ quay trở lại bài toán phân tích ra thừa số.Thuật toán Pollard kết hợp ý tưởng từ hai bài toán tưỏng chừng như chả liên quan gì ở trên. Để việc phân tích và trình bày thuật toán đơn giản, giả sử  trong đó  là hai số nguyên tố. Việc mở rộng phân tích ra trường hợp tổng quát coi như bài tập cho bạn đọc.Giả sử ta chọn  số ngẫu nhiên  trong khoảng . Xét dãy . Nếu tồn tại hai số  sao cho , thì ta có . Từ đó suy ra  chia hết cho . Do đó ta có thể tính:   Tính ước chung lớn nhất có thể được thực hiện khá hiệu quả, sử dụng  thao tác bít. Một câu hỏi đặt ra là cần sinh bao nhiêu số ngẫu nhiên  thì xác suất tìm được  là khá cao? Nếu phân tích kĩ bài toán này thì đây chính là bài toán trong nghịch lý ngày sinh. Thế giới  ở đây chính là "thế giớ" đồng dư modulo  và số ngày ở đây là . Do đó, nếu chọn  thì xác suất tìm được hai số  (ta gọi là cặp số tốt) như vậy ít nhất là . Để tăng xác suất tìm được cặp số tốt, ta chỉ việc tăng  lên. Cụ thể, nếu tăng  lên   thì xác suất là  (chứng minh coi như bài tập - chỉ cần mở rộng chứng minh ở trên). Ví dụ ta muốn xác suất là  thì ta sẽ tăng  lên  (). Nhưng ở đây ta đang đi tìm , làm sao ta xác định được ? Thực tế, ta không cần xác định   mà ta cứ sinh ngẫu nhiên  (có thể vô hạn) cho đến khi ta tìm được  thỏa mãn . Phân tích trên chỉ ra rằng quá trình sinh đó sẽ . Gỉa sử ta đã sinh được  số ngẫu nhiên và ta cũng đã biết rằng sẽ tồn tại một cặp số tốt trong số các số đã sinh đó. Để tìm cặp số tốt này, ta phải duyệt qua  cặp. Thời gian để duyệt đó là  (nhắc lại ); cách này không tốt hơn thuật toán  mà chúng ta đã biết. Wait! Bài toán phát hiện vòng trong danh sách liên kết có thể có liên quan gì đó ở đây? Sự thông minh của thuật toán Pollard chính là ở chỗ này.Để giải quyết vấn để này, Pollard đề xuất sử dụng một hàm giả ngẫu nhiên để sinh dãy . Hàm đơn giản nhất thỏa mãn tính chất này là:   Mình không đi sâu giải thích tại sao, Knuth [2] là nguồn tham khảo khá đầy đủ của vấn đề này. Như vậy, ta sẽ chỉ sinh một số  hoàn toàn  ngẫu nhiên và các phần tử còn lại sẽ sinh được sinh dựa trên . Dãy số ngẫu nhiên ta thu được cuối cùng là:  Do dãy  được sinh bởi hàm , nếu tồn tại  thì ta dễ dàng suy ra:  Nói cách khác, ta sẽ có một vòng (cycle) trong các dãy số bở  khi lấy  (giống như hình vẽ vòng của danh sách liên kết ở trên). Để tìm được giá trị  thỏa mãn  (hay tương đương với ), ta chỉ cần phát hiện ra vòng trong dãy này. Đó chính là vấn đề chúng ta đã giải quyết trong phần phát hiện vòng của danh sách liên kết. Như vậy, ta đã có đầy đủ các công cụ cần thiết để thực thi thuật toán Pollard. Giả mã như sau:   
Code của giả mã bằng C. Code đầu đủ được đính ở cuối bài:Thủ tục  kiểm tra xem  có phải là số nguyên tố hay không sử dụng .Chú ý do các phân tích trên chỉ đúng khi  đủ lớn. Do đó, nếu  quá nhỏ, ta có thể sử dụng thuật toán  (chính là dòng  trong giả mã trên). 
Gọi  là ước số nguyên tố nhỏ nhất của . Gọi  là thời gian để thuật toán tìm được . Do  có tối đa  ước số (xem phần phân tích thuật toán của ), thuật toán sẽ mất  để phân tích  thành các thừa số nguyên tố. Theo phân tích ở trên, thủ tục  () có thời gian kì vọng là  để tìm ra một thừa số   của  (có thể không nguyên tố do phép lấy ước chúng ở dòng  của giả mã) mà  là một thừa số nguyên tố của . Sau khi đã tìm được , thuật toán tiếp tục gọi đệ quy để tìm . Nếu  không quá nhỏ (nếu không ta có thể tìm được  với thời gian hằng số), ta sẽ tiếp tục sử dụng (), trong thời gian kì vọng , để tìm ra một thừa số của  mà  là một thừa số nguyên tố của . Tiếp tục như vậy, ta sẽ phả mất thời gian là , trong đó  là số thừa số nguyên tố của . Do , ta có .  Do đó, ta có: Code: .[1] Pollard, J. M. (1975). , BIT Numerical Mathematics 15 (3): 331–334.
[3] Knuth, Donald E.  Seminumerical Algorithms (1981).
[3] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 31. MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7 , , , Trackback link:  on                     Vì sao T(n) = 4√N . logN , thời gian tính là O(T(N)logN) mà kết quả định lý lại là O(4√N) ạ. Với lại chỗ Knuth giải thích cho việc chọn f(x)=x^2+1 nằm ở phần nào của quyển sách vậy ạ.
Cám ơn a ạ. on                     Hi BK,
Cám ơn bạn đã đặt câu hỏi. Về câu hỏi đầu tiên, bạn chú ý  và  là hai kí hiệu khác nhau.  Kí hiệu  sẽ bỏ qua nhân tử  vì nó quá bé so với  khi  đủ lớn. Kí hiệu  ít được dùng trong khoa học máy tính. Mình dùng kí hiệu này vì nó cho biểu thức đẹp hơn.Về câu hỏi 2, bạn xem trang 369, đoạn văn cuối cùng, của Vol 2, TAoCP. Hùng on                     Vâng ạ, cám ơn a nhiềuPowered by  and 