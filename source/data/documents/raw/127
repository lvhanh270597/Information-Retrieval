Quy hoạch động -- Dynamic Programming V
http://www.giaithuatlaptrinh.com/?p=130
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong bài này chúng ta thảo luận giải thuật quy hoạch động để giải bài toán Người Du Lịch (Traveling Salesman Problem - TSP). Giải thuật này được đề xuất bởi  và cũng được đề xuất độc lập bởi  Bellman vào năm 1962. 
Bài toán như sau: 
Ví dụ: Các thành phố và chi phí giữa chúng được cho bởi hình bên trái của hình dưới đây. Một hành trình tối ưu với tổng chi phí 18 được cho bởi hình bên phải.
Bài toán này có thể được giải bằng phương pháp  với thời gian . Trong bài này mình sẽ giới thiệu lời giải bằng quy hoạc động với thời gian  và thảo luận một phương pháp thực thi bằng C.Giả sử , , là một hành trình tối ưu đi từ thành phố  đến thành phố  qua  thành phố khác và quay lại . Vì hành trình  là tối ưu, hành trình  đi từ  tới  qua các thành phố   cũng phải là hành trình tối ưu. Như vậy, nếu gọi  là chi phí nhỏ nhất đi từ  tới  qua các thành phố trong tập hợp  (không chứa ), ta có công thức đệ quy sau: Do đó, để tính , ta chỉ cần đảm bảo các giá trị   với  đã được tính trước. Giả mã như sau: 
Hàm  tính chi phí của hành trình từ  đến  qua mỗi thành phố trong  (không chứa ) chính xác 1 lần và được tính theo công thức đệ quy . Giả mã như sau:  Thời gian tính của thuật toán trên có thể được quy về thời gian cập nhật bảng Cost có kíc thước . Mỗi phần từ của bảng được cập nhật theo thủ tục  và mất thời gian . Do đó tổng thời gian tính toán của thuật toán là .
Thuật toán quy hoạch động của bài toán TSP cho bởi giả mã  không quá phức tạp. Tuy nhiên khi thực thi thuật toán bằng C hay một số ngôn ngữ khác khi mà các phép toán liên quan đến tập hợp chưa sẵn có thì có một số vấn đề chúng ta cần phải giả quyết:Trong phần này mình thảo luận một cách để thực thi bằng  với  và giới thiệu một số kĩ thuật xử lí bit. Trước hết đối với vấn đề số 2, chúng ta có thể mã hóa bằng cách gán cho mỗi tập con  của  một số duy nhất, gọi là ,  để việc truy xuất hay cập nhật  được hiệu qủa. Ta có thể mã hóa một tập con  của tập  phần tử bằng một số nguyên  bít , trong đó  nếu phần tử  và  nếu .  của  chính là giá trị của số nguyên đó. Ví dụ: , tập con  có thể được biểu diễn bởi số nguyên ở hình dưới đây, và có  . Việc chứng minh không có hai tập con khác nhau nào có cùng một  coi như bài tập cho bạn đọc.
.Như vậy chúng ta đã có cách để mã hóa mỗi một tập con thành một số nguyên duy nhất tương ứng. Phần tiếp theo của bài viết dùng một số các phép toán xử lí bít. Các phép toán cơ bản gồm có: AND (&), OR (|), XOR (^), NOT (~), SHIFT LEFT ( ). Ví dụ một số cách xử lí bít để tính các hàm cơ bản như: Bạn đọc có thể tham khảo thêm ở []Bây giờ ta giải quyết bài toán sinh các tập con kích thước  của tập hợp có kích thước . Ở đây ta sẽ sinh tập con theo thứ tự từ điển. Như vậy ta có thể quy về bài toán cho một tập con , tìm tập con tiếp theo có  phần tử theo thứ tự từ điển. Giả sử tập con  đó được cho dưới dạng mã hóa bit như trên, ta quy về bài toán: 
Ví dụ: , số nguyên tiếp theo sẽ là . Ta có thể nhận thấy là nếu  có  ( có thể bằng 0) bít cuối cùng là 0, trước đó là  bít 1 (như ở hình bên trái của hình dưới đây), thì  sẽ có  bít cuối là 1, trước đó là  bít 0 và trước  bít 0  đó là 1 bít 1 (như hình bên phải của hình dưới đây).

Như vậy để giải bài toán trên, ta tìm cách chuyển  thành  giống như trong hình trên. Giả mã (gần giống với C) như sau: 
Để bạn đọc không mất tập trung vào giải thuật chính, mình sẽ giải thích đoạn code này ở cuối bài. Code bằng C của giả mã như sau :Bài toán tiếp theo chúng ta phải giải đó là liệt kê các tập con: 
Với mỗi tập , mình dùng danh sách liên kết để lưu các tập con của  có kích thước . Đầu của danh sách lưu . Mỗi mắt xích gồm hai trường: trường  lưu mã của tập con  và trường  lưu phần tử . Giả mã được cho ở dưới, seed là  của tập con . 
Code bằng C của giả mã:Dựa vào thủ tục ( seed, ), ta có thể tính trước mảng Subsets, trong đó mỗi phần tử của mảng Subsets là một danh sách liên kết lưu các tập con có kích thước  của tập  có  là . Giả mã như sau: 
Code của giả mã bằng C:Như vậy, chúng ta đã giải quyết xong bài toán mã hóa các tập con và sinh các tập con của một tập  có kích thước . Vấn đề còn lại chỉ là ghép các phần lại với nhau để giải quyết bài toán. Giả mã của thuật toán như sau: 
Code bằng C của giả mã:Thủ tục (S, i)  
Code của giả mã bằng C:
Các thao tác trong hàm ( ,  ) được minh hoạ bởi hình sau:
Code: , 
[1] Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. . 1st Edition). McGraw-Hill Higher Education, (2008).
 . , , , Trackback link:  on                     Ad giải thích hộ mình đoạn công thức đệ quy với. đoạn minj thuộc s ấy. minj là gì và tính thế nào vậy ? on                     Hi bạn Hòa,Cám ơn bạn đã đặt câu hỏi. Theo như định  nghĩa của hàm Cost:  là chi phí nhỏ nhất đi từ  tới i qua các thành phố trong tập hợp  (không chứa i). Do đường đi với chi phí nhỏ nhất đi từ  tới i chỉ qua S, đường đi này phải đi qua một đỉnh  nào đó thuộc  trước khi đến i. Tức là đường đi có dạng . Do đó . Tuy nhiên ở đây ta không biết cụ thể  mà chỉ biết   thuộc . Do đó, ta phải duyệt qua tất cả các  có thể thuộc  và lấy min. Hi vọng đoạn này giải đáp thắc mắc của bạn.Hùng on                     Mình hiểu rồi. Cảm ơn bạn nhiều lắm on                     Không có gì đâu. Cám ơn bạn đã ghé thăm.Powered by  and 