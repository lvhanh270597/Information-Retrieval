Chọn thế nào là tốt? -- How to avoid bad cases?
http://www.giaithuatlaptrinh.com/?p=950
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong thiết kế giải thuật, đôi khi chúng ta phải đưa ra quyết định chọn một phần tử trong tập các lựa chọn để xử lí và sau đó, tiếp tục thực hiện thuật toán sau khi đã xử lí phần tử được chọn. Nếu chúng ta chọn được phần tử "đủ tốt" trong tất cả các bước, thuật toán của chúng ta sẽ chạy với thời gian rất nhanh. Ví dụ trong thuật toán , nếu phần tử chốt mà ta chọn trong mỗi bước là  (trung vị) của mảng con chưa sắp xếp thì thuật toán của chúng ta sẽ là  với hằng số ẩn sau  khá nhỏ.Tuy nhiên, làm thế nào để chọn được phần tử "đủ tốt" là một vấn đề không hề dễ và đôi khi mất không ít thời gian vì chí ít ta cũng cần phải duyệt qua tất cả các lựa chọn để tìm ra phần tử đủ tốt đó. Ví dụ với Quicksort, chúng ta có thể áp dụng thuật toán  để chọn median trong thời gian . Tuy nhiên làm như vậy thì thuật toán Quicksort  cuối cùng sẽ có hằng số ẩn sau  quá lớn.Trong những trường hợp như Quicksort, chọn ngẫu nhiên, như sẽ chỉ ra dưới đây, sẽ cho chúng ta một giải pháp không quá tệ. Việc chọn ngẫu nhiên theo nguyên lí trên thường sẽ khiến cho thực thi thuật toán của chúng ta sẽ trở nên đơn giản hơn rất nhiều. Tuy nhiên, khó khăn sẽ nằm ở phần phân tích thuật toán và đây cũng là điểm yếu của các thuật toán ngẫu nhiên. Trong thực tế thì những giải thuật kiểu "thực thi đơn giản, phân tích khó khăn" thường được ưu tiên hơn là "thực thi khó khăn, phân tích đơn giản". Chúng ta sẽ tìm hiểu hai ví dụ áp dụng nguyên lí trên: Quicksort và chọn median. Trước khi đọc tiếp, mình khuyến khích bạn đọc xem lại h trước đây về . Ngoài ra, xem lại Appendix về  và bài  cũng sẽ giúp bạn tư duy tốt hơn trong phần phân tích mà mình sẽ trình bày. : Giả sử ta muốn sắp xếp mảng đầu vào . Để đơn giản ta sẽ giả sử các phần tử của mảng  đôi một khác nhau. Thuật toán gồm hai bước:Trong trường hợp lí tưởng, phần tử pivot  trong mỗi bước mà ta chọn là median thì hai phần sẽ có kích thước bằng nhau và bằng cỡ . Do đó thời gian sắp xếp của Quicksort thỏa mãn: . Từ đó suy ra . Chi tiết các bạn xem thêm tại .  Giả mã như sau:  Trong trường hợp xấu nhất, mỗi bước ta đều chọn phải phần tử pivot  mà hai phần có độ dài lệch nhau quá lớn thì thời gian của Quicksort sẽ là . Để tránh trường hợp xấu nhất này ta sẽ chọn  ngẫu nhiên. Thuật toán trở thành: Dòng màu đỏ chính là sự khác nhau của Quicksort và Quicksort ngẫu nhiên. Sự thay đổi này, như ta đã thấy, là khá đơn giản. Bây giờ chúng ta sẽ phân tích thuật toán. Do thời gian của thuật toán sẽ tỉ lệ với số phép so sánh, ta sẽ tính kì vọng số phép so sánh của thuật toán trên. Trước hết ta có nhận xét đơn giản sau: Hai phần tử bất kì của mảng được so sánh với nhau tối đa 1 lần và chúng chỉ được so sánh với nhau khi một trong hai phần tử đó được chọn là pivot tại bước nào đó của thuật toán. Gọi  là số lượng phép so sánh trong quá trình thực thi . Với mỗi cặp chỉ số  sao cho , ta định nghĩa biến ngẫu nhiên 0/1  như sau:  nếu phần tử nhỏ tứ  của mảng được so sánh với phần tử nhỏ thứ  của mảng và  nếu ngược lại.



  Như vậy, ta sẽ có:   Theo tính tuyến tính của kì vọng:  Do  là biến ngẫu nhiên 0/1, ta suy ra . Do đó, tính  sẽ được quy về tính các xác suất . Theo nhận xét ở trên,  chính là xác suất phần tử nhỏ thứ  hoặc thứ  sẽ được chọn làm pivot trong một bước nào đó. Tưởng tượng ta xếp các phần tử của mảng trên trục đường thẳng trong đó phần tử nhỏ thứ   của mảng sẽ được sắp xếp vào điểm có tọa độ . Nếu bất kì phần tử nào trong khoảng  (loại trừ hai đầu mút) được chọn làm pivot tại một bước nào đó thì hai phần tử nhỏ thứ  và thứ  sẽ không có cơ hội được so sánh với nhau. Do đó, xác suất để một trong hai phần tử đó được chọn làm pivot sẽ là:  Số  chính là độ dài của đoạn . Kết hợp với   ta suy ra:   Phương trình thứ 2 của  là do ta áp dụng công thức  ở Appendix .   Phân tích trên đây được viết ở phần mở đầu của cuốn sách nổi tiếng về Randomized Algorithms của Rajeev Motwani and Prabhakar Raghavan [1]. Mình khuyến khích bạn đọc xem thêm note của Avrim Blum [2]; trong đó Blum còn đưa ra cách phân tích khác dựa trên giải một phương trình đệ quy.  Bài toán như sau: Cho một mảng , tìm phần tử lớn thứ  của mảng. Thuật toán gồm hai bước:Giả mã: Chọn  như thế nào cũng lại là một vấn đề của bài toán này. Nếu chúng ta may mắn, mỗi bước ta đều chọn được  là phần tử chia mảng thành hai phần gần bằng nhau thì thuật toán ta thu được là . Nếu không may thì có thể sẽ là .Ý tưởng chính trong thuật toán  của Blum,Floyd,Pratt,Rivest và Tarjan đó là chọn ra được pivot  đủ tốt trong thời gian . Thuật toán bao gồm các bước sau: (1) Chia  thành  khối, mỗi khối có kích thước là . (2) Tìm  phần tử, mỗi phần tử là median của một khối đã chia ở bước . Gọi  là tập các phần tử đó. (3) Gọi đệ quy tìm trung vị của , lấy trung vị đó làm phần tử . (4) Thực hiện như giải thuật ban đầu với  vừa chọn được. Bằng các phân tích cụ thể hơn, thuật toán cuối cùng cũng có thời gian . Tuy nhiên, hằng số ẩn sau big-O cũng không hề nhỏ. Chi tiết bạn đọc xem thêm tại .Trong bài này, ta sẽ thay đổi 1 dòng trong  để thu được thuật toán ngẫn nhiên khá đơn giản mà cũng hiệu quả: Tất cả những khó khăn lại nằm trong phần phân tích. Ta sẽ quy về phân tích số lượng phép so sánh cần thiết để tìm ra phần tử mong muốn. Gọi  là số lượng phép so sánh kì vọng để chọn ra phần tử lớn thứ  của mảng gồm  phần tử. Gọi . Phân tích dựa trên bài toán sau đây: Rùa và Thỏ cùng nhặt được một thanh kẹo chocolate có chiều dài 1. Do không biết chia thế nào cho công bằng, Thỏ đề xuất nhờ bác Gấu già chia thanh kẹo đó. Bác Gấu, do không còn tinh mắt, chọn một điểm ngẫu nhiên trên thanh kẹo và bẻ thành hai phần. Thỏ tham ăn và nhanh tay hơn nên luôn chọn phần to còn Rùa thì chỉ được phần nhỏ. Hỏi kì vọng chiều dài thanh kẹo của Thỏ là bao nhiêu? Đáp án là . Nếu bạn nào muốn xem chi tiết lời giải thì xem . Chú ý trong bài toán trên, miền của bài toán là miền liên tục.Trở lại bài toán của chúng ta. Coi mảng  như một "thanh chocolate rời rạc" có chiều dài  và coi việc chọn phần tử pivot   như "bẻ thanh chocolate" tại một điểm ngẫu nhiên. Ở đây, sự khác biệt cơ bản so với bài toán bẻ chocolate ở trên đó là miền của chúng ta là rời rạc. Tuy nhiên, chiều dài kì vọng của phần lớn hơn vẫn không vượt quá . Xem chi tiết . Sau khi đã bẻ, trong trường hợp tồi nhất, chúng ta sẽ phải đệ quy trên phần dài nhất để tìm kiếm. Do đó, ta có:  Số  chính là số phép so sánh để chia mảng thành hai phần sau khi đã chọn được pivot. Giải công thức truy hồi trên ta được . Như vậy:  Phần phân tích thuật toán  là do Avrim Blum [3]. Thực tế phân tích này chỉ đưa cho bạn một cách nhìn trực quan về bài toán mà chưa phải là một phân tích "tỉ mỉ và chính xác" về mặt toán học. Bạn có thể xem cách phân tích tỉ mỉ hơn (ý tưởng thì vẫn như vậy) trong note [3].Vấn đề đầu tiên đó là thời gian thực tế của thuật toán ngẫu nhiên. Trong hai phân tích ở trên, chúng ta biết rằng  và  có thời gian chạy  lần lượt là  và . Tuy nhiên, trong thực tế, đôi khi thuật toán cuả chúng ta chạy nhanh hơn thời gian kì vọng và đôi khi lại chạy chậm hơn thời gian kì vọng vì giá trị của một biến ngẫu nhiên tại một thời điểm nào đó có thể nhỏ hơn hoặc lớn hơn hoặc nhỏ hơn giá trị kì vọng. Về mặt lý thuyết thì thuật toán thực tế có thể chạy lâu hơn  kì vọng nhiều lần và trong một số trường hợp (không phải hai thuật toán trong bài này) thuật toán không dừng (lặp vô hạn). Tuy nhiên, xác suất trường hợp như vậy xảy ra thường vô cùng nhỏ và khó có thể xảy ra trong thực tế. Để định lượng xem khả năng thuật toán chạy chậm hơn kì vọng, ví dụ 10 lần, là bao nhiêu thì chúng ta cần phải dùng đến những công cụ từ lý thuyết xác suất. Chính vì thế mà việc phân tích giải thuật ngẫu nhiên một cách đầy đủ thường khó hơn rất nhiều so với các phân tích ở trên. Ở đây mình sẽ giới thiệu và sử dụng bất đẳng thức Markov. Bất đẳng thức này khá đơn giản, vì thế nên các kết quả thu được cũng chưa thực sự mạnh.    Từ bất đẳng thức Markov, ta dễ dàng suy ra xác suất để thuật toán chạy chậm hơn kì vọng 10 lần () là không quá . Thực tế, các thuật toán này chạy lớn hơn 3 lần kì vọng với xác suất rất nhỏ. Tuy nhiên, để phân tích được điề unày thì cần đến công cụ rất mạnh như bất đẳng thức . Mình sẽ không đi sâu hơn vì vấn đề này vượt quá phạm vi của bài viết.Vấn đề thứ hai nằm trong chính sự ngẫu nhiên. Ở đâu mà ta có ngẫu nhiên và làm thế nào để chọn được một phần tử ngẫu nhiên trong máy tính? Câu hỏi này không hể đơn giản và có cả một ngành khoa học chuyên nghiên cứu về nó. Để đạt được một nguồn ngẫu nhiên thực sự là một việc không dễ dàng. Các nguôn ngẫu nhiên mà ta thường sử dụng trong máy tính (ví dụ sử dụng các hàm random để sinh số ngẫu nhiên trong máy tính) là . Các nguồn này trông hơi giống ngẫu nhiên (do ta khó đoán được quy luật của các số sinh ra) nhưng không thực sự là ngẫu nhiên. Trong thực thi các giải thuật, ta chấp nhận các nguồn giả ngẫu nhiên này thay cho nguồn ngẫu nhiên thực sự. [1] Rajeev Motwani and Prabhakar Raghavan.. Cambridge University Press, New York, NY, USA, 1995.
[2] Avrim Blum. . CMU, 2011.
[3] Avrim Blum. . CMU, 2011.
[4] Michael Mitzenmacher and Eli Upfal. Probability and Computing: Randomized Algorithms and Probabilistic Analysis. Cambridge University Press, New York, NY, USA, 2005. , , , , Trackback link:  on                     ở phần Một số vấn đề nếu viết Pr[X > E[X]] thì phải nói là xác suất để thuật toán chạy CHẬM hơn so với kỳ vọng chứ e toàn thấy anh viết là nhanh hơn, như vậy dễ gây hiểu lầm lắm. ^^ on                     Hi Hoahuongduong,Bạn nói đúng! Mình đã sửa lại bài viết. Cám ơn bạn đã comment. HùngPowered by  and 