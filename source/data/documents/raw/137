DFS, phân loại cung và sắp xếp Topo -- DFS, Arc Classification and Topological Sort
http://www.giaithuatlaptrinh.com/?p=590
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong , chúng ta đã làm quen với thuật toán duyệt theo chiều sâu DFS trên đồ thị (vô hướng). Chúng ta cũng chưa có dịp để thảo luận về các ứng dụng của thuật toán DFS mặc dù đây là một thuật toán có rất nhiều ứng dụng trong thiết kế giải thuật. Trong phần này chúng ta sẽ làm quen với ứng dụng của DFS trong bài toán sắp xếp Topo (Topological Sort). . Để dễ phân biết, ta kí hiệu đồ thị có hướng là . Đồ thị vô hướng thu được từ  bằng cách bỏ qua hướng của cạnh ta sẽ kí hiệu là . Một số khái niệm khác ở  chúng ta sẽ không nhắc lại ở đây nữa. Giả mã của thuật toán DFS cơ bản thăm đồ thị  như sau:  Gọi  là các đỉnh được thăm ở dòng . Một đỉnh  được gọi là  (reachable from ) nếu tồn tại một đường đi có hướng từ  tới . Dễ thấy với mọi , đỉnh  nằm trong tầm với một trong các đỉnh  của . Bây giờ ta muốn xem mỗi đỉnh  nằm trong tầm với của đỉnh nào trong . Một đỉnh  có thể nằm trong tầm với của hai hay nhiều đỉnh khác nhau trong , nhưng ở đây ta chỉ quan tâm để đỉnh đầu tiên trong , i.e, đỉnh có chỉ số nhỏ nhất, mà  nằm trong tầm với của đỉnh đó. Ngoài ra, nếu  nằm trong tầm với của , ta muốn in ra đường đi từ  đến . Ta gọi mỗi đỉnh  là  của .Để thu được thông tin đó, ta sẽ sửa đổi DFS một chút bằng cách thêm một vài mảng đánh dấu. Ta sử dụng mảng  trong đó  nếu  là nguồn của . Ban đầu khởi tạo  với mỗi . Để lưu vết đường đi từ  đến , ta sẽ lưu một mảng  trong đó  nếu cung  nằm trong đường đi từ  tới . Hay nói cách khác,  đứng ngay trước  trong đường đi có hướng từ  tới . Ta gọi cung  là  bởi DFS. Khi ta đã có mảng  thì đường đi từ  tới  (viết theo thứ tự ngược) là:  .
Thủ tục in ra đường đi từ  tới  theo thứ tự ngược (in thứ tự xuôi coi như bài tập cho bạn đọc): 
Code C:Giả mã của DFS sửa đổi:  Code C:Ví dụ thực thi thủ tục trên trong hình dưới đây. Các cung màu đỏ là các cung được thăm bởi DFS. Nhìn vào hình vẽ ta thấy các cung này sẽ tạo thành một rừng (forest) gọi là  (DFS forest), trong đó gốc của mỗi cây (đỉnh được tô màu) trong rừng là một đỉnh trong . Ta sẽ chứng minh điều này một cách hình thức hơn trong Lemma 1.Gọi  là tập các cung được thăm bởi DFS. Ta có:  
 Ta sẽ chứng minh mỗi  là một cây có hướng gốc tại . Việc chứng minh các đỉnh của  đều đến được từ  coi như bài tập cho bạn đọc. Từ thủ tục DFS ở trên, ta có nhận xét: Mỗi đỉnh , tồn tại duy nhất một đỉnh  sao cho .Xét cây vô hướng tương ứng , giả sử  có ít nhất một chu trình. Xét một chu trình  (vô hướng) nào đó của  có  đỉnh. Gọi  là một đỉnh của  được thăm đầu tiên bởi DFS. Gọi  là thứ tự các đỉnh dọc theo  sao cho  kề với . Do  là đỉnh được thăm đầu tiên,  được thăm sau . Do các cạnh thăm bởi DFS đều có dạng  và  là duy nhất, ta suy ra . Lập luận tương tự ta có:   Do , ta dễ dàng suy ra  hoặc . Do   và , ta có  . Nhưng điều này trái với giả thiết  là đỉnh được thăm đầu tiên của . Do đó, chu trình  không tồn tại. Hay nói cách khác,  là một cây.Xét các cung được thăm và không được thăm bởi DFS, ta có 4 loại cung sau:Các cung của cây DFS khá là dễ phân bệt và đó chính là cung  trong đó  là đỉnh được gọi ở dòng  (trong giả mã có đoạn mã màu đỏ ở trên). Trong điều kiên ở vòng for ở thủ tục , các cung  mà  là visitted sẽ có thể là một trong 3 loại cung: chéo, ngược hoặc xuối. Do đó, chỉ với hai nhãn này thì ta chưa phân biết được cung ngược với các cung khác (bài này ta chưa cần phân biệt cung chéo và cung xuôi). Nhắc lại, cung ngược là cung từ một đỉnh  tới một đỉnh tổ tiên của nó trong cùng một cây của rừng DFS.Để phát hiện ra cung xuôi ta phải dùng thêm một nhãn nữa là nhãn , bên cạnh hai nhãn là visitted và unvissited.  Ý nghĩa các nhãn như sau: Dựa vào định nghĩa của các nhãn, ta suy ra:  khi đang thăm đỉnh  (có nhãn visitting), nếu ta bắt gặp đỉnh  mà:Như vậy ta "gần như" đã phân loại được được các cạnh của DFS. Để phân biệt cung xuôi và cung chéo, ta cần sửa đổi DFS hơn nữa. Vấn đề này ta sẽ tìm hiểu trong bài sau. Giả mã như sau:  
Code C:Một đồ thị có hướng  được gọi là  (directed acyclic graph -- đồ thị có hướng và không có chu trình) nếu  . Ở đây ta nhấn mạnh cụm từ . Điều đó có nghĩa là đồ thị vô hướng tương ứng  vẫn có thể có chu trình.  Đồ thị trong ví dụ ở trên không phải là DAG do đồ thị đó có chu trình . Đồ thị trong hình  dưới đây là một DAG. Ta có bài toán sau: Gọi  là đồ thị thu được bằng cách đảo ngược các cung của . Ta có nhận xét sau: Đỉnh  của đồ thị  được gọi là một  (source vertex) nếu như không tồn tại  sao cho . Nói cách khác,  là phát nếu bậc tới (in-degree) của  bằng . Đỉnh  của đồ thị  được gọi là một  (sink vertex) nếu như không tồn tại  sao cho . Hay nói cách khác,  là đỉnh thu nếu bậc lui (out-degree) của  bằng . Ví dụ trong hình  dưới đây, các đỉnh  là các đỉnh phát, các đỉnh  là các đỉnh thu. Ta có bổ đề sau: 
 Nhận xét đỉnh phát của   chính là đỉnh thu của . Do đó, dựa vào Fact 1, ta chỉ cần chứng minh  luôn có một đỉnh phátChọn một đỉnh   và đánh dấu đỉnh . Gọi  là đỉnh sao cho . Nếu  không tồn tại thì  là đỉnh thu, bổ đề là đúng. Nếu  tồn tại, ta tiếp tục đánh dấu  và lặp lại quá trình đánh dấu như vậy cho đến khi ta gặp một đỉnh  là đỉnh thu hoặc tồn tại một đỉnh  sao cho  và  đã được đánh dấu. Trong trường hợp sau, ta sẽ tìm được một chu trình có hướng bao gồm các đỉnh đã đánh dấu, trái với giả thiết  là DAG.Gọi  là tập các đỉnh nguồn của . Thêm vào một đỉnh  và thêm  cung . Gọi  là đồ thị thu được. Dễ thấy: nếu  là DAG thì  cũng là DAG và ngược lại.
 Ngoài ra, nếu ta thực hiện DFS bắt đầu từ , ta sẽ chỉ thu được duy nhất một cây DFS gốc tại  (tại sao?). Ta có bổ đề sau: 
 Chiều thuận của bổ đề khá dễ để chứng minh. Nếu cây DFS gốc tại  có cung  là cung ngược,  và  đều có nhãn unvisiting. Do đó là cung ngược,  sẽ là tổ tiền của  trong cây DFS. Hay nói cách khác, có một đường đi  từ  đến . Đường đi đó kết hợp với cạnh  sẽ tạo thành một chu trình có hướng. Do đó  không phải là DAG.Ta chứng minh chiều ngược lại bằng phản chứng. Giả sử  không phải là DAG, gọi  là một chu trình có hướng của . Gọi  là đỉnh đầu tiên của  được thăm bởi DFS và  là đỉnh mà . Đỉnh  chỉ được đánh dấu là visited sau khi tất cả các đỉnh trong tầm với của  (reachable from ), trong đó có , đã được đánh dấu là visited. Do đó, khi ta thăm , đỉnh  đang được đánh dấu là visiting. Như vậy,  là cung ngược, trái với giả thiết là cây DFS không có cung ngược. Từ Lemma 3, ta có thể giải Problem 1 bằng cách thay đổi một chút thủ tục  như sau:  
Code C: Nếu biểu diễn đồ thị bằng danh sách kề, mỗi đỉnh  có hai danh sách: một danh sách các đỉnh  (gọi là các đỉnh tới) sao cho  và một danh sách khác lưu các đỉnh  (gọi là các đỉnh lui) sao cho  thì việc phát hiện các đỉnh phát (sink) có thể được thực hiện trong thời gian . Nếu ta chỉ lưu một danh sách là các đỉnh tới thì việc phát hiện nguồn có thể thực hiện trong thời gian  bằng cách duyệt qua các cung và đánh dấu các đỉnh cuối của mỗi cung. Các đỉnh không bị đánh dấu chính là các đỉnh nguồn. Việc thêm đỉnh  vào đồ thị cũng có thể được thực hiện trong thời gian . Thuật toán DFS có thời gian . Do đó thời gian của thuật toán  là .  : Đỉnh  thêm vào đồ thị để việc trình bày thuật toạn được đơn giản hơn. Khi thực thi thuật toán , ta không nhất thiết phải thêm vào đỉnh này. Ngoài ra, dựa vào chứng minh của Lemma 3, ta có thể dễ dàng mở rộng thuật toán  để in ra một chu trình có hướng trong trường hợp  không phải là DAG. Chi tiết coi như bài tập cho bạn đọc. của một đồ thị có hướng  là một cách sắp xếp các đỉnh trên một đường thẳng sao cho với mỗi cung , đỉnh  nằm bên trái đỉnh  trên đường thẳng đó. Ví dụ hình (6) dưới đây là một sắp xếp topo của đồ thị trong hình (5). Từ định nghĩa của săp xếp Topo ta có thể dễ dàng thấy rằng nếu  có một sắp xếp Topo thì  không thể có một chu trình có hướng. Hay nói cách khác,  là một DAG. Ngược lại, cho một DAG , luôn tồn tại một sắp xếp Topo cho . Ta sẽ chứng minh điều này bằng cách thiết kế một giải thuật để tìm sắp xếp Topo đó. Ta có: Ta có thể coi sắp xếp Topo giống như gán lại chỉ số trong tập  cho mỗi đỉnh sao cho với mỗi cung , đỉnh  được gán chỉ số nhỏ hơn . Để biểu diễn thứ tự của sắp xếp Topo, ta sẽ dùng một mảng  trong đó nếu  thì . Gọi  là tập các đỉnh nguồn của . Ta có:



 Ta có thể đổi chỗ các đỉnh trong tập  trong một sắp xếp Topo của  mà thứ tự các đỉnh sau khi đổi chỗ vẫn là thứ tự của một sắp xếp Topo (khác) của .Dựa vào nhận xét trên, ta có thể tìm một sắp xếp Topo của DAG  như sau:  Mỗi lần ta phát hiện ra một đỉnh nguồn mới, ta sẽ đưa đỉnh đó vào vị trí còn trống đầu tiên của mảng  và xóa đỉnh nguồn đó từ đồ thị. Ngoài ra, ta sẽ dùng một tập hợp  để lưu trữ các đỉnh nguồn của đồ thị hiện tại. Thuật toán  như sau:   Trong thực tế cài đặt, ta sẽ không thực sự "xóa" đỉnh ra khỏi đồ thị mà ta chỉ cần dùng mảng để đánh dấu là đỉnh đó đã bị "xóa". Ta sẽ chứng minh: 
 Ta sẽ chứng minh nếu   thì  sẽ được gán chỉ số nhỏ hơn . Giả sử ngược lại, tồn tại cung mà  được gán chỉ số lớn hơn . Từ đó suy ra khi ta gán chỉ số cho ,  đã được gán chỉ số rồi, và do đó, sẽ bị xóa khỏi đồ thị.  Do đó,  đã được đưa vào trong     khỏi . Nhưng điều đó có nghĩa là khi  vào , cung  vẫn thuộc , trái với điều kiện khi ta đưa  vào . Do đó, cung như vậy không tồn tại. Hay nói cách khác, đầu ra của thuật toán là một sắp xếp Topo.  Ta sẽ dùng danh sách kề, với mỗi đỉnh , danh sách kề của  chỉ lưu các đỉnh mà . Hay nói cách khác, danh sách kề của  chỉ lưu các out-neighbor của . Ta sẽ dùng một mảng  để đánh dấu đỉnh nào đã bị "xóa" ra khỏi đồ thị, i.e   nếu  bị xóa và  nếu ngược lại. Thao tác khó nhất là kiểm tra xem sau khi xóa  khỏi đồ thị,  có trở thành đỉnh nguồn hay không (dòng if có comment ở giả mã trên). Ta có thể thực thi bằng cách duyệt qua các hàng xóm tới  (in-neighbors) của  và kiểm tra xem    hay không. Nếu mọi hàng xóm tới của  đều đã bị xóa,  sẽ là đỉnh nguồn và ta đưa  vào . Tuy nhiên, để làm như vậy, ta phải lưu thêm một danh sách các hàng xóm tới cho mỗi đỉnh, và nếu không cẩn thận, mỗi thao tác duyệt sẽ mất thời gian là bậc tới của , do đó làm cho tổng thời gian thành . Để giải quyết tình trạng này, ta sẽ lưu thêm một mảng  trong đó  nếu bậc tới (in-degree) của  là  trong đồ thị hiện tại (không tính các đỉnh đã "xóa"). Do đó, mỗi lần "xóa"  ra khỏi đồ thị, ta chỉ việc cập nhật lại mảng  và đỉnh điều kiện ở dòng if sẽ trở thành  (xem giả mã dưới đây).  Do đó, thao tác kiểm tra này mất . Như vậy, tổng thời gian của thuật toán là . Giả mã:    
Code C: Theo , giải thuật sắp xếp Topo mà ta mô tả ở đây được phát triển bởi Kahn [1] năm 1966. Ngoài ra còn giải thuật khác sử dụng DFS khá giống với thủ tục . Giải thuật này được mô tả bởi Tarjan [2] vào năm 1974 và được sử dụng trong textbook CLRS[3]. Code đầy đủ: , , . [1] Kahn, Arthur B.  Communications of the ACM 5.11 (1962): 558-562.
[2] Tarjan, Robert Endre.  Computer Science Department, School of Humanities and Sciences, Stanford University, 1974.
[3] Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001) [1990].  (2nd ed.). Chapter 22.5. MIT Press and McGraw-Hill. , , , , Trackback link: Powered by  and 