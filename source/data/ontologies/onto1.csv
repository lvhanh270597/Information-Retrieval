Word,Class,isLessRelateOf,isRelateOf,isSynonymOf,isTheSameAs,Name,Info,Birthday,DateOfDeath,Education,Field,Nationality,PublicationDate
algorithm,Object,"hiệu_quả,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,google,liên_tục,heuristic,lập_trình,lập_trình_viên,công_cụ,lặp,halmiton,swap,đảo_ngược,backtracking,loop,euler,graph,đồ_thị_vô_hướng,theory,embed,cấu_trúc_dữ_liệu,classification,dữ_liệu,function,đồ_thị,nlp,ai,AI,microsoft,framework,matlab","tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","thuật_giải,giải_thuật,thuật_toán,algorithms",algorithms,algorithm,"Thuật toán (tiếng Anh: Algorithm) , còn gọi là giải thuật, là một tập hợp hữu hạn của các chỉ thị hay phương cách được định nghĩa rõ ràng cho việc hoàn tất một số sự việc từ một trạng thái ban đầu cho trước; khi các chỉ thị này được áp dụng triệt để thì sẽ dẫn đến kết quả sau cùng như đã dự đoán trước. Nói cách khác, thuật toán là một bộ các quy tắc hay quy trình cụ thể nhằm giải quyết một vấn đề trong một số bước hữu hạn, hoặc nhằm cung cấp một kết quả từ một tập hợp của các dữ kiện đưa vào.",,,,,,
hiệu_quả,Other,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,tối_ưu_hóa,algorithms",rời_rạc,,,hiệu quả,,,,,,,
khoa_học_máy_tính,Object,"algorithm,thuật_giải,giải_thuật,thuật_toán,hiệu_quả,richard_bellman,bellman,thiết_kế,tối_ưu_hóa,search,tìm_kiếm,natural_language_processing,google,nlp,theory,heuristic,AI,train,chiến_lược,dữ_liệu,kĩ_thuật,euler,graph,đồ_thị_vô_hướng,lập_trình_viên,function,đồ_thị,ai,công_cụ,microsoft,framework,matlab,tài_liệu,thuật_ngữ,chuỗi,algorithms","cấu_trúc_dữ_liệu,quy_hoạch_động,rời_rạc,truy_hồi,ai,lý_thuyết_trò_chơi,parallel,thông_minh,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,nlp,AI,natural_language_processing",computer_science,,khoa học máy tính,Khoa học máy tính (tiếng Anh: computer science) là ngành nghiên cứu các cơ sở lý thuyết về thông tin và tính toán cùng sự thực hiện và ứng dụng của chúng trong các hệ thống máy tính.,,,,,,
search,Other,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,graph,đồ_thị,tối_ưu_hóa,luật,sự_kiện,natural_language_processing,google,sort,java,windows,string,loop,classification,euler,đồ_thị_vô_hướng,theory,nlp,ai,AI,công_cụ,microsoft,framework,matlab,acm,cú_pháp,lập_trình_viên,algorithms","truy_hồi,lặp,công_cụ,query,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,google,microsoft,framework,matlab",tìm_kiếm,,search,,,,,,,
tìm_kiếm,Other,"algorithm,thuật_giải,giải_thuật,thuật_toán,khoa_học_máy_tính,natural_language_processing,google,tối_ưu_hóa,AI,lý_thuyết_trò_chơi,function,kĩ_thuật,nlp,ai,công_cụ,microsoft,framework,matlab,algorithms","tìm_kiếm_nhị_phân,truy_hồi,heuristic",search,,tìm kiếm,,,,,,,
natural_language_processing,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,quy_hoạch_động,bộ_nhớ,cấu_trúc_dữ_liệu,hằng_số,var,chuỗi,query,string,function,rời_rạc,dữ_liệu,tối_ưu_hóa,google,công_cụ,microsoft,optimize,luật,rời_rạc_hóa,framework,matlab,oop,lý_thuyết_trò_chơi,parallel,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,kĩ_thuật,dataset,algorithms","khoa_học_máy_tính,chuỗi,truy_hồi,heuristic,ai,thông_minh,thuật_ngữ,tài_liệu,nlp,AI","nlp,ai,artificial_intelligence,AI,trí_tuệ_nhân_tạo","nlp,ai,AI",nlp,Xử lý ngôn ngữ tự nhiên (natural language processing - NLP) là một nhánh của trí tuệ nhân tạo tập trung vào các ứng dụng trên ngôn ngữ của con người. Trong trí tuệ nhân tạo thì xử lý ngôn ngữ tự nhiên là một trong những phần khó nhất vì nó liên quan đến việc phải hiểu ý nghĩa ngôn ngữ-công cụ hoàn hảo nhất của tư duy và giao tiếp.,,,,,,
google,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,lập_trình,bảo_mật,query,nlp,truy_hồi,công_cụ,ai,tài_liệu,AI,microsoft,java,windows,lặp,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,donald_knuth,tuple,lỗi_cú_pháp,lập_trình_hướng_đối_tượng,protocol,compiler,framework,matlab,algorithms","search,truy_hồi,công_cụ,java,windows,lập_trình_viên,cú_pháp,microsoft,framework,matlab",,"công_cụ,microsoft,framework,matlab",google,"MATLAB là phần mềm cung cấp môi trường tính toán số và lập trình, do công ty MathWorksthiết kế. MATLAB cho phép tính toán số với ma trận, vẽ đồ thị hàm số hay biểu đồ thông tin, thực hiện thuật toán, tạo các giao diện người dùng và liên kết với những chương trình máy tính viết trên nhiều ngôn ngữ lập trình khác",,,,,,
liên_tục,Other,"algorithm,thuật_giải,giải_thuật,rời_rạc,heuristic,algorithms",tối_ưu_hóa,,,liên tục,"Có nhiều định nghĩa về hàm liên tục. Định nghĩa theo giới hạn của hàm là: Cho dãy {\displaystyle (x_{n})_{n\in \mathbb {N} }} {\displaystyle (x_{n})_{n\in \mathbb {N} }} bất kì trên miền xác định hội tụ về {\displaystyle c} c, thì tương ứng dãy {\displaystyle (f(x_{n}))_{n\in \mathbb {N} }} {\displaystyle (f(x_{n}))_{n\in \mathbb {N} }} hội tụ về {\displaystyle f(c)} {\displaystyle f(c)}",,,,,,
heuristic,Object,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,liên_tục,tìm_kiếm_nhị_phân,chuỗi,đầu_vào,rời_rạc,truy_hồi,thông_minh,thuật_ngữ,tài_liệu,theory,phân_hoạch,linear,mã_băm,swap,tham_số,ánh_xạ,truy_nhập,xóa_đỉnh,classification,tuple,algorithms","tìm_kiếm,natural_language_processing,nlp,function,tối_ưu_hóa,AI,lý_thuyết_trò_chơi,kĩ_thuật,ai",,,heuristic,"Heuristic là các kỹ thuật dựa trên kinh nghiệm để giải quyết vấn đề, học hỏi hay khám phá nhằm đưa ra một giải pháp mà không được đảm bảo là tối ưu. Với việc nghiên cứu khảo sát không có tính thực tế, các phương pháp heuristic được dùng nhằm tăng nhanh quá trình tìm kiếm với các giải pháp hợp lý thông qua các suy nghĩ rút gọn để giảm bớt việc nhận thức vấn đề khi đưa ra quyết định. Ví dụ của phương pháp này bao gồm sử dụng một luật ngón tay cái, giả thuyết, phán đoán trực giác, khuôn mẫu hay nhận thức thông thường.",,,,,,
lập_trình,Object,"algorithm,thuật_giải,giải_thuật,google,lập_trình_viên,công_cụ,microsoft,framework,matlab,algorithms",java,,,lập trình,"Lập trình máy tính hay lập chương trình máy tính thường gọi tắt là lập trình (tiếng Anh: Computer programming, thường gọi tắt là programming) là việc lập ra chương trình làm việc cho máy có bộ xử lý, nói riêng là máy tính, để thực thi nhiệm vụ xử lý thông tin nào đó.",,,,,,
lập_trình_viên,,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,lập_trình,ctdl,dữ_liệu,truy_hồi,windows,lỗi_cú_pháp,compiler,lập_trình_hướng_đối_tượng,protocol,kĩ_thuật,algorithms","google,công_cụ,microsoft,java,cú_pháp,matlab,donald_knuth,tuple,framework",,,lập trình viên,,,,,,,
công_cụ,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,lập_trình,bảo_mật,query,nlp,truy_hồi,ai,tài_liệu,AI,microsoft,java,windows,lặp,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,donald_knuth,tuple,lỗi_cú_pháp,lập_trình_hướng_đối_tượng,protocol,compiler,framework,matlab,algorithms,google","search,truy_hồi,java,windows,lập_trình_viên,cú_pháp,microsoft,framework,matlab,google",,"microsoft,framework,matlab,google",google,"MATLAB là phần mềm cung cấp môi trường tính toán số và lập trình, do công ty MathWorksthiết kế. MATLAB cho phép tính toán số với ma trận, vẽ đồ thị hàm số hay biểu đồ thông tin, thực hiện thuật toán, tạo các giao diện người dùng và liên kết với những chương trình máy tính viết trên nhiều ngôn ngữ lập trình khác",,,,,,
lặp,Other,"algorithm,thuật_giải,giải_thuật,google,công_cụ,query,truy_hồi,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,microsoft,framework,matlab,swap,đảo_ngược,algorithms","search,sort",loop,,lặp,Vòng lặp là một loại câu lệnh điều khiển dòng xử lý của máy tính. Vòng lặp for là để thực hiện lặp đi lặp lại một tập hợp các câu lệnh nào đó với điều kiện cụ thể.,,,,,,
halmiton,Entity,"algorithm,thuật_giải,giải_thuật,google,công_cụ,lặp,cây,tree,query,truy_hồi,microsoft,framework,matlab,bfs,backtracking,dfs,insert,dijsktra,neighbor,lý_thuyết_đồ_thị,vertex,liên_thông,trạng_thái,swap,đảo_ngược,algorithms","search,graph,sort",,,halmiton,"Đường đi Hamilton có nguồn gốc từ bài toán: ""Xuất phát từ một đỉnh của khối thập nhị diện đều hãy đi dọc theo các cạnh của khối đó sao cho đi qua tất cả các đỉnh khác, mỗi đỉnh đúng một lần sau đó quay về đỉnh xuất phát."" là gọi theo tên của William Rowan Hamilton phát biểu vào năm 1859.",,,,,,
swap,Entity,"algorithm,thuật_giải,giải_thuật,heuristic,lặp,halmiton,đầu_vào,mã_băm,phân_hoạch,dijsktra,linear,đảo_ngược,tham_số,ánh_xạ,truy_nhập,algorithms","function,sort",hoán_vị,,swap,,,,,,,
đảo_ngược,Entity,"algorithm,thuật_giải,giải_thuật,lặp,halmiton,swap,dijsktra,algorithms",sort,,,đảo ngược,,,,,,,
backtracking,Entity,"algorithm,thuật_giải,giải_thuật,google,công_cụ,lặp,halmiton,cây,tree,query,truy_hồi,loop,microsoft,framework,matlab,dijsktra,neighbor,lý_thuyết_đồ_thị,insert,vertex,liên_thông,trạng_thái,algorithms","search,graph,bfs,dfs",vét_cạn,,backtracking,,,,,,,
loop,Other,"algorithm,thuật_giải,giải_thuật,search,backtracking,algorithms","bfs,dfs",lặp,,loop,,,,,,,
euler,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,cây,toán_học,graph,tree,ctdl,node,xóa_đỉnh,theory,algorithms","đồ_thị,lý_thuyết_đồ_thị,euclidean,đồ_thị_vô_hướng,không_gian_vector",,,euler,"Trong lý thuyết đồ thị, một đường đi trong đồ thị G=(X,E) được gọi là đường đi Euler nếu nó đi qua tất cả các cạnh của đồ thị, mỗi cạnh đúng một lần. Đường đi Euler có đỉnh cuối cùng trùng với đỉnh xuất phát gọi là chu trình Euler. Khái niệm chu trình Euler xuất phát từ bài toán bảy cây cầu do Euler giải quyết vào khoảng năm 1737. Đường đi Euler có thể tìm thấy trong các bài toán vui vẽ một nét (vẽ một hình nào đó mà không nhấc bút khỏi mặt giấy, không tô lại cạnh nào hai lần).",,,,,,
graph,Object,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,euler,bộ_nhớ,nút_gốc,root,ctdl,node,leaf,tiền_tố,hậu_tố,đồ_thị_vô_hướng,theory,sort,bfs,dfs,đồ_thị,algorithms","halmiton,backtracking,cây,tree,insert,lý_thuyết_đồ_thị,vertex,liên_thông,trạng_thái","đồ_thị_vô_hướng,đồ_thị",,graph,,,,,,,
đồ_thị_vô_hướng,Object,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,graph,nút_gốc,root,dãy_fibonacci,xác_suất,đường_thẳng,dữ_liệu,dslk,dslk_đơn,mã_băm,dataset,cấu_trúc,ngăn_xếp,bảng_băm,matrix,bfs,dfs,insert,kĩ_thuật,leaf,trạng_thái,tiền_tố,hậu_tố,tuple,theory,algorithms","euler,cây,toán_học,tree,ctdl,node,xóa_đỉnh,lý_thuyết_đồ_thị,euclidean,không_gian_vector","graph,đồ_thị",đồ_thị,đồ thị,"Cho đồ thị G=(X, E). Nếu chúng ta không phân biệt thứ tự của cặp đỉnh liên kết với mỗi cạnh thì sẽ có được đồ thị vô hướng. Đồ thị vô hướng G=(X, E) được định nghĩa bởi: tập hợp X ≠ ∅ được gọi là tập các đỉnh của đồ thị; tập hợp E là tập các cạnh của đồ thị. mỗi cạnh e∈E được liên kết với một cặp đỉnh {i, j} ⊆ X không phân biệt thứ tự.",,,,,,
theory,Object,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,heuristic,euler,graph,đồ_thị_vô_hướng,đồ_thị,algorithms","lý_thuyết_trò_chơi,lý_thuyết_đồ_thị",,,theory,,,,,,,
embed,Other,"algorithm,thuật_giải,giải_thuật,thuật_toán,bộ_nhớ,cấu_trúc_dữ_liệu,trình_biên_dịch,lỗi_cú_pháp,compiler,algorithms","kernel,debug,thiết_kế",nhúng,,embed,"Hệ thống nhúng (tiếng Anh: embedded system) là một thuật ngữ để chỉ một hệ thống có khả năng tự trị được nhúng vào trong một môi trường hay một hệ thống mẹ. Đó là các hệ thống tích hợp cả phần cứng và phần mềm phục vụ các bài toán chuyên dụng trong nhiều lĩnh vực công nghiệp, tự động hoá điều khiển, quan trắc và truyền tin. Đặc điểm của các hệ thống nhúng là hoạt động ổn định và có tính năng tự động hoá cao.",,,,,,
cấu_trúc_dữ_liệu,Object,"algorithm,thuật_giải,giải_thuật,thuật_toán,natural_language_processing,embed,quy_hoạch_động,rời_rạc,truy_hồi,ai,lý_thuyết_trò_chơi,parallel,thông_minh,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,nlp,AI,algorithms","khoa_học_máy_tính,thiết_kế",ctdl,,cấu trúc dữ liệu,"Trong khoa học máy tính, cấu trúc dữ liệu là một cách lưu dữ liệu trong máy tính sao cho nó có thể được sử dụng một cách hiệu quả. Trong thiết kế nhiều loại chương trình, việc chọn cấu trúc dữ liệu là vấn đề quan trọng.",,,,,,
classification,Object,"algorithm,thuật_giải,giải_thuật,search,natural_language_processing,heuristic,cấu_trúc_dữ_liệu,quy_hoạch_động,ctdl,nlp,function,rời_rạc,truy_hồi,ai,AI,tài_liệu,protocol,dataset,overflow,tuple,dung_lượng,lý_thuyết_trò_chơi,parallel,thông_minh,lý_thuyết_đồ_thị,donald_knuth,xóa_đỉnh,algorithms","khoa_học_máy_tính,dữ_liệu,train,neighbor,chiến_lược,kĩ_thuật,linear",,,classification,"Ý tưởng của bài toán phân loại bắt đầu như sau: Chúng ta có một danh sách các quan sát (observation). Một quan sát là một khái niệm chung chung. Với Machine Learning, một quan sát thường là sự mô tả một đối tượng trong một trạng thái nào đó. Để hiểu rõ hơn, hãy xét một ví dụ rất phổ biến trong Machine Learning: hoa diên vĩ (Iris flowers). Giả sử một quan sát là sự mô tả một bông hoa. Với mỗi bông hoa, chúng ta có bốn thông số: độ dày và chiều dài của đài hoa (sepal) và cánh hoa (petal). Trên thực tế, ví dụ về hoa diên vĩ nổi tiếng với cái tên the Iris dataset và đây là bộ dữ liệu được sử dụng rất rộng rãi trong giới nghiên cứu Machine Learning để tìm hiểu về các thuật toán phân loại.",,,,,,
dữ_liệu,Other,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,natural_language_processing,lập_trình_viên,đồ_thị_vô_hướng,bộ_nhớ,đồ_thị,tree,cấp_phát,bảo_mật,mã_hóa,string,nlp,function,rời_rạc,cú_pháp,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,bảng_băm,matrix,mã_băm,leaf,neighbor,chiến_lược,kĩ_thuật,ai,AI,bit,algorithms","classification,ctdl,train,protocol,dataset,overflow,tài_liệu,linear,tuple,dung_lượng",,,dữ liệu,,,,,,,
function,Other,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,tìm_kiếm,natural_language_processing,classification,dữ_liệu,ctdl,bảo_mật,mã_hóa,nlp,tối_ưu_hóa,AI,lý_thuyết_trò_chơi,kĩ_thuật,ai,sort,biên_toàn_cục,algorithms","heuristic,swap,đầu_vào,phân_hoạch,linear,mã_băm,tham_số,ánh_xạ,truy_nhập",,,function,,,,,,,
đồ_thị,Object,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,graph,nút_gốc,root,dãy_fibonacci,xác_suất,đường_thẳng,dữ_liệu,dslk,dslk_đơn,mã_băm,dataset,cấu_trúc,ngăn_xếp,bảng_băm,matrix,bfs,dfs,insert,kĩ_thuật,leaf,trạng_thái,tiền_tố,hậu_tố,tuple,theory,algorithms","euler,cây,toán_học,tree,ctdl,node,xóa_đỉnh,lý_thuyết_đồ_thị,euclidean,không_gian_vector","graph,đồ_thị_vô_hướng",đồ_thị_vô_hướng,đồ thị,"Cho đồ thị G=(X, E). Nếu chúng ta không phân biệt thứ tự của cặp đỉnh liên kết với mỗi cạnh thì sẽ có được đồ thị vô hướng. Đồ thị vô hướng G=(X, E) được định nghĩa bởi: tập hợp X ≠ ∅ được gọi là tập các đỉnh của đồ thị; tập hợp E là tập các cạnh của đồ thị. mỗi cạnh e∈E được liên kết với một cặp đỉnh {i, j} ⊆ X không phân biệt thứ tự.",,,,,,
nlp,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,quy_hoạch_động,bộ_nhớ,cấu_trúc_dữ_liệu,hằng_số,var,chuỗi,query,string,function,rời_rạc,dữ_liệu,tối_ưu_hóa,google,công_cụ,microsoft,optimize,luật,rời_rạc_hóa,framework,matlab,oop,lý_thuyết_trò_chơi,parallel,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,kĩ_thuật,dataset,algorithms","khoa_học_máy_tính,chuỗi,truy_hồi,heuristic,ai,thông_minh,thuật_ngữ,tài_liệu,AI,natural_language_processing","natural_language_processing,ai,artificial_intelligence,AI,trí_tuệ_nhân_tạo","ai,AI,natural_language_processing",nlp,Xử lý ngôn ngữ tự nhiên (natural language processing - NLP) là một nhánh của trí tuệ nhân tạo tập trung vào các ứng dụng trên ngôn ngữ của con người. Trong trí tuệ nhân tạo thì xử lý ngôn ngữ tự nhiên là một trong những phần khó nhất vì nó liên quan đến việc phải hiểu ý nghĩa ngôn ngữ-công cụ hoàn hảo nhất của tư duy và giao tiếp.,,,,,,
ai,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,quy_hoạch_động,bộ_nhớ,cấu_trúc_dữ_liệu,hằng_số,var,chuỗi,query,string,function,rời_rạc,dữ_liệu,tối_ưu_hóa,google,công_cụ,microsoft,optimize,luật,rời_rạc_hóa,framework,matlab,oop,lý_thuyết_trò_chơi,parallel,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,kĩ_thuật,dataset,algorithms","khoa_học_máy_tính,chuỗi,truy_hồi,heuristic,thông_minh,thuật_ngữ,tài_liệu,nlp,AI,natural_language_processing","natural_language_processing,nlp,artificial_intelligence,AI,trí_tuệ_nhân_tạo","nlp,AI,natural_language_processing",nlp,Xử lý ngôn ngữ tự nhiên (natural language processing - NLP) là một nhánh của trí tuệ nhân tạo tập trung vào các ứng dụng trên ngôn ngữ của con người. Trong trí tuệ nhân tạo thì xử lý ngôn ngữ tự nhiên là một trong những phần khó nhất vì nó liên quan đến việc phải hiểu ý nghĩa ngôn ngữ-công cụ hoàn hảo nhất của tư duy và giao tiếp.,,,,,,
AI,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,quy_hoạch_động,bộ_nhớ,cấu_trúc_dữ_liệu,hằng_số,var,chuỗi,query,string,function,rời_rạc,dữ_liệu,tối_ưu_hóa,google,công_cụ,microsoft,optimize,luật,rời_rạc_hóa,framework,matlab,oop,lý_thuyết_trò_chơi,parallel,neighbor,classification,lý_thuyết_đồ_thị,donald_knuth,linear,kĩ_thuật,dataset,algorithms","khoa_học_máy_tính,chuỗi,truy_hồi,heuristic,ai,thông_minh,thuật_ngữ,tài_liệu,nlp,natural_language_processing","natural_language_processing,nlp,ai,artificial_intelligence,trí_tuệ_nhân_tạo","nlp,ai,natural_language_processing",nlp,Xử lý ngôn ngữ tự nhiên (natural language processing - NLP) là một nhánh của trí tuệ nhân tạo tập trung vào các ứng dụng trên ngôn ngữ của con người. Trong trí tuệ nhân tạo thì xử lý ngôn ngữ tự nhiên là một trong những phần khó nhất vì nó liên quan đến việc phải hiểu ý nghĩa ngôn ngữ-công cụ hoàn hảo nhất của tư duy và giao tiếp.,,,,,,
microsoft,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,lập_trình,bảo_mật,query,nlp,truy_hồi,công_cụ,ai,tài_liệu,AI,java,windows,lặp,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,donald_knuth,tuple,lỗi_cú_pháp,lập_trình_hướng_đối_tượng,protocol,compiler,framework,matlab,algorithms,google","search,truy_hồi,công_cụ,java,windows,lập_trình_viên,cú_pháp,framework,matlab,google",,"công_cụ,framework,matlab,google",google,"MATLAB là phần mềm cung cấp môi trường tính toán số và lập trình, do công ty MathWorksthiết kế. MATLAB cho phép tính toán số với ma trận, vẽ đồ thị hàm số hay biểu đồ thông tin, thực hiện thuật toán, tạo các giao diện người dùng và liên kết với những chương trình máy tính viết trên nhiều ngôn ngữ lập trình khác",,,,,,
framework,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,lập_trình,bảo_mật,query,nlp,truy_hồi,công_cụ,ai,tài_liệu,AI,microsoft,java,windows,lặp,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,donald_knuth,tuple,lỗi_cú_pháp,lập_trình_hướng_đối_tượng,protocol,compiler,matlab,algorithms,google","search,truy_hồi,công_cụ,java,windows,lập_trình_viên,cú_pháp,microsoft,matlab,google",,"công_cụ,microsoft,matlab,google",google,"MATLAB là phần mềm cung cấp môi trường tính toán số và lập trình, do công ty MathWorksthiết kế. MATLAB cho phép tính toán số với ma trận, vẽ đồ thị hàm số hay biểu đồ thông tin, thực hiện thuật toán, tạo các giao diện người dùng và liên kết với những chương trình máy tính viết trên nhiều ngôn ngữ lập trình khác",,,,,,
matlab,Entity,"algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,lập_trình,bảo_mật,query,nlp,truy_hồi,công_cụ,ai,tài_liệu,AI,microsoft,java,windows,lặp,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,halmiton,backtracking,donald_knuth,tuple,lỗi_cú_pháp,lập_trình_hướng_đối_tượng,protocol,compiler,framework,algorithms,google","search,truy_hồi,công_cụ,java,windows,lập_trình_viên,cú_pháp,microsoft,framework,google",,"công_cụ,microsoft,framework,google",google,"MATLAB là phần mềm cung cấp môi trường tính toán số và lập trình, do công ty MathWorksthiết kế. MATLAB cho phép tính toán số với ma trận, vẽ đồ thị hàm số hay biểu đồ thông tin, thực hiện thuật toán, tạo các giao diện người dùng và liên kết với những chương trình máy tính viết trên nhiều ngôn ngữ lập trình khác",,,,,,
tham_lam,Entity,"rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","algorithm,thuật_giải,giải_thuật,algorithms",greedy,,tham lam,Giải thuật tham lam (tiếng Anh: Greedy algorithm) là một thuật toán giải quyết một bài toán theo kiểu metaheuristic để tìm kiếm lựa chọn tối ưu địa phương ở mỗi bước đi với hy vọng tìm được tối ưu toàn cục.,,,,,,
rời_rạc,Entity,"natural_language_processing,liên_tục,heuristic,cấu_trúc_dữ_liệu,classification,dữ_liệu,nlp,ai,AI,tham_lam,quy_hoạch_động,mã_hóa,truy_hồi,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear,lý_thuyết_trò_chơi,thông_minh,neighbor,donald_knuth","algorithm,thuật_giải,giải_thuật,hiệu_quả,khoa_học_máy_tính,tối_ưu_hóa,algorithms",,,rời rạc,"Ứng dụng phổ biến của rời rạc hóa là đưa các vùng dữ liệu lớn về vùng dữ liệu nhỏ để dễ xử lý, sao cho vẫn thỏa mãn yêu cầu của bài toán đặt ra.",,,,,,
truy_hồi,Other,"google,heuristic,lập_trình_viên,công_cụ,lặp,halmiton,backtracking,cấu_trúc_dữ_liệu,classification,microsoft,framework,matlab,tham_lam,rời_rạc,quy_hoạch_động,tìm_kiếm_nhị_phân,chuỗi,query,tối_ưu_hóa,bfs,dfs,dijsktra,neighbor,lý_thuyết_đồ_thị,java,offline,sort,parallel,độ_phức_tạp,thiết_kế,linear,lý_thuyết_trò_chơi,thông_minh,donald_knuth,thuật_ngữ,tài_liệu,windows,cú_pháp","algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,google,công_cụ,nlp,ai,AI,microsoft,framework,matlab,algorithms",,,truy hồi,"Truy hồi thông tin (hay còn gọi là truy vấn thông tin) là hoạt động thu thập các nguồn thông tin liên quan đến một thông tin cần tìm kiếm, có thể dựa trên siêu dữ liệu (metadata) và trên việc đánh chỉ mục toàn văn (hoặc dựa trên nội dung khác). Những hệ thống truy hồi thông tin tự động được sử dụng để giảm thiểu ""quá tải thông tin"". Nhiều các trường đại học và thư viện công cộng sử dụng hệ thống truy hồi thông tin để cung cấp truy cập đến sách báo và các tài liệu khác. Các máy tìm kiếm trên web được coi là những ứng dụng truy hồi thông tin dễ nhận thấy nhất.",,,,,,
tối_ưu_hóa,Object,"hiệu_quả,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,function,nlp,ai,AI,tham_lam,truy_hồi,sort,java,offline,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear,lý_thuyết_trò_chơi,kĩ_thuật","algorithm,thuật_giải,giải_thuật,liên_tục,heuristic,rời_rạc,algorithms",optimize,,tối ưu hóa,"Trong khoa học máy tính và toán học, bài toán tối ưu hóa là bài toán tìm kiếm lời giải tốt nhất trong tất cả các lời giải khả thi. Bài toán tối ưu hóa có thể được chia thành hai loại tùy thuộc vào việc các biến là liên tục hay rời rạc.",,,,,,
java,Entity,"search,google,công_cụ,microsoft,framework,matlab,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,sort,overflow,cú_pháp,offline,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear,donald_knuth,tuple,windows","algorithm,thuật_giải,giải_thuật,google,lập_trình,lập_trình_viên,công_cụ,microsoft,framework,matlab,algorithms",,,java,"Java (phiên âm Tiếng Việt: ""Gia-va"") là một ngôn ngữ lập trình hướng đối tượng (OOP) và dựa trên các lớp (class)[9]. Khác với phần lớn ngôn ngữ lập trình thông thường, thay vì biên dịch mã nguồn thành mã máy hoặc thông dịch mã nguồn khi chạy, Java được thiết kế để biên dịch mã nguồn thành bytecode, bytecode sau đó sẽ được môi trường thực thi (runtime environment) chạy. Trước đây, Java chạy chậm hơn những ngôn ngữ dịch thẳng ra mã máy như C và C++, nhưng sau này nhờ công nghệ ""biên dịch tại chỗ"" - Just in time compilation, khoảng cách này đã được thu hẹp, và trong một số trường hợp đặc biệt Java có thể chạy nhanh hơn. Java chạy nhanh hơn những ngôn ngữ thông dịch như Python, Perl, PHP gấp nhiều lần. Java chạy tương đương so với C#, một ngôn ngữ khá tương đồng về mặt cú pháp và quá trình dịch/chạy[10][11] Cú pháp Java được vay mượn nhiều từ C & C++ nhưng có cú pháp hướng đối tượng đơn giản hơn và ít tính năng xử lý cấp thấp hơn. Do đó việc viết một chương trình bằng Java dễ hơn, đơn giản hơn, đỡ tốn công sửa lỗi hơn. Trong Java, hiện tượng rò rỉ bộ nhớ hầu như không xảy ra do bộ nhớ được quản lý bởi Java Virtual Machine (JVM) bằng cách tự động ""dọn dẹp rác"". Người lập trình không phải quan tâm đến việc cấp phát và xóa bộ nhớ như C, C++. Tuy nhiên khi sử dụng những tài nguyên mạng, file IO, database (nằm ngoài kiểm soát của JVM) mà người lập trình không đóng (close) các streams thì rò rỉ dữ liệu vẫn có thể xảy ra.",1991,,,,,
offline,Entity,"tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,sort,online,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","algorithm,thuật_giải,giải_thuật,algorithms",,,offline,"Offline có nghĩa là ẩn, ngoại tuyến. Nghĩa là tình trạng chưa hoặc không kết nối với mạng Internet (chế độ tắt mạng), trái nghĩa với offline chính là online (trực tuyến).",,,,,,
sort,Entity,"search,graph,function,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sự_kiện,bfs,dfs,parallel,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear,acm","algorithm,thuật_giải,giải_thuật,lặp,halmiton,swap,đảo_ngược,dijsktra,algorithms",sắp_xếp,,sort,,,,,,,
bfs,Entity,"google,công_cụ,lặp,halmiton,graph,đồ_thị_vô_hướng,đồ_thị,microsoft,framework,matlab,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,tree,query,thiết_kế,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,linear,neighbor","algorithm,thuật_giải,giải_thuật,search,backtracking,loop,algorithms",,,bfs,duyệt theo chiều rộng,,,,,,
dfs,Entity,"google,công_cụ,lặp,halmiton,graph,đồ_thị_vô_hướng,đồ_thị,microsoft,framework,matlab,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,tree,query,thiết_kế,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,linear,neighbor","algorithm,thuật_giải,giải_thuật,search,backtracking,loop,algorithms",,,dfs,duyệt theo chiều sâu,,,,,,
parallel,Other,"natural_language_processing,cấu_trúc_dữ_liệu,classification,nlp,ai,AI,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,quy_hoạch_động,lý_thuyết_trò_chơi,thiết_kế,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,linear,thông_minh,neighbor,donald_knuth","algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,algorithms",song_song,,parallel,,,,,,,
dijsktra,Entity,"google,công_cụ,lặp,halmiton,swap,đảo_ngược,backtracking,microsoft,framework,matlab,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,bfs,dfs,parallel,query,thiết_kế,độ_phức_tạp,lý_thuyết_đồ_thị,linear,neighbor","algorithm,thuật_giải,giải_thuật,search,sort,algorithms",,,Edsger Dijkstra,"Thuật toán Dijkstra, mang tên của nhà khoa học máy tính người Hà Lan Edsger Dijkstra vào năm 1956 và ấn bản năm 1959[1], là một thuật toán giải quyết bài toán đường đi ngắn nhất nguồn đơn trong một đồ thị có hướng không có cạnh mang trọng số âm. Thuật toán thường được sử dụng trong định tuyến với một chương trình con trong các thuật toán đồ thị hay trong công nghệ Hệ thống định vị toàn cầu (GPS).",,,,,,
độ_phức_tạp,Object,"tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,heapsort,quicksort,đệ_quy,thiết_kế,lý_thuyết_đồ_thị,linear","algorithm,thuật_giải,giải_thuật,thuật_toán,algorithms",complexity,,độ phức tạp,,,,,,,
lý_thuyết_đồ_thị,Object,"natural_language_processing,google,công_cụ,lặp,halmiton,backtracking,cấu_trúc_dữ_liệu,classification,nlp,ai,AI,microsoft,framework,matlab,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,quy_hoạch_động,cây,toán_học,tree,ctdl,query,node,lý_thuyết_trò_chơi,thiết_kế,insert,thông_minh,neighbor,xóa_đỉnh,euclidean,không_gian_vector,linear,donald_knuth,vertex,liên_thông,trạng_thái","algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,search,euler,graph,đồ_thị_vô_hướng,theory,đồ_thị,algorithms",theorem_graphic,,lý thuyết đồ thị,"Trong toán học và tin học, lý thuyết đồ thị nghiên cứu các tính chất của đồ thị. Một cách không chính thức, đồ thị là một tập các đối tượng được gọi là các đỉnh (hoặc nút) nối với nhau bởi các cạnh (hoặc cung). Cạnh có thể có hướng hoặc vô hướng. Đồ thị thường được vẽ dưới dạng một tập các điểm (các đỉnh nối với nhau bằng các đoạn thẳng (các cạnh). Đồ thị biểu diễn được rất nhiều cấu trúc, nhiều bài toán thực tế có thể được biểu diễn bằng đồ thị. Ví dụ, cấu trúc liên kết của một website có thể được biểu diễn bằng một đồ thị có hướng như sau: các đỉnh là các trang web hiện có tại website, tồn tại một cạnh có hướng nối từ trang A tới trang B khi và chỉ khi A có chứa 1 liên kết tới B. Do vậy, sự phát triển của các thuật toán xử lý đồ thị là một trong các mối quan tâm chính của khoa học máy tính. Cấu trúc đồ thị có thể được mở rộng bằng cách gán trọng số cho mỗi cạnh. Có thể sử dụng đồ thị có trọng số để biểu diễn nhiều khái niệm khác nhau. Ví dụ, nếu đồ thị biểu diễn một mạng đường giao thông, các trọng số có thể là độ dài của mỗi con đường. Một cách khác để mở rộng đồ thị cơ bản là quy định hướng cho các cạnh của đồ thị (như đối với các trang web, A liên kết tới B, nhưng B không nhất thiết cũng liên kết tới A). Loại đồ thị này được gọi là đồ thị có hướng. Một đồ thị có hướng với các cạnh có trọng số được gọi là một lưới. Các lưới có nhiều ứng dụng trong khía cạnh thực tiễn của lý thuyết đồ thị, chẳng hạn, phân tích lưới có thể dùng để mô hình hoá và phân tích mạng lưới giao thông hoặc nhằm ""phát hiện"" hình dáng của Internet - (Xem thêm các ứng dụng đưới đây. Mặc dù vậy, cũng nên lưu ý rằng trong phân tích lưới, thì định nghĩa của khái niệm ""lưới"" có thể khác nhau và thường được chỉ ra bằng một đồ thị đơn giản.)",,,,,,
thiết_kế,Other,"khoa_học_máy_tính,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,heapsort,quicksort,đệ_quy,kernel,debug,linear","algorithm,thuật_giải,giải_thuật,thuật_toán,embed,cấu_trúc_dữ_liệu,algorithms",,,thiết kế,,,,,,,
linear,Entity,"natural_language_processing,heuristic,swap,cấu_trúc_dữ_liệu,nlp,ai,AI,tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,quy_hoạch_động,ctdl,đầu_vào,tài_liệu,train,protocol,mã_băm,dataset,lý_thuyết_trò_chơi,phân_hoạch,overflow,thông_minh,neighbor,kĩ_thuật,chiến_lược,donald_knuth,tuple,dung_lượng,tham_số,ánh_xạ,truy_nhập","algorithm,thuật_giải,giải_thuật,khoa_học_máy_tính,classification,dữ_liệu,function,algorithms",,,linear, Thuật toán Linear Regression mô tả dữ liệu và thể hiện mối quan hệ giữa một biến phụ thuộc với một hoặc nhiều biến độc lập. Tức là nếu biến độc lập thay đổi thì ảnh hưởng đến biến phụ thuộc như thế nào.,,,,,,
thuật_giải,Object,"hiệu_quả,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,google,liên_tục,heuristic,lập_trình,lập_trình_viên,công_cụ,lặp,halmiton,swap,đảo_ngược,backtracking,loop,euler,graph,đồ_thị_vô_hướng,theory,embed,cấu_trúc_dữ_liệu,classification,dữ_liệu,function,đồ_thị,nlp,ai,AI,microsoft,framework,matlab","tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","algorithm,giải_thuật,thuật_toán,algorithms",giải_thuật,thuật giải,"Thuật toán (tiếng Anh: Algorithm) , còn gọi là giải thuật, là một tập hợp hữu hạn của các chỉ thị hay phương cách được định nghĩa rõ ràng cho việc hoàn tất một số sự việc từ một trạng thái ban đầu cho trước; khi các chỉ thị này được áp dụng triệt để thì sẽ dẫn đến kết quả sau cùng như đã dự đoán trước. Nói cách khác, thuật toán là một bộ các quy tắc hay quy trình cụ thể nhằm giải quyết một vấn đề trong một số bước hữu hạn, hoặc nhằm cung cấp một kết quả từ một tập hợp của các dữ kiện đưa vào.",,,,,,
giải_thuật,Object,"hiệu_quả,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,google,liên_tục,heuristic,lập_trình,lập_trình_viên,công_cụ,lặp,halmiton,swap,đảo_ngược,backtracking,loop,euler,graph,đồ_thị_vô_hướng,theory,embed,cấu_trúc_dữ_liệu,classification,dữ_liệu,function,đồ_thị,nlp,ai,AI,microsoft,framework,matlab","tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","algorithm,thuật_toán,algorithms,thuật_giải",thuật_giải,thuật giải,"Thuật toán (tiếng Anh: Algorithm) , còn gọi là giải thuật, là một tập hợp hữu hạn của các chỉ thị hay phương cách được định nghĩa rõ ràng cho việc hoàn tất một số sự việc từ một trạng thái ban đầu cho trước; khi các chỉ thị này được áp dụng triệt để thì sẽ dẫn đến kết quả sau cùng như đã dự đoán trước. Nói cách khác, thuật toán là một bộ các quy tắc hay quy trình cụ thể nhằm giải quyết một vấn đề trong một số bước hữu hạn, hoặc nhằm cung cấp một kết quả từ một tập hợp của các dữ kiện đưa vào.",,,,,,
thuật_toán,Object,"khoa_học_máy_tính,richard_bellman,tìm_kiếm,bellman,sắp_xếp,embed,cấu_trúc_dữ_liệu","bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,heapsort,quicksort,đệ_quy,độ_phức_tạp,thiết_kế","algorithm,thuật_giải,giải_thuật,algorithms",,thuật toán,"Thuật toán (tiếng Anh: Algorithm) , còn gọi là giải thuật, là một tập hợp hữu hạn của các chỉ thị hay phương cách được định nghĩa rõ ràng cho việc hoàn tất một số sự việc từ một trạng thái ban đầu cho trước; khi các chỉ thị này được áp dụng triệt để thì sẽ dẫn đến kết quả sau cùng như đã dự đoán trước. Nói cách khác, thuật toán là một bộ các quy tắc hay quy trình cụ thể nhằm giải quyết một vấn đề trong một số bước hữu hạn, hoặc nhằm cung cấp một kết quả từ một tập hợp của các dữ kiện đưa vào.",,,,,,
algorithms,Object,"hiệu_quả,khoa_học_máy_tính,search,tìm_kiếm,natural_language_processing,google,liên_tục,heuristic,lập_trình,lập_trình_viên,công_cụ,lặp,halmiton,swap,đảo_ngược,backtracking,loop,euler,graph,đồ_thị_vô_hướng,theory,embed,cấu_trúc_dữ_liệu,classification,dữ_liệu,function,đồ_thị,nlp,ai,AI,microsoft,framework,matlab","tham_lam,rời_rạc,truy_hồi,tối_ưu_hóa,java,offline,sort,bfs,dfs,parallel,dijsktra,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear","algorithm,thuật_giải,giải_thuật,thuật_toán",algorithm,algorithm,"Thuật toán (tiếng Anh: Algorithm) , còn gọi là giải thuật, là một tập hợp hữu hạn của các chỉ thị hay phương cách được định nghĩa rõ ràng cho việc hoàn tất một số sự việc từ một trạng thái ban đầu cho trước; khi các chỉ thị này được áp dụng triệt để thì sẽ dẫn đến kết quả sau cùng như đã dự đoán trước. Nói cách khác, thuật toán là một bộ các quy tắc hay quy trình cụ thể nhằm giải quyết một vấn đề trong một số bước hữu hạn, hoặc nhằm cung cấp một kết quả từ một tập hợp của các dữ kiện đưa vào.",,,,,,
richard_bellman,Entity,"thuật_toán,khoa_học_máy_tính",quy_hoạch_động,,bellman,richard bellman,"Richard Ernest Bellman là một nhà toán học ứng dụng người Mỹ, được ghi nhớ vì phát minh ra quy hoạch động vào năm 1953, và nhiều đóng góp quan trọng trong nhiều lĩnh vực toán học khác.",26 tháng 8 năm 1920,19 tháng 3 năm 1984,,Toán học ứng dụng,Hoa Kỳ,
bellman,Entity,"thuật_toán,khoa_học_máy_tính",quy_hoạch_động,,richard_bellman,richard bellman,"Richard Ernest Bellman là một nhà toán học ứng dụng người Mỹ, được ghi nhớ vì phát minh ra quy hoạch động vào năm 1953, và nhiều đóng góp quan trọng trong nhiều lĩnh vực toán học khác.",26 tháng 8 năm 1920,19 tháng 3 năm 1984,,Toán học ứng dụng,Hoa Kỳ,
sắp_xếp,Other,thuật_toán,"heap_sort,heapsort,quick_sort,quicksort",sort,,sắp xếp,,,,,,,
bruce_force,Entity,"độ_phức_tạp,thiết_kế,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,heapsort,quicksort,đệ_quy",thuật_toán,,,bruce force,"Brute Force là một thuật toán vét cạn, thuật toán này sẽ chạy tất cả các trường hợp có thể có để giải quyết một vấn đề nào đó (Bao gồm cả trường hợp đúng và các trường hợp sai hay còn gọi là trường hợp dư thừa).",,,,,,
greedy,Entity,"độ_phức_tạp,thiết_kế,bruce_force,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,heapsort,quicksort,đệ_quy",thuật_toán,tham_lam,,greedy,Giải thuật tham lam (tiếng Anh: Greedy algorithm) là một thuật toán giải quyết một bài toán theo kiểu metaheuristic để tìm kiếm lựa chọn tối ưu địa phương ở mỗi bước đi với hy vọng tìm được tối ưu toàn cục.,,,,,,
heap_sort,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,quicksort,đệ_quy","thuật_toán,sắp_xếp",,heapsort,heap sort,"Sắp xếp vun đống (Heapsort) là thuật toán sắp xếp dựa trên một cấu trúc dữ liệu được gọi là đống nhị phân (binary heap), gọi đơn giản là đống.",,,,,,
quick_sort,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,heapsort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,đệ_quy","thuật_toán,sắp_xếp",,quicksort,quick sort,"Sắp xếp nhanh (Quicksort), còn được gọi là sắp xếp kiểu phân chia (part sort) là một thuật toán sắp xếp phát triển bởi C.A.R. Hoare",,,,,,
quy_hoạch_động,Entity,"natural_language_processing,cấu_trúc_dữ_liệu,classification,nlp,ai,AI,rời_rạc,truy_hồi,parallel,độ_phức_tạp,lý_thuyết_đồ_thị,thiết_kế,linear,bruce_force,greedy,heap_sort,quick_sort,heapsort,quicksort,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,đệ_quy,lý_thuyết_trò_chơi,thông_minh,neighbor,donald_knuth","thuật_toán,khoa_học_máy_tính,richard_bellman,bellman",,,quy hoạch động,"Trong ngành khoa học máy tính, quy hoạch động là một phương pháp giảm thời gian chạy của các thuật toán thể hiện các tính chất của các bài toán con gối nhau (overlapping subproblem) và cấu trúc con tối ưu (optimal substructure).",,,,,,
tìm_kiếm_nhị_phân,Entity,"heuristic,truy_hồi,độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,heapsort,quicksort,vét_cạn,đệ_qui,đệ_quy","thuật_toán,tìm_kiếm",binary_search,,tìm kiếm nhị phân,,,,,,,
vét_cạn,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,heapsort,quicksort,đệ_qui,đệ_quy",thuật_toán,backtracking,,vét cạn,,,,,,,
đệ_qui,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,heapsort,quicksort",thuật_toán,"recursion,đệ_quy",đệ_quy,đệ qui,,,,,,,
heapsort,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,quicksort,đệ_quy","thuật_toán,sắp_xếp",,heap_sort,heap sort,"Sắp xếp vun đống (Heapsort) là thuật toán sắp xếp dựa trên một cấu trúc dữ liệu được gọi là đống nhị phân (binary heap), gọi đơn giản là đống.",,,,,,
quicksort,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,heapsort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,đệ_qui,đệ_quy","thuật_toán,sắp_xếp",,quick_sort,quick sort,"Sắp xếp nhanh (Quicksort), còn được gọi là sắp xếp kiểu phân chia (part sort) là một thuật toán sắp xếp phát triển bởi C.A.R. Hoare",,,,,,
đệ_quy,Entity,"độ_phức_tạp,thiết_kế,bruce_force,greedy,heap_sort,quick_sort,quy_hoạch_động,tìm_kiếm_nhị_phân,vét_cạn,heapsort,quicksort",thuật_toán,"đệ_qui,recursion",đệ_qui,đệ qui,,,,,,,
train,Entity,"khoa_học_máy_tính,linear,ctdl,tài_liệu,neighbor,chiến_lược,kĩ_thuật,protocol,dataset,overflow,tuple,dung_lượng","classification,dữ_liệu",huấn_luyện,,train,"Một tập huấn luyện được sử dụng trong trí tuệ nhân tạo, cùng với phương pháp học có giám sát, và nó bao gồm một vec-tơ đầu vào và một vec-tơ kết quả.",,,,,,
chiến_lược,Other,"khoa_học_máy_tính,dữ_liệu,linear,train,neighbor,kĩ_thuật",classification,,,chiến lược,,,,,,,
kĩ_thuật,Other,"khoa_học_máy_tính,tìm_kiếm,natural_language_processing,lập_trình_viên,đồ_thị_vô_hướng,dữ_liệu,function,đồ_thị,nlp,ai,AI,tối_ưu_hóa,linear,train,chiến_lược,ctdl,node,lý_thuyết_trò_chơi,neighbor","heuristic,classification,xóa_đỉnh,tuple",,,kĩ thuật,,,,,,,
tài_liệu,Object,"khoa_học_máy_tính,google,heuristic,công_cụ,classification,microsoft,framework,matlab,truy_hồi,linear,train,ctdl,cấp_phát,var,chuỗi,query,bool,kernel,thông_minh,thuật_ngữ,protocol,overflow,tuple,dung_lượng,giải_phóng,biến_số,bit,mâu_thuẫn,trạng_thái","natural_language_processing,dữ_liệu,nlp,ai,AI,bộ_nhớ,string,dataset",,,tài liệu,,,,,,,
thuật_ngữ,Entity,"khoa_học_máy_tính,heuristic,truy_hồi,tài_liệu,cấp_phát,chuỗi,string,bool,class,operator,toán_tử,thông_minh,giải_phóng,biên_toàn_cục","natural_language_processing,nlp,ai,AI,hằng_số,var,oop",,,thuật ngữ,,,,,,,
chuỗi,Object,"khoa_học_máy_tính,natural_language_processing,heuristic,nlp,ai,AI,truy_hồi,tài_liệu,thuật_ngữ,thông_minh,var,query,bool,input,đầu_vào","natural_language_processing,nlp,ai,AI,string",string,,chuỗi,"Chuỗi ký tự là một dãy gồm các ký tự hoặc một mảng các ký tự được kết thúc bằng ký tự '\0' (còn được gọi là ký tự NULL trong bảng mã Ascii). Các hằng chuỗi ký tự được đặt trong cặp dấu nháy kép """".",,,,,,
lý_thuyết_trò_chơi,Entity,"tìm_kiếm,natural_language_processing,cấu_trúc_dữ_liệu,classification,function,nlp,ai,AI,rời_rạc,truy_hồi,tối_ưu_hóa,parallel,lý_thuyết_đồ_thị,linear,quy_hoạch_động,kĩ_thuật,thông_minh,neighbor,donald_knuth","khoa_học_máy_tính,heuristic,theory",,,lý thuyết trò chơi,"Lý thuyết trò chơi là một nhánh của Toán học ứng dụng. Ngành này nghiên cứu các tình huống chiến thuật trong đó các đối thủ lựa chọn các hành động khác nhau để cố gắng làm tối đa kết quả nhận được. Ban đầu được phát triển như là một công cụ để nghiên cứu hành vi kinh tế học, ngày nay Lý thuyết trò chơi được sử dụng trong nhiều ngành khoa học, từ Sinh học tới Triết học. Lý thuyết trò chơi đã có sự phát triển lớn từ khi John von Neumann là người đầu tiên hình thức hóa nó trong thời kỳ trước và trong Chiến tranh Lạnh, chủ yếu do áp dụng của nó trong chiến lược quân sự, nổi tiếng nhất là khái niệm đảm bảo phá hủy lẫn nhau (mutual assured destruction). Bắt đầu từ những năm 1970, Lý thuyết trò chơi bắt đầu được áp dụng cho nghiên cứu về hành vi động vật, trong đó có sự phát triển của các loài qua chọn lọc tự nhiên. Do các trò chơi hay như Song đề tù nhân(prisoner's dilemma), trong đó lợi ích cá nhân làm hại cho tất cả mọi người, Lý thuyết trò chơi đã bắt đầu được dùng trong Chính trị học, Đạo đức họcvà triết học. Cuối cùng, Lý thuyết trò chơi gần đây đã thu hút được sự chú ý của các nhà Khoa học máy tính do ứng dụng của nó trong Trí tuệ nhân tạo và Điều khiển học.",,,,,,
thông_minh,Object,"heuristic,cấu_trúc_dữ_liệu,classification,rời_rạc,truy_hồi,parallel,lý_thuyết_đồ_thị,linear,quy_hoạch_động,tài_liệu,thuật_ngữ,lý_thuyết_trò_chơi,chuỗi,neighbor,donald_knuth","khoa_học_máy_tính,natural_language_processing,nlp,ai,AI",,,thông minh,"Trí thông minh hay trí năng được định nghĩa theo nhiều cách khác nhau bao gồm khả năng logic, trừu tượng, sự hiểu biết, tự nhận thức, học tập, có trí tuệ xúc cảm, trí nhớ, kế hoạch, và giải quyết vấn đề. Trí thông minh được nghiên cứu rộng rãi ở loài người, nhưng cũng được quan sát ở động vậtvà thực vật. Trí tuệ nhân tạo là sự mô phỏng trí thông minh ở máy móc.",,,,,,
neighbor,Object,"natural_language_processing,google,công_cụ,lặp,halmiton,backtracking,cấu_trúc_dữ_liệu,dữ_liệu,nlp,ai,AI,microsoft,framework,matlab,rời_rạc,truy_hồi,bfs,dfs,parallel,dijsktra,lý_thuyết_đồ_thị,linear,quy_hoạch_động,train,chiến_lược,kĩ_thuật,lý_thuyết_trò_chơi,thông_minh,query,donald_knuth","khoa_học_máy_tính,search,classification",,,neighbor,,,,,,,
donald_knuth,Entity,"natural_language_processing,google,công_cụ,cấu_trúc_dữ_liệu,classification,nlp,ai,AI,microsoft,framework,matlab,rời_rạc,truy_hồi,java,parallel,lý_thuyết_đồ_thị,linear,quy_hoạch_động,lý_thuyết_trò_chơi,thông_minh,neighbor,cú_pháp,tuple","khoa_học_máy_tính,lập_trình_viên",,,Donald Ervin Knuth,"Donald Ervin Knuth (sinh ngày 10 tháng 1, năm 1938) là một nhà khoa học máy tính nổi tiếng hiện đang là giáo sư danh dự tại Đại học Stanford. Knuth được biết đến nhiều nhất là tác giả của bộ sách Nghệ thuật lập trình máy tính (The Art of Computer Programming, TAOCP), một trong những sách tham khảo được coi trọng nhất trong ngành khoa học máy tính. Ông đã tạo ra ngành phân tích thuật toán và đã đem lại nhiều cống hiến nền tảng cho ngành khoa học máy tính lý thuyết. Ông đã tạo ra hệ thống sắp chữ TEX và hệ thống phát họa phông chữ METAFONT, và cũng là người khởi xướng khái niệm lập trình học thức (literate programming)

","10 tháng 1, 1938",,Đại học Standford,Khoa học máy tính,Hoa Kì,
computer_science,Object,,,khoa_học_máy_tính,,computer science,Khoa học máy tính (tiếng Anh: computer science) là ngành nghiên cứu các cơ sở lý thuyết về thông tin và tính toán cùng sự thực hiện và ứng dụng của chúng trong các hệ thống máy tính.,,,,,,
luật,Object,"search,natural_language_processing,nlp,ai,AI,input,lời_giải,đáp_án","suy_diễn_lùi,suy_diễn_tiến,sự_kiện,acm",,,luật,"Phương pháp biểu diễn tri thức bằng luật sinh được phát minh bởi Newell và Simon trong lúc hai ông đang cố gắng xây dựng một hệ giải bài toán tổng quát. Đây là một kiểu biểu diễn tri thức có cấu trúc. Ý tưởng cơ bản là tri thức có thể được cấu trúc bằng một cặp điều kiện – hành động : ""NẾU điều kiện xảy ra THÌ hành động sẽ được thi hành"". Chẳng hạn : NẾU đèn giao thông là đỏ THÌ bạn không được đi thẳng, NẾU máy tính đã mở mà không khởi động được THÌ kiểm tra nguồn điện, …",,,,,,
sự_kiện,Object,"search,sort,lời_giải,đáp_án","suy_diễn_lùi,suy_diễn_tiến,luật",,acm,sự kiện,"ACM, viết tắt từ Association for Computing Machinery, thành lập năm 1947, là một hiệp hội quốc tế về nghiên cứu, giáo dục ngành Khoa học máy tính và Tin học uy tín nhất thế giới với hơn 100.000 hội viên, tính đến năm 2011.",,,,,,
windows,Entity,"search,google,lập_trình_viên,công_cụ,microsoft,framework,matlab,truy_hồi,java,kernel,cú_pháp","google,công_cụ,microsoft,framework,matlab",,,windows,"Microsoft Windows (hoặc đơn giản là Windows) là tên của một họ hệ điều hành dựa trên giao diện người dùng đồ hoạ được phát triển và được phân phối bởi Microsoft. Nó bao gồm một vài các dòng hệ điều hành, mỗi trong số đó phục vụ một phần nhất định của ngành công nghiệp máy tính. Các dòng Windows hiện tại gồm Windows NT, Windows Embedded và Windows Phone; chúng có thể bao gồm các phân họ, VD: Windows Embedded Compact (Windows CE) hoặc Windows Server. Các dòng Windows đã bị ngừng gồm Windows 9x và Windows Mobile.",,,,,,
string,Entity,"search,natural_language_processing,dữ_liệu,nlp,ai,AI,thuật_ngữ,bộ_nhớ,variance,dataset,cấp_phát,query,bool,overflow,mã_băm,tham_số,giải_phóng,biên_toàn_cục","tài_liệu,var,chuỗi,query,bool",chuỗi,,string,,,,,,,
acm,Object,"search,sort,lời_giải,đáp_án","suy_diễn_lùi,suy_diễn_tiến,luật",,sự_kiện,sự kiện,"ACM, viết tắt từ Association for Computing Machinery, thành lập năm 1947, là một hiệp hội quốc tế về nghiên cứu, giáo dục ngành Khoa học máy tính và Tin học uy tín nhất thế giới với hơn 100.000 hội viên, tính đến năm 2011.",,,,,,
cú_pháp,Object,"search,dữ_liệu,truy_hồi,java,donald_knuth,trình_biên_dịch,tuple,mã_hóa,bảo_mật,windows,biên_dịch,debug,class,lớp,kế_thừa,operator,toán_tử","google,lập_trình_viên,công_cụ,microsoft,framework,matlab,protocol,lỗi_cú_pháp,compiler,lập_trình_hướng_đối_tượng",,,cú pháp,,,,,,,
query,Entity,"natural_language_processing,google,công_cụ,lặp,halmiton,backtracking,nlp,ai,AI,microsoft,framework,matlab,truy_hồi,bfs,dfs,dijsktra,lý_thuyết_đồ_thị,tài_liệu,neighbor,var,string,chuỗi,input,bool","search,string",,,query,,,,,,,
bộ_nhớ,Object,"natural_language_processing,graph,embed,dữ_liệu,nlp,ai,AI,trình_biên_dịch,var,variance,dataset,string,ascii,bảng_băm,nhị_phân,tree","tài_liệu,kernel,overflow,giải_phóng,cấp_phát,biến_số,bit,mâu_thuẫn,dung_lượng,trạng_thái",,,bộ nhớ,"Bộ nhớ máy tính (tiếng Anh: Computer data storage), thường được gọi là ổ nhớ (storage) hoặc bộ nhớ (memory), là một thiết bị công nghệ bao gồm các phần tử máy tính và lưu trữ dữ liệu, được dùng để duy trì dữ liệu số. Nó là một linh kiện cơ bản có chức năng cốt lõi của các máy tính.",,,,,,
hằng_số,Object,"natural_language_processing,nlp,ai,AI,var,variance,cấp_phát,oop",thuật_ngữ,,,hằng số,"Trong vật lý và toán học, hằng số là đại lượng có giá trị không đổi. Hằng số thường được ký hiệu là const, viết tắt chữ tiếng Anh constant.",,,,,,
var,Entity,"natural_language_processing,nlp,ai,AI,tài_liệu,bộ_nhớ,hằng_số,chuỗi,đầu_vào,bit,dung_lượng,oop,query,tham_số","thuật_ngữ,cấp_phát,giải_phóng,bool,string,biên_toàn_cục","variance,biến_số",,var,,,,,,,
optimize,Other,"natural_language_processing,nlp,ai,AI",,tối_ưu_hóa,,optimize,,,,,,,
rời_rạc_hóa,,"natural_language_processing,nlp,ai,AI",,,,rời rạc hóa,,,,,,,
oop,Entity,"natural_language_processing,nlp,ai,AI,var,hằng_số","thuật_ngữ,class,operator,toán_tử","lập_trình_hướng_đối_tượng,Object_oriented_programming",,oop,,,,,,,
dataset,Entity,"natural_language_processing,đồ_thị_vô_hướng,classification,đồ_thị,nlp,ai,AI,linear,train,bộ_nhớ,tree,string,dslk,dslk_đơn,protocol,mã_băm,cấu_trúc,ngăn_xếp,bảng_băm,matrix,tuple,leaf,overflow,dung_lượng","dữ_liệu,tài_liệu,ctdl",,,dataset,"DataSet là một đối tượng có thể chứa nhiều DataTable cùng với mối liên hệ giữa chúng (relationship) và kể các ràng buộc (constraint) được lưu hoàn toàn trong bộ nhớ để làm việc offline. Qua bài viết này, bạn có thể hiểu cấu trúc của DataSet, DataTable cũng như nạp dữ liệu, tạo relation, constraint và thao tác dữ liệu trên các đối tượng dữ liệu này.",,,,,,
artificial_intelligence,Entity,,,"natural_language_processing,nlp,ai,AI,trí_tuệ_nhân_tạo",,artificial intelligence,,,,,,,
trí_tuệ_nhân_tạo,Entity,,,"natural_language_processing,nlp,ai,artificial_intelligence,AI",,trí tuệ nhân tạo,,,,,,,
bảo_mật,Other,"google,công_cụ,dữ_liệu,function,microsoft,framework,matlab,ascii,bảng_băm,nhị_phân,overflow,ctdl,ngẫu_nhiên,online,admin,cú_pháp,trình_duyệt","mã_băm,protocol,mã_hóa,admin,giao_thức",,,bảo mật,"Bảo mật là sự hạn chế khả năng lạm dụng tài nguyên và tài sản. Bảo mật trở nên đặc biệt phức tạp trong quản lý, vận hành những hệ thống thông tin có sử dụng các công cụ tin học, nơi có thể xảy ra và lan tràn nhanh chóng việc lạm dụng tài nguyên (các thông tin di chuyển vô hình trên mạng hoặc lưu trữ hữu hình trong các vật liệu) và lạm dụng tài sản (các máy tính, thiết bị mạng, thiết bị ngoại vi, các phần mềm của cơ quan hoặc người sở hữu hệ thống). Hạn chế ở đây có ý rằng không thể triệt phá hết ngay việc lạm dụng, cho nên cần sẵn sàng đề phòng mọi khả năng xấu với các phương cách thích hợp và chuẩn bị xử lý các sự cố nếu có việc lạm dụng xảy ra.",,,,,,
tuple,Other,"google,heuristic,công_cụ,đồ_thị_vô_hướng,classification,đồ_thị,microsoft,framework,matlab,java,linear,train,tài_liệu,donald_knuth,dataset,bảng_băm,tree,overflow,dung_lượng,xóa_đỉnh,leaf,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,matrix,mã_băm,cú_pháp,operator,protocol,toán_tử","lập_trình_viên,dữ_liệu,kĩ_thuật,ctdl",,,tuple,"Tuple là một container cũng được sử dụng rất nhiều trong các chương trình Python không thua kém gì List. Một Tuple gồm các yếu tố sau: Được giới hạn bởi cặp ngoặc (), tất cả những gì nằm trong đó là những phần tử của Tuple; Các phần tử của Tuple được phân cách nhau ra bởi dấu phẩy ; Tuple có khả năng chứa mọi giá trị, đối tượng trong Python.",,,,,,
lỗi_cú_pháp,Object,"google,lập_trình_viên,công_cụ,embed,microsoft,framework,matlab,kernel,protocol,lập_trình_hướng_đối_tượng","trình_biên_dịch,cú_pháp,compiler,biên_dịch,debug",,,lỗi cú pháp,"Ứng với mỗi ngôn ngữ lập trình, sẽ có bộ cú pháp riêng. Nhưng dù có sử dụng ngôn ngữ nào thì lập trình viên vẫn luôn luôn phải đối mặt với lỗi sai phổ biến nhất là lỗi cú pháp.",,,,,,
lập_trình_hướng_đối_tượng,Entity,"google,lập_trình_viên,công_cụ,microsoft,framework,matlab,protocol,lỗi_cú_pháp,compiler,hiệu_năng","cú_pháp,class,lớp,kế_thừa,operator,toán_tử","oop,Object_oriented_programming",,lập trình hướng đối tượng,"Lập trình hướng đối tượng (tiếng Anh: Object-oriented programming, viết tắt: OOP) là một mẫu hình lập trình dựa trên khái niệm ""công nghệ đối tượng"", mà trong đó, đối tượng chứa đựng các dữ liệu, trên các trường, thường được gọi là các thuộc tính; và mã nguồn, được tổ chức thành các phương thức. Phương thức giúp cho đối tượng có thể truy xuất và hiệu chỉnh các trường dữ liệu của đối tượng khác, mà đối tượng hiện tại có tương tác (đối tượng được hỗ trợ các phương thức ""this"" hoặc ""self""). Trong lập trình hướng đối tượng, chương trình máy tính được thiết kế bằng cách tách nó ra khỏi phạm vi các đối tượng tương tác với nhau.[1][2] Ngôn ngữ lập trình hướng đối tượng khá đa dạng, phần lớn là các ngôn ngữ lập trình theo lớp, nghĩa là các đối tượng trong các ngôn ngữ này được xem như thực thể của một lớp, được dùng để định nghĩa một kiểu dữ liệu.",,,,,,
protocol,Object,"google,lập_trình_viên,công_cụ,classification,microsoft,framework,matlab,linear,train,tài_liệu,dataset,ascii,bảng_băm,nhị_phân,overflow,dung_lượng,ctdl,ngẫu_nhiên,mã_băm,tuple,lỗi_cú_pháp,compiler,lập_trình_hướng_đối_tượng,admin","dữ_liệu,bảo_mật,mã_hóa,cú_pháp",giao_thức,,protocol,"Việc trao đổi thông tin dù là đơn giản nhất cũng phải tuân theo những nguyên tắc nhất định. Đơn giản như hai người nói chuyện với nhau, muốn cho cuộc nói chuyện có kết quả thì ít nhất cả hai người phải ngầm tuân thủ quy ước : Khi một người nói thì người kia phải biết lắng nghe và ngược lại. Việc truyền thông trên mạng cũng vậy. Cần có các quy tắc, quy ước truyền thông về nhiều mặt : khuôn dạng cú pháp của dữ liệu, các thủ tục gửi, nhận dữ liệu, kiểm soát hiệu quả nhất chất lượng truyền thông tin. Tập hợp những quy tắc, quy ước truyền thông đó được gọi là giao thức của mạng (protocol).",,,,,,
compiler,Entity,"google,lập_trình_viên,công_cụ,embed,microsoft,framework,matlab,protocol,lập_trình_hướng_đối_tượng","cú_pháp,lỗi_cú_pháp,debug","trình_biên_dịch,biên_dịch",,compiler,"Trình biên dịch, còn gọi là phần mềm biên dịch, compiler, là một chương trình máy tính làm công việc dịch một chuỗi các câu lệnh được viết bằng một ngôn ngữ lập trình (gọi là ngôn ngữ nguồn hay mã nguồn), thành một chương trình tương đương nhưng ở dưới dạng một ngôn ngữ máy tính mới (gọi là ngôn ngữ đích) và thường là ngôn ngữ ở cấp thấp hơn, như ngôn ngữ máy. Chương trình mới được dịch này gọi mã đối tượng.",,,,,,
đầu_vào,Object,"heuristic,swap,linear,var,kernel,mã_băm,bool,chuỗi,phân_hoạch,tham_số,ánh_xạ,truy_nhập",function,input,,đầu vào,"Các hằng chuỗi ký tự được đặt trong cặp dấu nháy kép """".",,,,,,
phân_hoạch,Other,"heuristic,swap,linear,mã_băm,đầu_vào,tham_số,ánh_xạ,truy_nhập",function,,,phân hoạch,"Trong số học, sự phân tích một số nguyên dương n là cách viết số đó dưới dạng tổng của các số nguyên dương. Hai cách phân tích có các số hạng giống nhau được coi là một cách phân tích. Số lượng cách phân tích số n được tính bởi hàm phân tích, ký hiệu là p(n).",,,,,,
mã_băm,Entity,"heuristic,swap,đồ_thị_vô_hướng,dữ_liệu,đồ_thị,linear,dataset,string,ascii,nhị_phân,tree,ngẫu_nhiên,leaf,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,matrix,đầu_vào,protocol,admin,giao_thức,phân_hoạch,tham_số,ánh_xạ,truy_nhập,tuple","function,ctdl,bảo_mật,mã_hóa","bảng_băm,hàm_băm",,mã băm," hay hàm băm là một hàm mã hóa trong máy tính. Hàm này được dùng dùng để mã hóa các dữ liệu với dung lượng bất kỳ về một loại dữ liệu với dung lượng nhất định. Hàm hash thường được dùng phổ biến với kiểu dữ liệu cơ bản như kiểu chuỗi, kiểu số, mảng, Object... nhưng nó có thể dùng với bất cứ loại dữ liệu nào thậm chỉ cả kiểu dữ liệu binary.",,,,,,
tham_số,Object,"heuristic,swap,linear,var,string,mã_băm,bool,đầu_vào,phân_hoạch,ánh_xạ,truy_nhập","function,biên_toàn_cục",,,tham số,,,,,,,
ánh_xạ,Other,"heuristic,swap,linear,mã_băm,đầu_vào,tham_số,phân_hoạch,truy_nhập",function,,,ánh xạ,"Trong toán học, ánh xạ là khái quát của khái niệm hàm số. hàm số lại xuất phát từ khái niệm tương quan giữa các đại lượng vật lý. Chẳng hạn trong một chuyển động đều, độ dài quãng đường đi được bằng tích của tốc độ với thời gian. Nếu tốc độ là 5cm/s thì quãng đường đi được trong t giây là s= 5t",,,,,,
truy_nhập,Other,"heuristic,swap,linear,mã_băm,đầu_vào,tham_số,phân_hoạch,ánh_xạ",function,,,truy nhập,,,,,,,
xóa_đỉnh,Other,"heuristic,euler,classification,lý_thuyết_đồ_thị,tree,ctdl,cây,toán_học,insert,dslk,dslk_đơn,euclidean,không_gian_vector,tuple","đồ_thị_vô_hướng,đồ_thị,kĩ_thuật,node",,,xóa đỉnh,,,,,,,
ctdl,Object,"lập_trình_viên,euler,graph,classification,function,lý_thuyết_đồ_thị,linear,train,kĩ_thuật,tài_liệu,overflow,bit,dung_lượng,trạng_thái,cây,toán_học,node,tiền_tố,hậu_tố,protocol,xóa_đỉnh,euclidean,không_gian_vector,mã_hóa,phần_tử,kích_thước,bảo_mật","đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,matrix,mã_băm,tuple,leaf",cấu_trúc_dữ_liệu,,ctdl,,,,,,,
cây,Object,"halmiton,backtracking,euler,lý_thuyết_đồ_thị,trạng_thái,ctdl,toán_học,insert,vertex,liên_thông,node,xóa_đỉnh,euclidean,không_gian_vector","graph,đồ_thị_vô_hướng,đồ_thị,nút_gốc,root",tree,,cây,"Cây (tiếng Anh: Tree) là khái niệm quan trọng trong lý thuyết đồ thị, cấu trúc dữ liệu và giải thuật. Cây là một đồ thị mà trong đó hai đỉnh bất kì đều được nối với nhau bằng đúng một đường đi. Nói cách khác, đồ thị liên thông bất kỳ không có chu trình là một cây.",,,,,,
tree,Other,"halmiton,backtracking,euler,dữ_liệu,bfs,dfs,lý_thuyết_đồ_thị,bộ_nhớ,dataset,bảng_băm,toán_học,insert,vertex,liên_thông,xóa_đỉnh,euclidean,không_gian_vector,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,matrix,mã_băm,tuple","graph,đồ_thị_vô_hướng,đồ_thị,ctdl,node,leaf,trạng_thái,tiền_tố,hậu_tố",cây,,tree,,,,,,,
insert,Other,"halmiton,backtracking,đồ_thị_vô_hướng,đồ_thị,lý_thuyết_đồ_thị,tree,trạng_thái,cây,dslk,dslk_đơn,xóa_đỉnh,vertex,liên_thông","graph,node",,,insert,,,,,,,
vertex,Object,"halmiton,backtracking,lý_thuyết_đồ_thị,tree,trạng_thái,cây,insert,liên_thông",graph,,,vertex,đỉnh trong đồ thị,,,,,,
liên_thông,Entity,"halmiton,backtracking,lý_thuyết_đồ_thị,tree,trạng_thái,cây,insert,vertex",graph,,,liên thông,"Trong lý thuyết đồ thị, một thành phần liên thông của một đồ thị vô hướng là một đồ thị con trong đó giữa bất kì hai đỉnh nào đều có đường đi đến nhau, và không thể nhận thêm bất kì một đỉnh nào mà vẫn duy trì tính chất trên.",,,,,,
trạng_thái,Object,"halmiton,backtracking,đồ_thị_vô_hướng,đồ_thị,lý_thuyết_đồ_thị,tài_liệu,kernel,overflow,giải_phóng,cấp_phát,biến_số,bit,mâu_thuẫn,dung_lượng,cây,ctdl,node,insert,vertex,leaf,liên_thông,tiền_tố,hậu_tố","graph,bộ_nhớ,tree",,,trạng thái,,,,,,,
hoán_vị,Other,,,swap,,hoán vị,,,,,,,
toán_học,Object,"euler,lý_thuyết_đồ_thị,tree,ctdl,cây,fibonacci,ngẫu_nhiên,trung_vị,bayes,node,xóa_đỉnh,euclidean,không_gian_vector","đồ_thị_vô_hướng,đồ_thị,dãy_fibonacci,xác_suất,đường_thẳng",,,toán học,,,,,,,
node,Object,"euler,graph,lý_thuyết_đồ_thị,kĩ_thuật,trạng_thái,ctdl,cây,toán_học,leaf,tiền_tố,hậu_tố,euclidean,không_gian_vector","đồ_thị_vô_hướng,đồ_thị,tree,insert,dslk,dslk_đơn,xóa_đỉnh",,,node,,,,,,,
euclidean,Entity,"lý_thuyết_đồ_thị,tree,ctdl,cây,toán_học,node,xóa_đỉnh","euler,đồ_thị_vô_hướng,đồ_thị,không_gian_vector",,,euclidean,"Khoảng cách Euclidean (Euclidean Distance): Khoảng cách giữa 2 điểm là chiều dài của đường thẳng nối chúng. Trong mặt phẳng, khoảng cách giữa 2 điểm (x1, y1)  và (x2, y2) được cho bởi định lý Pythagorean như sau:",,,,,,
không_gian_vector,Entity,"lý_thuyết_đồ_thị,tree,ctdl,cây,toán_học,node,xóa_đỉnh","euler,đồ_thị_vô_hướng,đồ_thị,euclidean",,,không gian vector,"Trong toán học, không gian vectơ là một tập hợp mà trên đó hai phép toán, phép cộng vectơ và phép nhân vectơ với một số, được định nghĩa và thỏa mãn các tiên đề được liệt kê dưới đây.",,,,,,
nút_gốc,Other,"graph,đồ_thị_vô_hướng,đồ_thị",cây,,root,nút gốc,,,,,,,
root,Other,"graph,đồ_thị_vô_hướng,đồ_thị",cây,,nút_gốc,nút gốc,,,,,,,
leaf,Object,"graph,đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,trạng_thái,node,dslk,dslk_đơn,mã_băm,cấu_trúc,ngăn_xếp,matrix,tuple,tiền_tố,hậu_tố","tree,ctdl",,,leaf,,,,,,,
tiền_tố,Object,"graph,đồ_thị_vô_hướng,đồ_thị,trạng_thái,ctdl,node,leaf","tree,ngăn_xếp,hậu_tố",prefix,,tiền tố,"Trong toán học thì các biểu thức thường được biểu diễn dưới dạng trung tố (các toán tử nằm giữa các toán hạng) cho dễ hiểu, đó là đối với con người. Còn đối với máy tính thì nó khó hiểu đối với chúng. Vì vậy, để hiểu được máy tính phải đưa biểu thức dạng trung tố về dạng tiền tố hoặc hậu tố. Trong bài viết này tôi trình bày cách đưa biểu thức dạng trung tố về dạng tiền tố và tính toán biểu thức tiền tố.",,,,,,
hậu_tố,Object,"graph,đồ_thị_vô_hướng,đồ_thị,trạng_thái,ctdl,node,leaf","tree,tiền_tố,ngăn_xếp",postfix,,hậu tố,"Việc tính giá trị của một biểu thức toán học ở dạng trung tố trong máy tính thông thường sẽ được chuyển sang dạng ký pháp nghịch đảo Ba Lan (hậu tố) để việc tính toán được dễ dàng. Bạn có thể xem lại thuật toán chuyển đổi từ trung tố sang hậu tố trong bài viết “Chuyển biểu thức trung tố sang tiền tố và hậu tố bằng Stack” của tôi, và tải project mẫu tại đây. Trong bài viết này, tôi sẽ trình bày phương pháp tính giá trị của một biểu thức tiền tố và hậu tố bằng Stack. Bạn có thể sẽ cần áp dụng kiến thức dưới đây nếu muốn tạo ra một cây biểu thức (expression tree) từ các dạng biểu thức này.",,,,,,
dãy_fibonacci,Other,"đồ_thị_vô_hướng,đồ_thị,xác_suất,đường_thẳng","toán_học,fibonacci",,,dãy fibonacci,,,,,,,
xác_suất,Other,"đồ_thị_vô_hướng,đồ_thị,dãy_fibonacci,đường_thẳng,mã_hóa","toán_học,ngẫu_nhiên,trung_vị,bayes",,,xác suất,,,,,,,
đường_thẳng,Other,"đồ_thị_vô_hướng,đồ_thị,dãy_fibonacci,xác_suất",toán_học,,,đường thẳng,,,,,,,
dslk,Entity,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,insert,xóa_đỉnh,leaf,khai_báo,cấu_trúc,ngăn_xếp,matrix,mã_băm,tuple","ctdl,node,dslk_đơn",,,dslk, Một Danh sách liên kết (Linked List) là một dãy các cấu trúc dữ liệu được kết nối với nhau thông qua các liên kết (link). Hiểu một cách đơn giản thì Danh sách liên kết là một cấu trúc dữ liệu bao gồm một nhóm các nút (node) tạo thành một chuỗi. Mỗi nút gồm dữ liệu ở nút đó và tham chiếu đến nút kế tiếp trong chuỗi.,,,,,,
dslk_đơn,Entity,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,insert,xóa_đỉnh,leaf,khai_báo,cấu_trúc,ngăn_xếp,matrix,mã_băm,tuple","ctdl,node,dslk",,,dslk đơn, Một Danh sách liên kết (Linked List) là một dãy các cấu trúc dữ liệu được kết nối với nhau thông qua các liên kết (link). Hiểu một cách đơn giản thì Danh sách liên kết ,,,,,,
cấu_trúc,Other,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,leaf,dslk,dslk_đơn,mã_băm,ngăn_xếp,matrix,tuple",ctdl,,,cấu trúc,,,,,,,
ngăn_xếp,Entity,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,overflow,leaf,dslk,dslk_đơn,cấu_trúc,mã_băm,matrix,tuple","ctdl,tiền_tố,hậu_tố",,,ngăn xếp,"Trong khoa học máy tính, một ngăn xếp (còn gọi là bộ xếp chồng, tiếng Anh: stack) là một cấu trúc dữ liệu trừu tượng hoạt động theo nguyên lý ""vào sau ra trước"" (Last In First Out (LIFO).",,,,,,
bảng_băm,Entity,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,bộ_nhớ,dataset,ascii,tree,cấp_phát,ngẫu_nhiên,bảo_mật,dslk,dslk_đơn,protocol,cấu_trúc,ngăn_xếp,matrix,tuple,leaf,nhị_phân,dung_lượng","ctdl,mã_hóa,bit","mã_băm,hàm_băm",,bảng băm,,,,,,,
matrix,Object,"đồ_thị_vô_hướng,dữ_liệu,đồ_thị,dataset,bảng_băm,tree,leaf,dslk,dslk_đơn,cấu_trúc,ngăn_xếp,input,mã_băm,tuple","ctdl,phần_tử,kích_thước",,,matrix,,,,,,,
trình_biên_dịch,Entity,"embed,bộ_nhớ,cú_pháp,debug","kernel,lỗi_cú_pháp","compiler,biên_dịch",,trình biên dịch,,,,,,,
kernel,Entity,"thiết_kế,tài_liệu,cấp_phát,đầu_vào,windows,overflow,giải_phóng,biến_số,bit,mâu_thuẫn,dung_lượng,trạng_thái,lỗi_cú_pháp,debug","embed,bộ_nhớ,trình_biên_dịch",,,kernel,"Nhân hệ điều hành (tiếng Anh: Kernel) là thành phần trung tâm của hầu hết các hệ điều hành máy tính. Nó có nhiệm vụ quản lý các tài nguyên hệ thống (liên lạc giữa các thành phần phần cứng và phần mềm).[1] Thông thường, với vai trò một thành phần cơ bản của một hệ điều hành, nhân có thể cung cấp các tầng trừu tượngmức thấp nhất cho các tài nguyên máy tính (đặc biệt là bộ nhớ, CPU, và các thiết bị vào ra mà phần mềm ứng dụng cần điều khiển để thực hiện các chức năng của mình. Nhân hệ điều hành thường cung cấp các tiện ích xử lý này cho các tiến trình của các phần mềm ứng dụng qua các cơ chế liên lạc giữa các tiến trình (inter-process communication) và các hàm hệ thống (system call).",,,,,,
debug,Other,"thiết_kế,trình_biên_dịch,kernel,cú_pháp,biên_dịch","embed,lỗi_cú_pháp,compiler",,,debug,,,,,,,
nhúng,Other,,,embed,,nhúng,,,,,,,
overflow,Other,"classification,java,linear,train,tài_liệu,dataset,string,kernel,ctdl,cấp_phát,bảo_mật,protocol,ngăn_xếp,giải_phóng,biến_số,bit,mâu_thuẫn,dung_lượng,trạng_thái,tuple","dữ_liệu,bộ_nhớ",,,overflow,Thuộc tính overflow xác định điều gì sẽ xảy ra nếu một thành phần box tràn nội dung.,,,,,,
dung_lượng,Entity,"classification,linear,train,tài_liệu,var,dataset,ascii,bảng_băm,nhị_phân,kernel,overflow,giải_phóng,biến_số,mâu_thuẫn,ctdl,protocol,tuple,trạng_thái","dữ_liệu,bộ_nhớ,cấp_phát,bit",,,dung lượng,Dung lượng là một thuật ngữ đo lường để chỉ dung lượng lưu trữ máy tính. ,,,,,,
cấp_phát,Other,"dữ_liệu,tài_liệu,thuật_ngữ,string,ascii,bảng_băm,nhị_phân,kernel,overflow,giải_phóng,hằng_số,bool,biên_toàn_cục,mâu_thuẫn,trạng_thái","bộ_nhớ,var,biến_số,bit,dung_lượng",,,cấp phát,,,,,,,
mã_hóa,Other,"dữ_liệu,function,rời_rạc,bit,ctdl,bayes,xác_suất,cú_pháp,admin,giao_thức","ascii,bảng_băm,nhị_phân,ngẫu_nhiên,mã_băm,protocol,bảo_mật",,,mã hóa,,,,,,,
bit,Entity,"dữ_liệu,tài_liệu,var,kernel,overflow,giải_phóng,biến_số,ctdl,mã_hóa,mâu_thuẫn,trạng_thái","bộ_nhớ,ascii,bảng_băm,nhị_phân,cấp_phát,dung_lượng",bít,,bit,,,,,,,
biên_toàn_cục,Object,"function,thuật_ngữ,string,giải_phóng,cấp_phát,bool","var,tham_số",,,biên toàn cục,"Vị trí biến đặt bên ngoài tất cả các hàm, cấu trúc…Các biến có ảnh hưởng tới toàn bộ chương trình",,,,,,
online,Entity,"offline,bảo_mật",giao_thức,,,online,"Online chỉ có 1 nghĩa duy nhất đó là trực tuyến, tức là bạn đang kết nối với mạng Internet. Trái nghĩa với Offline. Để hiểu rõ hơn thì bạn hãy đọc kỹ lại phần ví dụ của Offline, bạn sẽ thấy Online và Offline có mối quan hệ mật thiết với nhau.",,,,,,
song_song,Entity,,,parallel,,song song,,,,,,,
complexity,Object,,,độ_phức_tạp,,complexity,,,,,,,
theorem_graphic,Object,,,lý_thuyết_đồ_thị,,theorem graphic,,,,,,,
binary_search,Entity,,,tìm_kiếm_nhị_phân,,binary search,,,,,,,
recursion,Entity,,,"đệ_qui,đệ_quy",,recursion,,,,,,,
huấn_luyện,Entity,,,train,,huấn luyện,,,,,,,
bool,Object,"tài_liệu,thuật_ngữ,string,giải_phóng,cấp_phát,query,chuỗi,đầu_vào,tham_số,biên_toàn_cục","var,variance,string",boolean,,bool,,,,,,,
giải_phóng,Other,"tài_liệu,thuật_ngữ,string,kernel,overflow,cấp_phát,bool,biên_toàn_cục,biến_số,bit,mâu_thuẫn,dung_lượng,trạng_thái","bộ_nhớ,var,variance",,,giải phóng,,,,,,,
biến_số,Object,"tài_liệu,kernel,overflow,giải_phóng,bit,dung_lượng,mâu_thuẫn,trạng_thái","bộ_nhớ,cấp_phát","var,variance",,biến số,,,,,,,
mâu_thuẫn,Entity,"tài_liệu,kernel,overflow,giải_phóng,cấp_phát,biến_số,bit,dung_lượng,trạng_thái",bộ_nhớ,,,mâu thuẫn,,,,,,,
class,Object,"thuật_ngữ,cú_pháp,kế_thừa,operator,toán_tử","oop,lập_trình_hướng_đối_tượng",lớp,,class,,,,,,,
operator,Object,"thuật_ngữ,tuple,cú_pháp,class,lớp,kế_thừa","oop,lập_trình_hướng_đối_tượng",toán_tử,toán_tử,operator,"Trong toán học, một toán tử (tiếng Anh operator, phân biệt với operation - phép toán) là một hàm, thông thường có một vai trò quan trọng trong một lĩnh vực nào đấy. Chẳng hạn trong đại số tuyến tính có ""toán tử tuyến tính"" (linear operator). Trong giải tích có ""toán tử vi phân"" (differential operator)... Thông thường, một ""toán tử"" là một hàm tác động lên các hàm khác; hoặc nó có thể là tổng quát hóa của một hàm, như trong đại số tuyến tính.",,,,,,
toán_tử,Object,"thuật_ngữ,tuple,cú_pháp,class,lớp,kế_thừa","oop,lập_trình_hướng_đối_tượng",operator,operator,operator,"Trong toán học, một toán tử (tiếng Anh operator, phân biệt với operation - phép toán) là một hàm, thông thường có một vai trò quan trọng trong một lĩnh vực nào đấy. Chẳng hạn trong đại số tuyến tính có ""toán tử tuyến tính"" (linear operator). Trong giải tích có ""toán tử vi phân"" (differential operator)... Thông thường, một ""toán tử"" là một hàm tác động lên các hàm khác; hoặc nó có thể là tổng quát hóa của một hàm, như trong đại số tuyến tính.",,,,,,
variance,Entity,"bộ_nhớ,hằng_số,string","bool,giải_phóng","var,biến_số",,variance,,,,,,,
ascii,Entity,"bộ_nhớ,cấp_phát,ngẫu_nhiên,bảo_mật,protocol,mã_băm,bảng_băm,dung_lượng","mã_hóa,bit,nhị_phân",,,ascii,"ASCII (American Standard Code for Information Interchange - Chuẩn mã trao đổi thông tin Hoa Kỳ), thường được phát âm là át-xơ-ki, là bộ ký tự và bộ mã ký tự dựa trên bảng chữ cái La Tinh được dùng trong tiếng Anh hiện đại và các ngôn ngữ Tây Âu khác. Nó thường được dùng để hiển thị văn bản trong máy tính và các thiết bị thông tin khác. Nó cũng được dùng bởi các thiết bị điều khiển làm việc với văn bản.",,,,,,
nhị_phân,Entity,"bộ_nhớ,bảng_băm,cấp_phát,ngẫu_nhiên,bảo_mật,protocol,mã_băm,dung_lượng","ascii,mã_hóa,bit",,,nhị phân,"Hệ nhị phân (hay hệ đếm cơ số hai) là một hệ đếm dùng hai ký tự để biểu đạt một giá trị số, bằng tổng số các lũy thừa của 2. Hai ký tự đó thường là 0 và 1; chúng thường được dùng để biểu đạt hai giá trị hiệu điện thế tương ứng (có hiệu điện thế, hoặc hiệu điện thế cao là 1 và không có, hoặc thấp là 0). Do có ưu điểm tính toán đơn giản, dễ dàng thực hiện về mặt vật lý, chẳng hạn như trên các mạch điện tử, hệ nhị phân trở thành một phần kiến tạo căn bản trong các máy tính đương thời.",,,,,,
biên_dịch,Entity,"cú_pháp,debug",lỗi_cú_pháp,"compiler,trình_biên_dịch",,biên dịch,,,,,,,
ngẫu_nhiên,Other,"ascii,bảng_băm,nhị_phân,toán_học,bảo_mật,trung_vị,protocol,mã_băm","xác_suất,bayes,mã_hóa","random,randomized",,ngẫu nhiên,"Ngẫu nhiên nghĩa là thiếu một khuôn mẫu hay khả năng dự báo trong các sự kiện.[1] Sự ngẫu nhiên cho thấy một sự vô thứ tự hoặc không gắn kết trong một chuỗi các ký hiệu hoặc bước, nấc; sao cho không có một khuôn mẫu hoặc sự kết hợp nào minh bạch dễ hiểu.",,,,,,
hàm_băm,Entity,,,"mã_băm,bảng_băm",,hàm băm,,,,,,,
bít,Entity,,,bit,,bít,,,,,,,
phần_tử,Other,"ctdl,kích_thước",matrix,,,phần tử,,,,,,,
kích_thước,Other,"ctdl,phần_tử",matrix,,,kích thước,,,,,,,
fibonacci,Entity,toán_học,dãy_fibonacci,,,fibonacci,"Leonardo Pisano Bogollo, còn được biết đến với tên Leonardo của Pisa, Leonardo Pisano, Leonardo Bonacci, Leonardo Fibonacci, hay, phổ biến nhất, chỉ là Fibonacci, là một nhà toán học người Ý, được một số người xem là ""nhà toán học tài ba nhất thời Trung Cổ.",1170,1250,,Toán học,Ý,
trung_vị,Entity,"toán_học,ngẫu_nhiên,bayes",xác_suất,,,trung vị,"Trong lý thuyết xác suất và thống kê, số trung vị (tiếng Anh: median) là một số tách giữa nửa lớn hơn và nửa bé hơn của một mẫu, một quần thể, hay một phân bố xác suất. Nó là giá trị giữa trong một phân bố, mà số các số nằm trên hay dưới con số đó là bằng nhau. Điều đó có nghĩa rằng 1/2 quần thể sẽ có các giá trị nhỏ hơn hay bằng số trung vị, và một nửa quần thể sẽ có giá trị bằng hoặc lớn hơn số trung vị.",,,,,,
bayes,Entity,"toán_học,trung_vị,mã_hóa","ngẫu_nhiên,xác_suất",,,bayes,,,,,,,
random,Other,,,"ngẫu_nhiên,randomized",,random,,,,,,,
randomized,Other,,,"ngẫu_nhiên,random",,randomized,,,,,,,
prefix,Other,,,tiền_tố,,prefix,,,,,,,
postfix,Other,,,hậu_tố,,postfix,,,,,,,
khai_báo,,"dslk,dslk_đơn",,,,khai báo,,,,,,,
input,Object,"matrix,luật,query,chuỗi",,đầu_vào,,input,,,,,,,
admin,Object,"mã_băm,protocol,mã_hóa,bảo_mật,trực_quan,giao_thức","bảo_mật,trình_duyệt",,,admin,,,,,,,
giao_thức,Object,"mã_băm,mã_hóa,admin","bảo_mật,online",protocol,,giao thức,,,,,,,
trình_duyệt,Other,"bảo_mật,giao_diện","admin,trực_quan",,,trình duyệt,,,,,,,
suy_diễn_lùi,Object,,"suy_diễn_tiến,luật,sự_kiện,acm",,,suy diễn lùi,Suy diễn lùi là quá trình xuất phát từ sự kiện cần chứng minh và thay vào đó là những sự kiện ở vế trái của 1 luật có vế phải là sự kiện cần chứng minh. Quá trình này được thực hiện cho đến khi đưa về các sự kiện là tập sự kiện con của tập sự kiện giả thiết.,,,,,,
suy_diễn_tiến,Object,,"suy_diễn_lùi,luật,sự_kiện,acm",,,suy diễn tiến,"Suy diễn tiến là quá trình suy diễn bắt đầu từ tập sự kiện đã biết, rút ra những sự kiện mới và cứ như vậy cho đến khi có được sự kiện cần chứng minh hoặc không có luật nào sinh ra các sự kiện mới (tập sự kiện đúng là cực đại).",,,,,,
lời_giải,,"luật,sự_kiện,acm",,,,lời giải,,,,,,,
đáp_án,,"luật,sự_kiện,acm",,,,đáp án,,,,,,,
lớp,Object,"cú_pháp,kế_thừa,operator,toán_tử",lập_trình_hướng_đối_tượng,class,,lớp,,,,,,,
kế_thừa,Other,"cú_pháp,class,lớp,operator,toán_tử",lập_trình_hướng_đối_tượng,,,kế thừa,,,,,,,
Object_oriented_programming,Entity,,,"oop,lập_trình_hướng_đối_tượng",,Object oriented programming,,,,,,,
boolean,Entity,,,bool,,boolean,,,,,,,
trực_quan,Other,admin,"trình_duyệt,giao_diện",,,trực quan,Dùng những vật cụ thể hay ngôn ngữ cử chỉ làm cho học sinh có được hình ảnh cụ thể về nhữngđiều được học.,,,,,,
giao_diện,Other,trình_duyệt,trực_quan,,,giao diện,,,,,,,
hiệu_năng,Other,lập_trình_hướng_đối_tượng,,,,hiệu năng,,,,,,,
alan,Entity,,,turing,,Alan Turing,"Alan Mathison Turing (23 tháng 6 năm 1912 – 7 tháng 6 năm 1954) là một nhà toán học, logic học và mật mã học người Anh thường được xem là cha đẻ của ngành khoa học máy tính. Phép thử Turing (Turing test) là một trong những cống hiến của ông trong ngành trí tuệ nhân tạo: thử thách này đặt ra câu hỏi rằng máy móc có khi nào đạt được ý thức và có thể suy nghĩ được hay không. Ông đã hình thức hóa khái niệm thuật toán và tính toán với máy Turing, đồng thời đưa ra phiên bản của ""Turing"", mà ngày nay được đông đảo công chúng chấp nhận, về luận đề Church-Turing, một luận đề nói rằng tất cả những gì tính được bằng thuật toán đều có thể tính được bằng máy Turing",23/06/1912,6/7/1954,"Trường Đại học Manchester
Phòng Thí nghiệm Vật lý Quốc gia
Trường Mật mã Chính phủ Anh
Đại học Cambridge","nhà toán học, nhà logic, nhà phân tích mật mã học, nhà khoa học máy tính",Anh,
turing,Entity,,,alan,,turing,,,,,,,
