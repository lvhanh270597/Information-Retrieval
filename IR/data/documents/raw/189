Phân tích ra thừa số -- Integer factorization
http://www.giaithuatlaptrinh.com/?p=341
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Bài toán phân tích một số nguyên thành tích của các thừa số nguyên tố là một bài toán khó (nằm trong lớp các bài tóan ). Hiện tai, chưa có thuật toán thời gian đa thức (polynomial time) nào có thể giải được bài toán này (nếu có thì toàn bộ các hệ thống bảo mật hiện tại sẽ đổ vỡ). Tuy nhiên, điều đó không có nghĩa là chúng ta hoàn toàn không giải được. Trong phần này, chúng ta sẽ thảo luận một số thuật toán (thời gian lũy thừa) để giải bài toán này, qua đó có một cái nhìn sâu hơn về bài toán. 
Chú ý: theo định lý cơ bản của số học (), phép phân tích  với  là duy nhất.Ý tưởng cơ bản nhất để giải quyết bài toán này là duyệt dãy số nguyên tố:  để tìm ước nguyên tố của . Thông thường, sinh dãy số nguyên tố như vậy có thể rất tốn kém (phương pháp thường dùng là sử dụng  tốn khá nhiều bộ nhớ). Do đó, ta sẽ duyệt qua một dãy  dễ sinh hơn dãy  sao cho  ( có thể chứa hợp số). Donald Knuth [1, p.364] đề xuất sử dụng dãy:  Ngoại trừ 2 số đầu tiên, dãy  có khoảng cách giữa hai số kề nhau thay đổi liên tục giữa  và . Giả mã như sau: 
Mặc dù  có thể chứa hợp số, ta có thể dễ dàng chứng minh (coi như bài tập cho bạn) các số  đầu ra của thuật toán luôn là các số nguyên tố và có giá trị tăng dần. Từ giả mã trên ta thấy số lần lặp của vòng lặp  chính bằng số phần tử  của dãy . Hơn nữa, dãy  càng gần dãy  thì số lần lặp càng ít. Trong trường hợp dãy  như đề xuất , số lần lặp xấp xỉ bằng . Trường hợp , số phần tử của  chính là số lượng các số nguyên tố . Gọi  là số các số nguyên tố nhỏ hơn hoặc bằng . Định lý sau cho chúng ta biết giá trị tiệm cận của :   Do đó, theo prime number theorem, số lần lặp của vòng  trong trường hợp  là , tốt hơn đề xuất   lần. Với số nguyên  là rất lớn, sự khác nhau này thực sự không nhiều. Chúng ta có thể cải tiến thuật toán dựa trên nhận xét sau: Nếu  không phải số nguyên tố thì . Do đó, trong vòng lặp  ở trên, ta chỉ việc thêm thủ tục kiểm tra tính nguyên tố của  (sử dụng thuật toán ) và thay điều kiện  bằng . Giả mã của thuật toán như sau: 
Code của giả mã bằng C (code đầy đủ được đính kèm ở cuối bài): Nhắc lại:  là ước số nguyên tố lớn thứ 2 của . Vòng lặp  ít nhất phải duyệt đến phần tử thứ  của mảng  sao cho . Sau khi đã duyệt và in ra , , do đó, thủ tục kiểm tra tính nguyên tố ở dòng  sẽ in ra  và thuật toán kết thúc. Từ đó suy ra số lần lặp xấp xỉ là . Do , số lần lặp là .



Ta sẽ tính tổng số phép kiểm tra tính nguyên tố (mỗi phép kiểm tra sử dụng  thao tác bít). Thủ tục kiểm tra tính nguyên tố sẽ được gọi mỗi lần tìm thấy một ước số của . Do đó, tổng số phép kiểm tra tính nguyên tố xấp xỉ . Ta có:  Từ đó suy ra tổng số phép kiểm tra nguyên tố là .Tương tự như vậy, tổng số phép tính  xấp xỉ là . Mỗi phép khai căn  có thể được thực hiện sử dụng  thao tác bít. Do đó, tổng thời gian cho phép khai căn là .Như vậy, tổng thời gian của thuật toán là  trong đó nhân tử  là thời gian để thực hiện một phép cộng hoặc đồng dư  bít.   Code: , . [1] Knuth, Donald E.  Seminumerical Algorithms (1981).
[2] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 31. MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7
[3] Pollard, John M.  BIT Numerical Mathematics 15.3 (1975): 331-334. , , Trackback link: Powered by  and 