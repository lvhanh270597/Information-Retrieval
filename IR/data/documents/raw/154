Cơ sở toán học của phép băm I: hàm băm-- Mathematical foundation of hashing I
http://www.giaithuatlaptrinh.com/?p=980
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Hàm băm có rất nhiều loại và rất nhiều ứng dụng khác nhau (xem ), do đó, chúng ta sẽ không có đủ thời gian để thảo luận hết được. Hàm băm trong bài này chúng ta thảo luận đó là hàm băm sử dụng để . Hai yêu cầu chính trong thiết kế hàm băm: Ta sẽ nhắc lại một số khái niệm cơ bản trong thiết kế bảng băm. Kí hiệu bảng băm với dung lượng  là . Ta thực hiện băm  phần tử từ một tập gốc  có kích thước  lớn hơn nhiều so với . Cho trước hàm băm , hai khóa  mà  được gọi là  nếu . Một hàm băm  được gọi là  nếu:  Số 2 ở đây không phải là số đặc biệt. Bất kì hằng số nào khác 2 đều có thể chấp nhận được trong định nghĩa ở trên. Về mặt trực quan, hàm băm tốt là hàm băm có xác suất đụng độ nhỏ.Trước khi nói kĩ hơn về hàm băm, có một vấn đề mà bài trước chúng ta chưa đụng đến: cái gì có thể băm được. Dường như chúng ta đang mặc định khóa của chúng ta là các số nguyên. Nếu khóa không phải là số nguyên (ví dụ xâu kí tự) thì ta cần một cơ chế để chuyển về số nguyên trước khi băm. Ta gọi số nguyên đó là mã băm (hashcode), Phần này ta sẽ tìm cơ chế tìm mã băm cho xâu kí tự. Các dạng dữ liệu cơ bản khác đều có thể quy về xâu (ví dụ số 0.12345 có thể coi như là xâu "0.12345"). Thiết kế cơ chế tìm mã băm có thể quy về tìm một hàm  sao cho với mỗi xâu ,  là một số nguyên. Hàm  phải có tính chất nếu đầu vào là hai xâu khác nhau thì đầu ra phải là hai mã băm khác nhau vì nếu nhiều xâu có cùng mã băm thì bất kể hàm băm  chọn thế nào thì số lượng đụng độ cũng rất lớn. Nếu coi  là một hàm băm thì hình như ta lại quay trở lại vấn đề ban đầu: tìm hàm băm có xác suất đụng độ nhỏ và có thể tính được một cách hiệu quả.  May mắn thay, khác biệt cơ bản trong thiết kế hàm băm  so với  khiến cho thiết kế  dễ hơn rất nhiều đó là: không gian mã của  có thể lớn hơn rất nhiều . Ví dụ bảng băm có kích thước ,  chỉ được phép băm một khóa vào một trong các giá trị  ( giá trị khác nhau) còn  có thể băm một khóa vào một trong các giá trị  ( giá trị khác nhau) nếu đầu ra của  là một số nguyên không dấu 64 bít. Coi số thứ tự trong hệ ASCII mỗi kí tự là một chữ số trong hệ cơ số 256. Ví dụ kí tự 'A' tương ứng với chữ số 65 (65 là mã ASCII của A). Một họ hàm băm khá phổ biến thường dùng để thiết kế  đó là  (polynomial hashing):   Nếu chọn  thì  sẽ duy nhất với mọi , i.e, . Tuy nhiên,  càng lớn thì  sẽ càng lớn. Do đó, thông thường người ta sẽ chọn  là một số nguyên tố không quá lớn. Ngôn ngữ  mặc định chọn  để tính . Một điểm mạnh của băm đa thức đó là nó có thể tính được hiệu quả bằng .   Mình sẽ không đi sâu thêm vào các hàm băm kiểu này nữa. Một số hàm băm khác bạn đọc có thể tham khảo thêm tại . Hai điểu mà mình muốn nhấn mạnh trong phần này đó là:Như đã nói trong bài trước, một hàm băm tốt không thể là một hàm băm tất định (deterministic) được vì theo , ít nhất  phần tử sẽ có cùng mã băm. Một hàm băm tốt thường sẽ được chọn ngẫu nhiên (trước khi băm) từ một họ các hàm băm được thiết kế sẵn. Trong phần này mình đi sâu hơn vào hai họ hàm băm đã giới thiệu ở bài trước: (multiplicative hashing): Họ hàm băm nhân được Carter và Wegman [5] giới thiệu năm 1977. Ta chọn một số nguyên tố  lớn hơn  và định định nghĩa:  Họ  được gọi là họ hàm băm nhân. Ta sẽ chứng minh nếu chọn ngẫu nhiên một hàm băm  từ họ  thì xác suất đụng độ là nhỏ. 
 Kí hiệu  là ước chung lớn nhất của hai số  và . Do  là một số nguyên tố, . Theo thuật toán Euclidean , tồn tại duy nhất hai số nguyên dương  (modulo ) sao cho:  Do đó, , dpcmGiả sử ta chọn ngẫu nhiên . Đụng độ sẽ xảy ra khi và chỉ khi tồn tại hai khóa  sao cho:  Ở đây  có thể nhận một trong các giá trị  vì . Mỗi giá trị của  sẽ tương ứng với một giá trị của . Do đó, đụng độ chỉ xảy ra khi  nhận một trong  giá trị thỏa mãn . Do ta chọn   chọn ngẫu nhiên trong  và  là hai khóa cho trước, xác suất ta chọn được  như vậy là:   Họ hàm băm nhân này được giới thiệu bởi Martin, Hagerup, Katajainen và Penttonen [6] năm 1977 để giải quyết bài toán cặp điểm gần nhất (closest pair). Ưu điểm của họ hàm băm này so với họ hàm băm nhân ở trên là: không cần đến số nguyên tố lớn và mã bă có thể tính được chỉ sử dụng các thao tác bít đơn giản.Gọi  là số nguyên dương nhỏ nhất sao cho  . Chọn . Với mỗi số nguyên dương   không lớn quá , ta định nghĩa: 
 Họ hàm băm ta xây dựng là . Chứng minh xác suất đụng độ là nhỏ nếu ta chọn ngẫu nhiên một hàm băm  từ  phức tạp hơn so với chứng minh ở trên một chút. Trước hết ta sẽ chứng minh:   trong đó  là một số nguyên lẻ.
 
 Giả sử , ta suy ra . Do  lẻ và , đẳng thức chỉ xảy ra khi . Điều này trái với giả thiết , dpcm.Về mặt trực quan, Lemma 2 cho chúng ta biết hàm  với  cho trước là một đơn ánh (injective map) từ tập  vào chính nó. Do miền xác định và miền giá trị bằng nhau, ta suy ra hàm  là một song ánh (bijective map). Ý nghĩa của tính chất này đó là với một khóa  cố định, việc chọn  ngẫu nhiên tương đương với việc chọn  ngẫu nhiên trong tập . Ta sẽ sử dụng tính chất này để chứng minh xác suất đụng độ của  là nhỏ.Theo hình minh họa ở trên, mã băm đầu sẽ là  bít cao nhất của . Nhắc lại . Giả sử xảy ra đụng độ giữa hai khóa . Không mất tính tổng quát, ta giả sử  > . Ta có  khi và chỉ khi  bít cao nhất của  và  là giống nhau. Từ đó ta suy ra  bít cao nhất của  phải là một dãy  số  hoặc một dãy  số . Ta có:  Với  cho trước, theo nhận xét ở đoạn trước, việc chọn  ngẫu nhiên tương đương với chọn  ngẫu nhiên trong . Do đó, xác suất ta chọn được ngẫu nhiên một số  bít có  bít cao nhất là toàn  hoặc toàn  là . Nhắc lại . Như vậy:  [1] Donald E. Knuth. , Volume 3: (2nd Ed.) Sorting and Searching. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA, 1998.
[2] Jeff Erickson. . UIUC, 2013.
[3] Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.   (2nd ed.). Chapter 12. McGraw-Hill Higher Education, 2001.
[4] Procul.org: , accessed 20/04/2016.
[5] J.L. Carter and M.N. Wegman. 1977. . In STOC' 77, 106-112.
[6] D. Martin, T. Hagerup, J. Katajainen, and M. Penttonen.  Journal of Algorithms 25, No. 1 (1997): 19-51. , , , , Trackback link: Powered by  and 