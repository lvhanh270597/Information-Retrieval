Các kĩ thuật xử lí bít I-- Bitwise tricks I
http://www.giaithuatlaptrinh.com/?p=515
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Như Donald Knuth [2] đã nói, thao tác với bít là "một thành phần không thể thiếu trong toolkit của các lập trình viên tốt". Trong bài này chúng ta sẽ tìm hiểu tại sao thao tác với bít lại quan trong như vậy. Sử dụng thao tác bít, chúng ta có thể thực hiện nhiều thứ rất "ảo" bằng một vài câu lệnh đơn giản.Xét một ví dụ "đơn giản" sau: cho một số nguyên 64 bít không dấu , kiểm tra xem  có phải là một lũy thừa của 2 hay không, i.e, kiểm tra xem có tồn tại một số  sao cho ? Có lẽ một số trong chúng ta sẽ tiếp cận như sau: với mỗi , ta tính  và so sánh với : 
Tất nhiên bạn có thể thêm một vài heuristic để thuật toán nhanh hơn, còn về mặt ý tưởng thì là như vậy. Tuy nhiên,  nếu bạn biết xử lí bít thì hàm trên có thể được thực hiện nhanh và ngắn gọn như sau: 
Code C:Trong đó  là phép AND. Hi vọng ví dụ trên đủ để thuyết phục bạn rằng nắm chắc các kĩ thuật xử lí bít là một điều không thể thiếu trong các kĩ năng của bạn. Trong các phần tiếp theo chúng ta sẽ tìm hiểu tại sao thuật toán  là đúng. Ta sẽ kí hiệu số nguyên có dấu là  và số nguyên không dấu là  trong đó  là số bít. Ví dụ số nguyên 64 bít không dấu là  và số nguyên 32 bít có dấu là .   Các thao tác bít cơ bản và kí hiệu toán học dùng trong các bài viết này được cho bởi bảng dưới: Các ngôn ngữ lập trình thường cung cấp 2 phép SHIFT RIGHT là LOGICAL SHIFT RIGHT  và ARITHMETIC SHIFT RIGHT. Sự khác nhau nằm ở chỗ bít dấu sẽ được shift như thế nào. Trong LOGICAL SHIFT RIGHT, kí hiệu , bít dấu không được giữ nguyên khi shift Trong ARITHMETIC SHIFT RIGHT, kí hiệu , bít dấu sẽ được shift lan về bên phải khi shift. Hai ví dụ cuối cùng trong bảng trên của hàng SHIFT RIGHT minh họa cho sự khác nhau này. Nếu số được shift là số không dấu thì ARITHMETIC SHIFT RIGHT và LOGICAL SHIFT RIGHT là như nhau.  Một số ngôn ngữ có hai phép SHIFT LEFT là ARITHMETIC SHIFT LEFT và LOGICAL SHIFT LEFT. Tuy nhiên trong khuôn khổ những bài viết ở đây, ta chỉ xét LOGICAL SHIFT LEFT mà ta gọi là SHIFT LEFT cho ngắn gọn. Một trong những điều chúng ta phải hết sức chú ý đó là  của các thao tác. Thứ tự thông thường như sau: NOT > nhân, chia > cộng, trừ > SHIFT LEFT, SHIFT RIGHT > AND > XOR > OR Một số tính chất của các thao tác như sau: 
 Các tính chất  không quá khó để chứng minh. Do các thao tác áp dụng kiểu bitwise (không có nhớ), để chứng minh, ta chỉ cần kiểm tra các thao tác trên đúng với trường hợp  chỉ có 1 bít. Chi tiết coi như bài tập cho bạn đọc. Chú ý  có biểu diễn nhị phân là  (chỉ gồm các bít 1). Tính chất  ( không dấu) được suy ra từ định nghĩa của các phép shift.Ta dễ thấy: , từ đó suy ra:  Thay  bởi , ta cũng suy ra:  Kết hơp  ta có . Bằng phép quy nạp, ta suy ra: Trong các ví dụ dưới đây, các giá trị boolean TRUE/FALSE sẽ được coi là các giá trị .Cho hai số nguyên  kiểu , trả về  nếu  khác dấu và 0 nếu ngược lại. Các thủ tục dưới đây thực hiện hàm này. Tính đúng đắn coi như bài tập cho bạn đọc.  Code C:Tính giá trị tuyệt đối của số nguyên  có độ dài  bít:   
Code C:Chứng minh  trả lại giá trị tuyệt đối của  coi như bài tập cho bạn đọc. Ta sẽ chứng minh thủ tục   là đúng:Chứng minh  đúng tương tự như chứng minh  đúng. Chi tiết coi như bài tập cho bạn đọc. Giả sử ta có một số nguyên có dấu  độ dài  bít, ta muốn mở rộng bít thứ  của  ra thành bít dấu:Ví dụ , giá trị sau khi mở rộng là . Ví dụ khác, , giá trị sau khi mở rộng là .  Ta có thể làm như sau:   Code C:Ta sẽ chứng minh  đúng. Các thủ tục khác chứng minh tương tự. Gọi  với  và . Ta cần chứng minh thủ tục sẽ trả về  nếu  và  nếu .Thật vậy, sau khi đã xóa  bít đầu tiên (lệnh ), ta có . Nếu , ta suy ra  và thủ tục sẽ trả lại . Nếu , ta có  và . Do đó, thủ tục trả lại . Một trong những thủ tục trong các thuật toán sắp xếp là đổi chỗ hai biến. Thông thường, ta sẽ dùng một biến trung gian để lưu một trong hai giá trị trong quá trình đổi chỗ. Nếu hai biến cần đổi chỗ là các số nguyên ta không cần phải sử dụng biến trung gian đó.   
Code C:Chứng minh tính đúng đắn coi như bài tập cho bạn đọc.Cho hai giá trị nguyên , tìm giá trị lớn nhất, nhỏ nhất của hai số .  
Code C:Tính đúng đắn coi như bài tập cho bạn đọc. Thủ tục tính max tương tự như tính min. Chi tiết coi như bài tập cho bạn đọc.  Giả sử ta có một số nguyên có dấu  và một biến . Nếu  thì ta phải đổi dấu của . Nếu  ta giữ nguyên giá trị .  
Code C:Ta chứng minh  đúng. Nếu , dễ dàng kiểm tra được thủ tục trả lại giá trị . Nếu , ta có: Tương tự như vậy, ta có thể chứng minh được  đúng. Trong phần này, giả sử số nguyên  có biểu diễn nhị phân như sau:  trong đó  có thể bằng . Ta dễ dàng suy ra:  Từ đó suy ra . Ta lại thu được các đẳng thức ở trên.Một số thao tác với bít 1 tận cùng bên phải quan trọng nên nhớ:  Các mặt nạ "thần kì" (magic mask) được sử dụng rất rất nhiều trong các thủ tục thao tác bít. Các mặt nạ thần kì được định nghĩa như sau:  Về mặt toán học,  là khai triển nhị phân của  do   Ở đây, bạn đọc chỉ cần nhớ  gồm mỗi dãy lặp lại  số  liên tiếp sau đó là  số 1 liên tiếp.   Thủ tục  ở trên kiểm tra xem có tồn tại  sao cho  hay không? Dễ thấy, nếu  thì  có đúng 1 bít 1. Theo ,  sẽ xóa bít 1 tận cùng bên phải. Do đó,  trả về 0 khi và chỉ khi  và   với một số  nào đó.
Cho một số nguyên  (không dấu), đếm số bít  của . Ta có thể thực hiện sử dụng  thao tác bít trong đó  là số bít biểu diễn của  như sau: 
Code C:Sử dụng thuật toán trên trong trường hợp  có  bít cần khoảng  phép tính. Để tăng tốc thuật toán, ta sẽ sử dụng một bảng , gọi là bảng nhớ, để tính trước. Giả sử ta có bảng  trong đó   nếu trong biểu diễn nhịn phân cuả  có  bít 1. Nếu bảng  đã được tính sẵn, ta có thể đếm số bít 1 của  trong 11 phép tính như sau: 
Code C:Trong trường hợp số lượng bít 1 của  không nhiều, ta có thể sử dụng . Cụ thể, nếu  có  bít 1 thì ta chỉ cần  phép tính.  Code C:Chứng minh thủ tục  đúng coi như bài tập cho bạn đọc. Cho một số nguyên , gọi  là  số lượng bít 0 cuối cùng (trailing zeros) của . Tính . Ví dụ , ta có . Dễ thấy nếu  lẻ thì . Ta có công thức đệ quy sau của :  Trong đó  là số bít biểu diễn của . Cách đầu tiên ta có thể nghĩ đến là duyệt các bít của  từ trái sang phải để đếm số lượng bít 0 cho đến khi ta bắt gắp bít 1 đầu tiên thì dừng. Cách này cần khoảng  phép tính trong đó  là số lượng bít 0 cuối cùng. Trong trường hợp tồi nhất, đếm số bít 0 cuối cùng cuả số nguyên không dấu 32 bít cần hơn 150 phép tính. Có thể tăng tốc thuật toán này bằng cách sử dụng bảng nhớ như trên. Cách khác ta có thể nghĩ tới là sử dụng chia để trị để tìm bít 1 phải nhất. Cách này áp dụng cho mọi số nguyên 32 bít sử dụng 19 phép tính. 
Code C:Tính đúng đắn coi như bài tập cho bạn đọc. Ngoài ra ta có thể sử dụng mặt nạ thần kì để tính . Nhận thấy nếu  với một số  nào đó thì:  trong đó hàm  nếu  là TRUE và  nếu ngược lại. Do đó, để áp dụng , ta sẽ áp dụng  trước để xóa hết các bít 1 bên trái của bít 1 cuối cùng. Nếp áp dụng phương pháp này cho số nguyên có  bít thì mất cỡ 16 phép tính. Giả mã như sau: Code C:Cho số nguyên , ví dụ  bít , đảo ngược biểu diễn nhị phân của , i.e, trả lại . Cách đơn giản nhất là copy các bít của  sang một số  theo thứ tự đảo ngược. Cách này mất  phép tính trong đó  là vị trí của bít 1 tận cùng bên trái của . Do đó, khi áp dụng cho số 32 bít, trong trường hợp xấu nhất, tổng số thao tác ta cần sử dụng là hơn 180 phép tính.    
Code C:Trong bài toàn này ta cũng có thể áp dụng chia để trị. Ví dụ với  có 8 bít như trên, ta có thể đảo ngược các bít của  trong 3 bước như sau:  Để thực hiện bước 1, ta sẽ làm như sau:  Tương tự như vậy các bước tiếp theo ta thực hiện với mặt nạ thần kì . Giả mã với  là số nguyên 32 bít không dấu như sau: Code C:Dễ thấy sử dụng các mặt nạ thần kì, ta có thể đảo bít số nguyên 32 bít trong  phép tính và số nguyên 64 bít trong 26 phép tính. Chứng minh tính đúng đắn của thủ tục trên coi như bài tập cho bạn đọc. Trong ví dụ tiếp theo, ta sẽ áp dụng phương pháp đổi chỗ hai bít để đảo bít số nguyên 64 bít sử dụng 26 phép tính.Cho số nguyên không dấu , đổi chỗ hai bít  và  của  ( < ). Đặt , ta tiến hành đổi chỗ như sau:  
Code C:Trong giả mã trên, bước đầu tiên, ta tách  ra khỏi  và đặt vào vị trí thứ . Sau đó, ta tách  ra khỏi  và đặt vào bít thứ . Mặt nạ  ở trên có tất cả các bít là 1 ngoại trừ bít thứ  và . Suy ra,  sẽ thiết lập bít  và  về 0. Như vậy, kết quả cuối cùng sẽ là . Chú ý trong ví dụ đổi chỗ hai số nguyên không dùng biến thứ 3, ta sử dụng phép XOR. Ở bài toán này, ta có thể thực hiện ý tưởng tương tự.  
Code C:Đầu tiên ta tính  và đưa kết qủa vào vị trí thứ . sau đó đổi  thành  và  thành . Dễ thấy cách này sử dụng ít thao tác bít hơn cách ở trên.  Ý tưởng của thuật toán  còn có thể được dùng để đổi chỗ vài cặp bít cùng một lúc (giống như cách chúng ta đảo bít ở trên). Thông thường, để thực hiện đảo nhiều cặp bít, ta sẽ dùng mặt nạ  thay vì  như trên.  Ta sẽ gọi thủ tục này là -swap. Sử dụng -swap, ta có thể thực hiện đảo bít số nguyên 64 bít không dấu trong 26 phép tính (thay vì 28) như sau: Chi tiết chứng minh tính đúng đắn của thuật toán trên coi như bài tập cho bạn đọc.Code: [1] Donald E. Knuth. . Addison-Wesley Professional, 2009.
[2] 
[3] Warren, Henry S. . Pearson Education, 2012. , , Powered by  and 