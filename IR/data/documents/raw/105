Cây nhị phân cân bằng --- Balanced binary search tree
http://www.giaithuatlaptrinh.com/?p=1954
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Xét bài toán sau: 
Có 2 cách mà ta nghĩ đến ngay: (i) dùng mảng để biểu diễn  hoặc (ii) dùng . Cách (ii) có lẽ không phù hợp vì thao tác Access(, k) mất thời gian  nếu như  có  phần tử. Với cách (i), ta có thể giải quyết thao tác Access(, k) bằng cách duy trì một mảng đã sắp xếp và sử dụng . Tuy nhiên, ta lại gặp vấn đề với hai thao tác sau.Trong bài này, ta sẽ tìm hiểu cấu trúc cây nhị phân tìm kiếm cân bằng (blanched binary search tree) để biểu diễn . Với cấu trúc này, ta có thể thực hiện mỗi thao tác trên trong thời gian . Cây có thể coi là một đồ thị đơn không có chu trình. Ta thường chỉ định một nút đặc biệt trong cây, kí hiệu , mà ta gọi là  của cây. Các nút có bậc 1 (chỉ kề với một cạnh) trong cây, ngoại trừ nút gốc, được gọi là các nút lá (leaf node). Nút không phải là nút lá ta gọi là  của cây (internal node). Với mỗi cạnh  nối hai nút  và , nút nào gần gốc hơn thì ta gọi nút đó là  của nút còn lại. Ta dùng  để kí hiệu nút cha của một nút . CHú ý, gốc  không có nút cha và ta gán . Ta gọi  là nút con của nút .Một cây được gọi là  nếu với mỗi nút trong có  hai nút con. Thông thường ta biểu diễn một cây nhị phân như Figure 1(a). Cây trong khoa học máy tính thường được biểu diễn ngược với cây trong tự nhiên; gốc ở trên còn lá ở dưới. Đôi khi, ta định hướng cạnh từ nút cha tới nút con (hoặc ngược lại) để quan hệ cha-con trực quan hơn. Từ đây về cuối bài, ta sử dụng khái niệm cây để ám chỉ cây nhị phân, vì ta chỉ tìm hiểu cây nhị phân trong bài này. Ta sử dụng cây để tổ chức dữ liệu bằng cách chèn các phần tử dữ liệu vào mỗi nút của cây và mỗi nút của cây được gán một khóa. Khóa không nhất thiết phải khác nhau, tuy nhiên, để trình bày đơn giản, ta sẽ giả sử khóa của các nút đôi một khác nhau. Để hỗ trợ tìm kiếm, ta thường tổ chức dữ liệu trên cây sao cho khóa của của nút cha lớn hơn khóa của nút con trái và nhỏ hơn khóa của nút con phải.  Ta gọi tính chất này là tính chất  và gọi cây nhị phân như vậy là . Figure 1(b) minh họa một cây nhị phân tìm kiếm.

 (a) một cây nhị phân và (b) một cây nhị phân tìm kiếm: Nhắc lại, ta sẽ dùng  để kí hiệu nút cha của  trong cây . Ta dùng  và  lần lượt để kí hiệu nút con trái và nút con phải của nút . Các giá trị này sẽ là  nếu  không có con trái (hoặc con phải). Ta sử dụng  để kí hiệu khóa của nút .  Khi lập trình, ta có thể lưu con trỏ  cho mỗi nút . Tuy nhiên, đa phần các cấu trúc cây nhị phân không cần đến trường này mà ta chỉ lưu con trỏ của 2 nút con  và . Việc tiết kiệm con trỏ  không chỉ vấn đề bộ nhớ, mà còn tiết kiệm được cả thời gian (cập nhật con trỏ này). Trong bài này, mình sẽ không sử dụng con trỏ  trong giả mã mà chỉ dùng nó như một kí hiệu tới nút cha (trong chứng minh).Giả sử ta đã có một cây nhị phân tìm kiếm  để biểu diễn , với khóa của mỗi nút là một số nguyên trong . Sử dụng tính chất tìm kiếm (quan hệ giữa khóa của cha và hai nút con), Ta có thể thực hiện tìm kiếm như sau: Tạm thời gác lại hai thao tác chèn và xóa. Liệu thao tác Access(, k) với biểu diễn cây nhị phân tìm kiếm như trên có hiệu quả? Figure 2 cho ta câu trả lời là không. Trong trường hợp xấu nhất, ta phải trả thời gian  để tìm kiếm một nút lá của cây nếu như cấu trúc cây trong giống một đường đi đơn (path) như Figure 2.
 Một cây nhị phân tìm kiếm với độ sâu 4. Ta có thể mở rộng ra cây nhị phân tìm kiếm có độ sâu .Do đó, ta cần một cách tổ chức cây sao cho đường đi từ gốc của cây đến một nút lá bất kì đều không quá dài, i.e, . Từ đó ta có khái niệm cây cân bằng, là cây có độ sâu (depth) không quá lớn. Ta định nghĩa  của một nút , kí hiệu , là độ dài là độ dài (số cạnh) trên đường đi (duy nhât) từ gốc  đến nút .  của cây, kí hiệu , được định nghĩa là độ sâu lớn nhất trong số các nút lá của cây.    Theo định  nghĩa, độ sâu của nút gốc  là .Một khái niệm tương tự độ sâu là  (height). Chiều cao của mọi nút lá là  và chiều cao của một nút trong  được định nghĩa từ nút con của nó như sau:  Chiều cao của cây, kí hiệu , được định nghĩa là chiều cao của nút gốc. Từ định nghĩa của chiều cao và độ sâu, ta suy ra:   Bạn đọc cần phân biệt rõ hai khái niệm chiều cao và độ sâu. Độ sâu được định nghĩa từ gốc xuống lá còn chiều cao được định  nghĩa từ lá lên gốc. : Để dễ dàng trong việc phân tích cấu trúc cây, ta sẽ giả mọi nút có chứa dữ liệu (kể cả lá) có  hai nút con. Điều này có thể được đảm bảo bằng cách thêm 2 nút  vào mỗi nút lá, và thêm 1 nút  vào mỗi nút trong nếu nút trong đó có đúng 1 nút con. Xem minh họa trong Figure 3(a). Theo quy ước trên, mọi nút lá của cây là . Có nhiều cách để định nghĩa cây cân bằng: cân bằng theo chiều cao, cân bằng theo trọng số, cân bằng theo hạng (rank),   nhưng mục tiêu chung là đảm bảo độ sâu của cây là . Mỗi cách định nghĩa cân bằng thường tương ứng với một cách thực thi riêng. Tìm một cách định nghĩa cân bằng để cân bằng giữa các yếu tố: độ sâu, bộ nhớ và tính đơn giản trong thực thi, vẫn đang là một chủ đề nghiên cứu hiện nay. Dưới đây mình giới thiệu loại cây cân bằng phổ biến: cây AVL và cây đỏ-đen (red-black tree).  được phát triển bởi Adelson-Velsky và Landis [2], sử dụng chiều cao (height) làm tiêu chuẩn cân bằng.    
Trong bài sau ta sẽ tìm hiểu cách thức thực thi để đảm bảo tính chấ ttrong phương trình . Một số tính chất của cây AVL ta sẽ nghiên cứu ở đây. Đầu tiên là chiều cao của cây AVL. Theo quy ước, mọi nút lá là   (và có chiều cao 0). Do đó, mọi nút trong đều có chiều cao dương.   Với ,  và .
 
 Bằng quy nạp (chi tiế tcoi như bài tập cho bạn đọc), ta có thể chứng minh được một cây AVL chiều cao  có không quá  nút trong. Từ đó ta suy ra cận dưới. Để chứng minh cận trên, ta cần phải xét xem một cây AVL chiều cao  có  bao nhiêu nút trong. Phương pháp chứng minh dưới đây được đề xuất bởi Knuth [3] (trang 453).Gọi  là cây AVL chiều cao  có số nút trong ít nhất trong số các cây AVL chiều cao . Gọi  là số nút của . Theo , ta có thể giả sử cây con trái của gốc  có chiều cao  và cây con phải của gốc  có chiều cao  (tại sao ta có thể giả sử như vậy?). Từ đó ta có công thức truy hồi:  và . Nếu đặt , ta có   và . Đây chính là , kí hiệu , dịch sang trái 1 đơn vị. Do đó:  Bằng một vài biến đổi đại số nhỏ, ta sẽ có dpcm.Trong thực thi cây AVL, chúng ta cần một trường (một số nguyên) để lưu trữ chiều cao của mỗi nút (khoảng 8 bít là đủ). Tùy vào ứng dụng mà số lượng bít này có thể coi là nhiều hay ít. Trong cây đỏ-đen dưới đây, mỗi nút chỉ cần đúng 1 bít để duy trì thông tin cân bằng. Do đó, so với cây AVL, cây đỏ-đen tiết kiệm được nhiều bộ nhớ lưu trữ hơn.Cây đỏ-đen được Guibas và Sedgewick [4] giới thiệu năm 1978. Trước hết ta định nghĩa cây đỏ-đen thông qua hạng (rank). Cách định nghĩa này, tuy chả liên quan gì đến cái tên đỏ-đen, nhưng cho phép chứng minh một số tính chất về chiều cao trở nên đơn giản hơn (sử dụng quy nạp là đủ). Sau đó ta sẽ liên hệ rank và màu sắc của nút.Một cây nhị phân tìm kiếm được gọi là cây đỏ-đen nếu tồn tại một hàm  gán cho mỗi nút của cây một số nguyên không âm sao cho với mọi nút :Ví dụ một cách gán  cho mỗi nút của cây ở Figure 1(b) được minh họa trong Figure 3(b) 
 (a) Cây nhị phân thu được sau khi thêm các nút  vào cây nhị phân trong Figure 1(b) để thu được cây theo quy ước. (b) Cây nhị phân với hàm . Số màu đỏ của mỗi nút tương ứng với rank của nút đó.  Chứng minh rằng không tồn tại hàm  với 3 tính chất kể trên cho cây trong Figure 3(a).Chú ý, theo quy ước, các nút lá  sẽ có rank 0. Việc kiểm tra hàm  gán như trên thỏa mãn 3 tính chất coi như bài tập cho bạn đọc.  Từ tính chất của rank, ta suy ra các tính chất (tương đương) sau của màu sắc (xem minh họa trong Figure 4.):
 Một cây đỏ đen được chuyển đổi từ cây nhị phân với hàm rank trong Figure 3b. Số màu đỏ trên mỗi nút là rank của nút đó.Ngược lại, từ một cây đỏ-đen với màu sắc của mỗi nút, ta có thể suy ngược lại hàm rank bằng cách gán cho các nút lá rank 0 và rank của các nút trong khác được suy ra (bằng quy nạp) từ màu sắc và rank của các nút con của nó. Chi tiết coi như bài tập cho bạn đọc.Tính chất màu sắc của cây đỏ đen cho phép ta chỉ dùng 1 bít để lưu trữ màu sắc tại mỗi nút, thay vì một số nguyên để lưu trữ giá trị height như trong cây AVL tree. Cách lưu trữ này tiết kiệm được rất nhiều bộ nhớ. Cấu trúc  trong Java chính là sử dụng cây đỏ-đen.  
 Ta chứng minh bằng phương pháp quy nạp. Dễ thấy Theorem 1 đúng cho các nút lá (có rank 0 và height 0). Với nút  có , theo (2),  nút con  của  có  hoặc . Phần còn lại của chứng minh ta sẽ xét các trường hợp, và chi tiết coi như bài tập cho bạn đọc.Áp dụng Theorem 2 cho nút gốc , ta suy ra nút gốc có chiều cao không quá  và ít nhất  nút con cháu. Do cây có tối đa  nút trong, nó có không quá  nút (tính cả các nút lá), ta suy ra:  Chứng minh chặt chẽ hơn ta có thể suy ra độ cao của cây là không quá . Logarithm ở đây là base 2. So với cậy AVL, chiều cao của cây đỏ-đen nói chung là lớn hơn (xem lại Theorem 1). Tuy nhiên, cây AVL sử dụng nhiều bộ nhớ hơn. Trong bài sau ta sẽ thấy, thực thi cây đỏ-đen phức tạp hơn thực thi cây AVL rất nhiều.[1] R. E. Tarjan. . Society for Industrial and Applied Mathematics, 1983.
[2] G. Adelson-Velsky and E. Landis. . Proceedings of the USSR Academy of Sciences (in Russian). 146: 263–266. English translation by Myron J. Ricci in Soviet Math. Doklady, 3:1259–1263, 1962.
[3] D. Knuth. . Addison-Wesley, 1997.
[4] L. J. Guibas and R. Sedgewick. . Proceedings of the 19th Annual Symposium on Foundations of Computer Science. pp. 8–21. 1978. , , , , , Trackback link:  on                     Em chào anh, ở phần đặt vấn đề( Problem 1) thì dùng HashMap được không ạ? Em nghĩ 3 thao thác tìm kiếm, thêm, xóa thực hiện trên HashMap đều hiệu quả. on                     Hi bạn.
Great question! Vấn đề của một (standard) Hashmap là bạn phải khởi tạo một map với N phần tử và sau đó không được phép thêm vào. Về mặt kĩ thuật, bạn có thể thêm vào Hashmap sau đó, nhưng bạn sẽ không đạt được thời gian O(1) như mong muốn nữa. Do đó, Hashmap chỉ phù hợp cho các bài toán mà Access là thao tác chủ yếu, còn delete và update là các thao tác ít khi xảy ra. Nếu cả 3 thao tác này xảy ra thường xuyên thì cây cân bằng là một cấu trúc phù hợp hơn!HùngPowered by  and 