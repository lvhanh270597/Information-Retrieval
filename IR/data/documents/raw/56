Giới thiệu về P và NP --- P vs NP
http://www.giaithuatlaptrinh.com/?p=1719
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Qua các bài viết trong blog, chúng ta đã thấy rất nhiều các bài toán được giải quyết một cách hiệu quả. Ví dụ như bài toán sắp xếp, bài toán tìm kiếm xâu, bài toán tìm đường đi ngắn nhất, tìm cây khung nhỏ nhất, bài toán luồng cực đại, bài toán lát cắt cực tiểu, v.v và v.v. Tất cả các bài toán này đều được giải trong thời gian  với một hằng số  nào đó và  là chiều dài của đầu vào bài toán. Ngược lại,  các bài toán chúng ta gặp trong thực tế là những bài toán mà  chúng ta  làm sao để giải chúng một cách hiệu quả. Mình nhấn mạnh hai từ "hiện tại" và "không biết" ý nói  những bài toán đó có lời giải hiệu quả, chỉ là chúng ta chưa tìm ra được lời giải. Tuy nhiên, rất nhiều các nhà nghiên cứu tin rằng những bài toán đó chúng ta không thể giải được hiệu quả và vấn đề chỉ là chúng ta chưa tìm ra cách để  rằng ta không thể giải chúng hiệu quả. Post này và các post tiếp theo sẽ cung cấp một công cụ để xác định những bài toán khó đó. Chúng ta thường mô tả độ phức tạp của một bài toán dựa vào các tài nguyên (resource) cần thiết để giải bài toán đó. Hai loại tài nguyên cơ bản là thời gian (time) và bộ nhớ (space). Trong các bài viết ở đây, chúng ta quan tâm nhiều đến thời gian hơn là bộ nhớ. Trong phân tích của các bài viết trước trên blog, chúng ta thường phát biểu thuật toán có độ phức tạp (thời gian) , , , , hay một cách tổng quát hơn là  với  là một hàm (tăng) của . Vậy ở đây  và  có ý nghĩa thế nào? Ta sẽ lần lượt làm rõ ý nghĩa của hai đại lượng này.Trong phân tích thuật toán, chúng ta thường sử dụng tiệm cận hơn là đếm chính xác số lượng các thao tác cơ bản. Một phần vì đếm chính xác số lượng thao tác thường là một việc không tầm thường. Một phần khác là vì sử dụng phương pháp tiệm cận sẽ cho chúng ta một cách ước lượng tương đối về thuật toán một cách nhanh chóng để chúng ta tập trung vào thiết kế ở mức cao (high level). Phân tích tiệm cận cho phép chúng ta có thể mở rộng tập thao tác cơ bản để bao gồm các phép toán phức tạp hơn như cộng, trừ, nhân và chia (CTNC), trong đó, các hạng (nhân) tử tham gia vào các phép CTNC đều có chiều dài hằng số. Chú ý, nếu các hạng (nhân) tử tham gia vào các phép CTNC không còn là hằng số nữa thì ta không thể coi đó là các thao tác cơ bản. Bạn đoc có thể xem ví dụ cụ thể khi các phép CTNC không còn được coi là hằng số trong phân tích . Một bài toán bao giờ cũng có ít nhất hai phần là đầu vào (input) và đầu ra (output). Độ dài của input được coi như là biến để đo độ phức tạp của thuật toán giải bài toán. Có những bài toán mà ta phải phân tích độ phức tạp dựa trên cả hai biến input và output, ví dụ như bài toán nén dữ liệu (data compression). Ở đây, ta chỉ xét những bài toán mà đầu ra chỉ là 1 bít ( hoặc ). Các bài toán như vậy được gọi là các bài toán  (decision problem).  Các bài toán quyết định thoạt đầu nghe có vẻ không có tính tổng quát cao vì đầu ra chỉ có 1 bít. Tuy nhiên, ta có thể quy rất nhiều bài toán không quyết định về bài toán quyết định, mà thời gian để chuyển qua lại giữa hai bài toán vẫn là đa thức. Ví dụ bài toán tìm kích thước của  (independent set) lớn nhất trong đồ thị.  
Ta có thể quy bài toán  về bài toán quyết định như sau: 
Dễ thấy, bài toán  là bài toán quyết định (có tồn tại hay không). Nếu ta có thể giải được bài toán , ta có thể giải được bài toán  bằng cách tìm kiếm nhị phân giá trị  trong đoạn .

 (a) Tập màu đỏ là một tập độc lập trong đồ thị. (b) Tập màu xanh không phải là một tập độc lập trong đồ thị.Một thuật toán được gọi là giải bài toán quyết định nếu như với mỗi input của bài toán, thuật toán xác định được chính xác đầu ra là  hay . Trong số các bài toán quyết định, lớp bài toán mà chúng ta quan tâm nhất là lớp các bài toán mà ta có thể giải được hiệu quả bằng máy tính. Lớp bài toán đó được gọi là lớp  (viết tắt của polynomial time-thời gian đa thức).  
Trong định  nghĩa trên, giá trị của bậc  trong biểu thức  không quan trọng, miễn là nó không phụ thuộc vào . Do đó, ta sẽ dùng kí hiệu  để thay cho .Tuy nhiên, nhiều bài toán hiện tại chúng ta chưa biết có thể giải được hiệu quả hay không (thuộc  hay không). Trong số các bài toán đó, có một lớp các bài toán thú vị mà người ta gọi nó là lớp . Ý tưởng đằng sau lớp bài toán này là: nếu ai đó cho chúng ta lời giải của một bài toán khó, việc kiểm tra xem đó có phải là lời giải đúng hay không sẽ  việc trực tiếp giải bài toán đó. Dễ hơn ở đây hiểu theo nghĩa có thể kiểm tra được lời giải trong thời gian . Ví dụ với bài toán . Nếu ai đó đưa ta một tập đỉnh  của đồ thị và nói rằng tập đỉnh đó là tập độc lập của đồ thị có kích thước ít nhất , ta có thể kiểm tra (trong thời gian ) xem   có phải là tập độc lập hay không trong thời gian  (tại sao?) và kiểm tra xem  hay không. Nếu cả hai điều kiện được thỏa mãn thì đầu vào của bài toán có lời giải , và ngược lại. Tập  đó gọi là một  (certificate) cho thấy input của bài toán có output . Hai tính chất quan trọng của tập  mà ta có thể rút ra từ ví dụ trên:Ta gọi  là một  của bài toán . Theo định nghĩa trên, để chứng minh một bài toán thuộc  ta phải: (i) chỉ ra một bằng chứng ngắn gọn cho đầu vào  và (ii) chỉ ra một thuật toán để kiểm tra bằng chứng đó trong thời gian . Ta sẽ minh họa thêm một số bài toán  trong phần sau. Từ  ở đây là viết tắt của ondeterministic olynomial time, một thuật ngữ liên quan đến máy Turing không tất định. Nhiều người nhầm lẫn  là viết tắt của on-olynomial time. Về mặt trực quan, một bài toán dễ giải thì cũng dễ kiểm tra lời giải. Do đó,   . Hay nói cách khác, bất kì một bài toán  nào cũng thuộc . Việc chứng minh    theo định nghĩa bằng chứng ngắn gọn dễ kiểm tra ta sẽ coi như bài tập cho bạn đọc (hints: bằng chứng ngắn gọn dễ kiểm tra của một bài toán  là ).Một câu hỏi làm đau đầu các nhà nghiên cứu lý thuyết đó là liệu    hay không? Hay nói cách khác, liệu có tồn tại một bài toán nào trong lớp  mà không thể giải được hiệu quả? Bài toán này được gọi là bài toán  vs , một trong 7 bài toán mà người đưa ra lời giải sẽ được thưởng .   Hầu hết các nhà khoa học máy tính tin rằng   . Tuy nhiên, có những nhà khoa học máy tính nối tiếng, ví dụ như Donald Knuth [3], tin rằng   .  Trên  của mình, Gerhard J Woeginger có liệt kê một danh sách các "chứng minh", và gần như một nửa đưa ra "chứng minh"    còn nửa kia đưa ra "chứng minh"   . Điều đó cho thấy bài toán này, có lẽ, còn rất lâu nữa mới có thể được giải quyết một cách đầy đủ. Tạm thời, chúng ta có biểu đồ Venn thể hiện quan hệ giữa  và  như sau: 
 vs Bài toán quan trọng nhất trong lớp  đó là bài toán . Lí do tại sao  là bài toán quan trọng nhất thì ta sẽ xem ở bài viết tiếp theo.    
Ví dụ:    Trong ví dụ trên,  biểu thức  có phép gán (,,) có giá trị . Biểu thức  không có phép gán nào có giá trị . 
 Bằng chứng mà chúng ta đưa ra ở đây là một phép gán cho các biến của . Bằng chứng này là ngắn gọn vì một phép gán có thể được mô tả bằng  bít với mỗi bít biểu diễn giá trị gián của một biến. Để kiểm tra xem một phép gán này có giá trị  hay không, ta sẽ thay giá trị của từng biến vào biểu thức . Nếu tất cả các mệnh đề đều có giá trị   thì biểu thức có giái tị , và ngược lại. Việc tính giá trị của biểu thức có thể được thực hiện trong thời gian . Do đó, một phép gán là một bằng chứng dễ kiểm tra.  
Ví dụ bài toán xác định biểu thức  ở trên có phép gán giá trị  hay không thuộc  .Chứng minh tương tự Lemma 1, ta có:    
Ví dụ  và , tập  có tổng bằng .  
 Ta chứng minh định lý cho bài toán . Bằng chứng ta đưa ra ở đây là một tập các số nguyên . Bằng chứng  ngắn gọn vì ta có thể dùng tối đa  bít để biểu diễn , trong đó . Để kiểm tra bằng chứng này, ta chỉ việc cộng tất cả các số trong  và kiểm tra xem tổng của chúng có bằng  hay không. Phép cộng này có thể thực hiện được trong thời gian đa thức. 

 Các cạnh tô đậm màu đỏ là các cạnh của một chu trình Hamilton trong đồ thị. 
Chú ý, trong định nghĩa của đường đi đóng, ta cho phép một đỉnh xuất hiện nhiều lần trên đường đi. 
Chứng minh Lemma 4 coi như bài tập cho bạn đọc. Trong post tiếp theo, chúng ta sẽ tìm hiểu về ; tập các bài toán khó nhất trong lớp .[1] Cook, Stephen. . The Millennium Prize Problems (2006): 87-106.
[2] Arora, Sanjeev, and Boaz Barak. . Cambridge University Press, 2009.
[3] Reddit Thread, . Accessed 19/12/2016. , , , , , , Trackback link:  on                     Chỗ \phi(2,4)=(x hội y) tuyển (x hội phủ định của y) tuyển (phủ định x hội y) tuyển (phủ định x hội phủ định y) on                     Hi,
Mình không hiểu ý bạn lắm. Chỗ đó có vấn đề gì?Powered by  and 