Một số kĩ thuật cải tiến quy hoạch động I -- Advanced Dynamic Programming
http://www.giaithuatlaptrinh.com/?p=152
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong loạt bài này mình sẽ giới thiệu những kĩ thuật để cải tiến thuật toán quy hoạch động. Kĩ thuật trong bài này mình viết ở đây chủ yếu dựa trên notes của Jeff Erickson [].  Trong bài viết , mình giới thiệu phương pháp quy hoạch động để tính khoảng cách Edit Distance (ED) giữa hai xâu ,  với thời gian . Gọi  là khoảng cách giữa hai xâu con  và . Công thức đệ quy sau chính là ý tưởng chính của thuật toán quy hoạch động:   
Trong bài viết trước, chúng ta đã thảo luận hai cách thực thi thuật toán quy hoạch động với bộ nhớ tương ứng là  và . Nếu chúng ta chỉ quan tâm đến khoảng cách giữa hai xâu, thuật toán thứ hai hiển nhiên sẽ là lựa chọn tốt. Bây giờ nếu bài toán yêu cầu in ra một dãy với tổng số lượng các các thao tác  nhỏ nhất để biến  thành , chúng ta sẽ làm thế nào?Với thuật toán , bằng cách truy ngược bảng , chúng ta có thể dễ dàng thu được dãy tối ưu các thao tác. Tuy nhiên với cách thực thi với bộ nhớ , gần như không thể truy ngược lại vì chúng ta không lưu toàn bộ bảng . Tuy nhiên, vào năm 1975,  đề xuất phương pháp chia để trị không những tính được khoảng cách giữa hai xâu với thời gian  và bộ nhớ  mà còn tìm được một dãy tối ưu các thao tác để chuyển  thành  với cùng thời gian và bộ nhớ. Giải thuật của Dan Hirshberg sẽ là chủ đề chính của phần này. 
Thuật toán của Hirshberg dựa trên quan sát rằng bài toán chuyển xâu  thành xâu  có thể được chia thành hai bài toán con: bài toán thứ nhất chuyển xâu  thành  và bài toán thứ hai chuyển xâu  thành  . Vấn đề ở đây là làm sao để tìm điểm chia . Hirshberg chứng minh bổ đề sau: 
Ta sẽ chứng minh bổ đề này sau. Bây giờ giả sử chúng ta đã có thuật toán  tìm điểm chia  trong thời gian  và bộ nhớ . Ta có thể gọi đệ quy trên các bài toán con để giải bài toán ban đầu. Chi tiết như trong giả mã sau: 
Có thể dễ thấy là bộ nhớ cần thiết của thuật toán là  vì bộ nhớ cần thiết của thủ tục  là . Thời gian tính của thuật toán được cho bởi công thức đệ quy sau:   
Bằng phương pháp , ta có thể chứng minh rằng .  Giải thuật Hirshberg tìm điểm chia bằng phương pháp quy hoạch động. Gọi  là điểm chia khi biến xâu con  thành . Hay nói cách khác, bài toán chuyển xâu  sang xâu con  có thể được chia thành hai bài toán: bài toán chuyển xâu con  sang xâu  và bài toán chuyển xâu con  sang xâu con . Dễ thấy:Tổng hợp lại, ta có công thức đệ quy sau của :   
Như vậy, điểm chia . Dựa vào công thức đệ quy ở trê, ta có thể tính được  với thời gian  và bộ nhớ . Chi tiết coi như bài tập cho bạn đọc (tham khảo thêm tại ).Ví dụ bảng  và bảng  với hai xâu , . Hình ảnh được lấy từ []

Chính vì kĩ thuật Hirshberg mà thông thường, với các bài toán quy hoạch động, nếu chúng ta có thể tìm được giá trị tối ưu trong thời gian  và bộ nhớ , chúng ta có thể tìm được ít nhất một phương án tối ưu với cùng thời gian và bộ nhớ. Các bài toán quy hoạch động thông thường liên quan đến việc xây dựng bảng quy hoạch hai hoặc ba chiều. Mỗi ô của bảng được cập nhật dựa trên các ô liền kề của bảng. Một điểm chúng ta có thể nhận thấy là không phải tất cả các ô đều được sử dụng trong xây dựng phương án tối ưu. Do đó một cách để tiết kiệm thời gian và bộ nhớ là chúng ta chỉ lưu lại giá trị của những ô mà có thể được sử dụng trong xây dựng phương án. Nếu số lượng các ô đó nhỏ hơn nhiều kích thước cuả toàn bảng, chúng ta sẽ tiết kiệm thêm được thời gian và bộ nhớ. Trong bài này mình lấy bài toán dãy con chung dài nhất (Longest Common Subsequence - LCS) làm ví dụ:  
Ví dụ:  và  có xâu con chung dài nhất là  có chiều dài là 6 (ta thêm kí tự  vào cuối hai xâu để việc lập trình đơn giản hơn). Tương tự như bài toán , nếu ta gọi  là chiều dài dãy con chung dài nhất của hai xâu con . Ta có công thức đệ quy sau:   
Dựa vào công thức trên, ta có thuật toán quy hoạch động giải bài toán trên với thời gian . Thuật toán quy hoạc động cũng là thuật toán tối ưu để giải bài toán này theo nghĩa nếu , không tồn tại thuật toán chạy với thời gian ít hơn  với mọi  trừ khi Giả Thiết Thời Gian Lũy Thừa () là sai [3]. 
Code của thuật toán bằng C. Trong code này, đầu vào  là dãy các số nguyên từ 0-9 thay vì là kí tự. Tuy nhiên trong một số trường hợp đặc biệt, mà ở đây là trường hợp bảng QHD "thưa", ta có thể thiết kế thuật toán nhanh hơn . Nếu để ý kĩ ta sẽ thấy các ô của bảng  được sử dụng để xây dựng phương án tối ưu là các ô  với . Ta gọi các ô  với  là các ô . Với ví dụ  và , ta có tất cả  9 ô hữu ích. Hình sau được lấy từ [].
Ta có thể thấy giá trị của các ô hữu ích phụ thuộc trực tiếp vào nhau theo công thức đệ quy sau: 
Ở công thức trên,  là ô hữu ích (). Gọi  là số lượng các ô hữu ích. Ta có thể tính trước danh sách các ô hữu ích và lưu trong mảng  trong thời gian  như sau: 
Trong code bằng C của giả mã dưới đây, thay vì lưu giữ mảng chỉ số  như trong giả mã, mình dùng cấu trúc dữ liệu  để lưu chỉ số cùng với dữ liệu. Sau khi đã tìm được chỉ số của các ô hữu ích, ta có thể tìm chiều dài của dãy con chung dài nhất bằng quy hoạch động dựa vào công thức đệ quy ở . Giả mã như sau: 
Code của thuật toán bằng C. Code đầy đủ được cho ở cuối bài. Thuật toán tìm các ô hữu dụng có thời gian tính là . Sắp xếp mảng  có thể thực hiện trong thời gian . Phần quy hoạch động cập nhật mảng  có thời gian tính . Do đó, tổng thời gian tính toán của thuật toán  là . Như vậy, nếu  (bảng quy hoạch động "thưa") thì thuật toán trên sẽ nhanh hơn thuật toán quy hoạch động ban đầu. Bằng kĩ thuật tương tự với kĩ thuật trong bài , chúng ta có thể giảm thời gian cập nhật mảng  xuống còn . Do đó thời gian tính có thể giảm xuống còn . Chi tiết coi như bài tập cho bạn đọc. Code: . 
, UIUC.
[2] D. S. Hirschberg. 1975. . Commun. ACM 18, 6 (June 1975), 341-343.
[3] Abboud, Amir, Arturs Backurs, and Virginia Vassilevska Williams. . arXiv preprint arXiv:1501.07053 (2015). , , , Trackback link:  on                     Thiếu dấu + ở mục độ phức tạp: O(nlognmlogm+K) on                     Cám ơn bạn đã chỉ ra. Mình đã sửa!
HùngPowered by  and 