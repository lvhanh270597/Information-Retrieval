Đồ thị -- Introduction to Algorithmic Graph Theory
http://www.giaithuatlaptrinh.com/?p=553
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong bài này và loạt bài tiếp theo chúng ta sẽ làm quen với đồ thị và các thuật toán với đồ thị. Đồ thị là một đối tượng tổ hợp (combinatorial object) được nghiên cứu và ứng dụng rất nhiều trong thực tế (có lẽ hơi thừa khi viết điều này). Phần này chúng ta sẽ:Bạn đọc có thể bỏ qua các phần mà các bạn đã quen thuộc. Note [1] của Jeff Erickson vẫn là tài liệu tham khảo chính của bài này. Một , kí hiệu là , gồm hai thành phần:Ta sẽ kí hiệu  lần lượt là số đỉnh và số cạnh của đồ thị, i.e, . Số đỉnh của đồ thị đôi khi ta cũng gọi là  (order of the graph). Các đỉnh ta sẽ kí hiệu bằng các chữ in thường như . Cạnh giữa hai đỉnh  có thể là  hoặc . Trong trường hợp đầu ta sẽ kí hiệu cạnh là , còn trong trường hợp sau ta sẽ kí hiệu là  để chỉ rõ hướng của cạnh là từ  đến . Thông thường khi ta nói cạnh thì ta ám chỉ cạnh vô hướng còn với một cạnh có hướng ta sẽ gọi nó là một  (arc). Hình  của hình dưới đây biểu diễn một đồ thị vô hướng (các cạnh là vô hướng) và hình  phải của hình dưới đây biểu diễn một đồ thị có hướng.Trong hình , cạnh  được gọi là  (loop) và hai cạnh giữa cặp đỉnh  được gọi là hai  (parallel edges).  Một đồ thị được gọi là một  (simple graph) nếu nó không có cạnh lặp và cạnh song song (hình ). Nếu một đồ thị không phải là đơn đồ thị thì chúng ta sẽ goị nó là  (multigraph). Trong các loạt bài đồ thị ở đây, ta chủ yếu xét đơn đồ thị. Do đó, khi nói đồ thị ta sẽ ngầm hiểu là đơn đồ thị. Ta có: Nếu đồ thị  vô hướng, với mỗi cạnh , đỉnh  được gọi là kề (incident) với cạnh . Đỉnh  được gọi là hàng xóm (neighbor) của .  (degree) của đỉnh , thường kí hiệu là , là số hàng xóm của đỉnh . Nếu đồ thị  có hướng, với mỗi cung , đỉnh  được gọi là  (successor) của  và đỉnh  được gọi là  (predecessor) của .  (in-degree) của  là số đỉnh liền trước  và  (out-degree) của  là số đỉnh liền sau . Ví dụ bậc tới của  trong hình  là 1 và bậc lui là .Ta gọi  là  (subgraph) của  nếu  và . Một  (walk) là một dãy các cạnh  trong đó hai cạnh liền kề bất kì  và  đều có chung một đỉnh.
Chú ý là đường đi có thể đi qua một đỉnh nhiều lần. Trong trường hợp mỗi đỉnh được thăm đúng 1 lần, ta sẽ gọi đó là  (path). Ví dụ trong đồ thì ở hình dưới đây,  là một đường đi giữa  và  và  là một đường đi đơn giữa  và . Một  (closed walk) là một đường đi bắt đầu và kết thục tại cùng một điểm. Một  (cycle) là một đường đi đơn bắt đầu và kết thúc tại cùng một điểm. Có thể nói một chu trình là một đường đi đóng đi qua mỗi điểm đúng 1 lần ngoại trừ điểm đầu và điểm cuối. Các khái niệm vừa rồi nếu áp dụng cho đồ thị có hướng thì ta sẽ thêm từ "có hướng" vào đằng trước.
 Một đồ thị vô hướng được gọi là  (connected) nếu tồn tại một đường đi giữa mọi cặp điểm. Một đồ thị có hướng gọi là  liên thông (yếu) nếu đồ thị vô hướng thu được từ đồ thị đó bằng cách bỏ qua hướng của cạnh là liên thông. Một đồ thị có hướng gọi là  (strongly connected) nếu tồn tại một đường đi có hướng giữa mọi cặp điểm. Hiển nhiên nếu một đồ thị có hướng liên thông mạnh thì nó cũng liên thông yếu. Tuy nhiên điều ngược lại chưa chắc đúng (ví dụ?).  Ví dụ đồ thị  dưới đây là không liên thông, đồ thị  liên thông, đồ thị  liên thông yếu (nhưng không mạnh) và đồ thị  liên thông mạnh. Nếu một đồ thị (vô hướng) không liên thông, tập các đỉnh liên thông với nhau tạo thành một  (connected component). Tương tự như vậy ta có thể định nghĩa thành phần liên thông (yếu hay mạnh) cho đồ thị có hướng. Một đồ thị  (acyclic) thì ta gọ là một  (forest). Một rừng chỉ có một thành phần liên thông thì ta gọi nó là một  (tree). Khái niệm cây và rừng có hướng tương tự như đồ thị có hướng.  Có lẽ ta sẽ dừng định nghĩa khái niệm ở đây. Còn  các khái niệm khác chúng ta sẽ định nghĩa khi mà chúng ta cần. Gần như tất cả các khái niệm cơ bản đã được liệt kê ở [2] mà bạn đọc có thể tham khảo thêm. Trong phần tiếp theo, ta xét  vô hướng. Các thao tác với đồ thị có hướng có thể được mở rộng và áp dụng một cách tương tự.Chúng ta có thể biểu diễn đồ thị bằng một  (adjacency matrix)  có kích thước  trong đó:  Có thể thấy ngay là kích thước của cách biểu diễn này là  bất kể số lượng cạnh là nhiều hay ít. Theo Fact 1, số lượng cạnh  của một đồ thị có thể lên tới  cạnh (ta gọi là đồ thị dầy). Do đó, cách biểu diễn này có thể nói là phù hợp với đồ thị dầy. Tuy nhiên, nhiều đồ thị (đặc biệt các đồ thị thực tế như mạng xã hôi), số lượng cạnh  (ta gọi là đồ thị thưa). Do đó cách biểu diễn này khá tốn kém với đồ thị thưa. Để tiết kiệm bộ nhớ, với mỗi đỉnh , ta lưu trữ một danh sách các đỉnh kề với nó. Như vậy, đỉnh  cần một danh sách có  phần tử. Do đó tổng số phần tử của các danh sách là:  Tổng  là do mỗi cạnh được đếm hai lần trong tổng bậc của hai đỉnh kề với nó. Cách biểu diễn như trên gọi là biểu diễn bằng  (adjacency list). Cách biểu diễn này phù hợp với cả đồ thị thưa. Mặc dù tiết kiệm bộ nhớ, cách biểu diễn này không phù hợp với một số thao tác của đồ thị. Bảng dưới đây so sánh hai cách biểu diễn vừa trình bày. Ví dụ về hai cách biểu diễn đồ thị cho trong hình dưới đây:Ta còn có thể kết hợp cách biểu diễn danh sách kề với một vài cấu trúc dữ liệu khác. Cụ thể, thay vì dùng danh sách liên kết để biểu diễn các đỉnh kề với một đỉnh , ta còn có thể dùng bảng băm hoặc cấu trúc cây để biểu diễn. Trong khuôn khổ các bài viết ở đây, ta ít dùng (hoặc không dùng) các cấu trúc như vậy.Ngoài ra ta có thể biểu diễn đồ thị bằng cách liệt kê tất cả các cặp  thỏa mãn . Cách biểu diễn này có bộ nhớ là . Tuy nhiên, việc thực hiện các thao tác cơ bản trong cách biểu diễn này sẽ rất tốn kém. Đôi khi, ta có thể kết hợp cách biểu diễn này với cách biểu diễn danh sách kề để tận dụng ưu thế của cả hai cách biểu diễn mà bộ nhớ vẫn là tuyến tính.  Ta gọi bài toán trên là bài toán duyệt đồ thị từ một đỉnh . Để đơn giản, ta sẽ giả sử đồ thị là liên thông. Trường hợp đồ thị không liên thông sẽ được mở rộng ở cuối phần này. Cách thức chung để duyệt đồ thị như sau: Ta sẽ sử dụng 2 loại nhãn để gán cho các đỉnh của đồ thị:  (unvisited) và  (visited). Ban đầu tất cả các đỉnh được đánh dấu là chưa thăm (unvisited). Ta sẽ duy trì một tập hợp  (thực thi tập  thế nào ta sẽ tìm hiểu sau), ban đầu khởi tạo rỗng. Ta sẽ thực hiện lặp 2 bước sau: Thuật toán dừng khi . Giả mã như sau:  Một đỉnh có thể được đưa nhiều lần vào tập  (do đó  không hẳn là tập hợp vì có nhiều phần tử giống nhau). Ví dụ xét 3 đỉnh  đôi một kề nhau. Đỉnh  được lấy ra từ  đầu tiên; đánh dấu  là đã thăm. Ngay sau đó,  và  sẽ được đưa vào . Tiếp theo, lấy  ra khỏi  và đánh dấu  là đã thăm. Lúc này ta lại tiếp tục đưa  vào  một lần nữa vì theo giả mã trên,  là hàng xóm của  và có nhãn chưa thăm. Ở đây, ta sẽ  kiểm tra xem một đỉnh đã nằm trong  hay chưa trước khi đưa vào .Từ giả mã trên, ta thấy, tập  lưu các đỉnh .  Giả sử rằng ta sử dụng một cấu trúc để thực thi  sao cho việc thêm vào hoặc lấy một đỉnh bất kì (dòng  và dòng cuối cùng) được thực hiện trong thời gian  (ví dụ nếu thưc thi   bằng danh sách liên kết thì thêm vào hoặc lấy ra đỉnh ở đầu danh sách có thể được thực hiện trong thời gian ). Ta có một vài nhận xét sau:Từ các nhận xét trên, ta suy ra tổng thời gian tính toán của thuật toán là . Trong trường hợp đồ thị không liên thông, ta phải duyệt qua từng thành phần liên thông một. Do đồ thị có tối đa  thành phần liên thông, ta có: Nếu ta thực thi  bằng danh sách liên kết thì có lẽ không có gì thú vị cả.  Tuy nhiên, nếu ta thực thi  bằng hàng đợi (Queue) hoặc ngăn xếp (Stack) thì ta sẽ thu được một số tính chất thú vị từ đồ thị. Trường hợp ta thực thi  bằng hàng đợi, ta gọi thuật toán là  (Breath First Search - BFS). Trường hợp ta thực thi  bằng ngăn xếp, ta gọi thuật toán là  (Depth First Search - DFS). Sau đây ta sẽ thảo luận cả hai thuật toán. Như đã nói ở trên, thuật toán BFS sẽ thực thi  bằng hàng đợi. Ta sẽ thay thủ tục  bằng thủ tục  và thủ tục  bằng thủ tục . Ngoài khung cơ bản như thuật toán ở trên, ta sẽ gán cho mỗi đỉnh  một nhãn . Giá trị của , như ta sẽ chỉ ra dưới đây, là khoảng cách ngắn nhất từ  tới . Giả mã như sau: 
Code của giả  mã bằng C:Ví dụ ta thực thi thuật toán trên với đồ thị trong hình bên trái và kết qủa thu được trong hình bên phải. Các số ứng với các đỉnh tương ứng là nhãn của các đỉnh đó. Những cạnh màu đỏ laf những cạnh mà  có nhãn unvisited ở dòng  được thăm bởi BFS.  Gọi mức (level) của một đỉnh , kí hiệu là , là khoảng cách ngắn nhất từ đỉnh  tới . Trong ví dụ trên, đỉnh  có mức ,  có mức 2, .... Bằng quy nạp, ta có thể chứng minh rằng (coi như bài tập cho bạn đọc): Các đỉnh ở mức  sẽ được thăm sau các đỉnh ở các mức .
Ta quy nạp trên biến  để chứng minh rằng nhãn của  cũng chính là mức của , i.e, .Xét một đỉnh . Lần đầu tiên  được đưa vào hàng đợi  là khi ta thăm một đỉnh  nào đó kề với  và theo Claim trên, mức của  sẽ nhỏ hơn mức của . Từ định nghĩa của mức ta suy ra . Theo giả thiết quy nạp , ta suy ra . Theo giả mã, khi đưa  vào hàng đợi, ta cập nhật . Do đó, , dpcm.Kết hợp Theorm 1 và Theorem 2 ta có hệ quả sau: Corollary 1 có ý nghĩa rất lớn vì ta sẽ thấy (trong bài ), thuật toán tốt nhất tìm đường đi ngắn nhất với đồ thị có trong số có thời gian  ngay cả trong đồ thị thưa (m = O(n)). Thuật toán BFS sẽ là thuật toán đơn giản và hiệu quả để tìm đường đi ngắn nhất trong đồ thị không có trong số. Trong duyệt theo chiều sâu DFS, ta thực thi  sử dụng ngăn xếp. Ta sẽ thay thủ tục  bằng thủ tục  và thủ tục  bằng thủ tục . 
Code của giả  mã bằng C:Nếu chỉ nhìn qua thi không thấy sự khác biệt qúa nhiều giữa DFS và thuật toán chung để duyệt đồ thị. Tuy nhiên bằng cách  cập nhật thêm một vài thông tin trong quá trình duyệt đồ thị (giống như BFS), ta có thể phát hiện ra những tính chất rất thú vị của DFS. Ta sẽ thảo luận những tính chất đó ở bài sau.  Hình dưới đây là một ví dụ thực thi DFS trên đồ thị. Số tương ứng của mỗi đỉnh ở bên phải là thứ tự của đỉnh thăm bởi DFS. Ngoài thủ tục lặp DFS sử dụng ngăn xếp như trên, có lẽ một trong số chúng ta cũng khá quen thuộc với thủ tục thực thi DFS sử dụng đệ quy sau: 
Code của giả  mã bằngTa thấy cách thứ hai đơn giản hơn do không phải thực thi Stack. Tuy nhiên, cách này sẽ sử dụng nhiều Call Stack của máy tính và trong trường hợp độ sâu đệ quy lớn có thể gây ra Stack Overflow. Một trong những ứng dụng đơn giản nhất để duyệt đồ thị là phát hiện ra các thành phần liên thông. Để phát hiện ra các thành phần liên thông của đồ thị (vô hướng), ta thực hiện lặp lại thao tác sau: chọn một đỉnh chưa thăm  và thực hiện thăm các đỉnh trong thành phần liên thông chứa . Thủ tục sau đây trả lại số thành phần liên thông của đồ thị đầu vào .  Code C:Code đầy đủ: , .
[1] Jeff Erickson, , UIUC.
[2] Diestel, Reinhard.  Grad. Texts in Math (2005).
[3] Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 23. MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7. , , , , , Trackback link: Powered by  and 