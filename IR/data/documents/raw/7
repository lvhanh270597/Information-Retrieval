Cây tìm kiếm ưu tiên -- Priority Search Tree
http://www.giaithuatlaptrinh.com/?p=643
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong bài này chúng ta sẽ làm quen với một cấu trúc dữ liệu sử dụng trong hình học tính toán (computational geometry) tên gọi là  (Priority Search Tree - PST). Cây PST được McCreight [1] phát triển vào năm 1985 (cũng là người phát triển thuật toán tuyến tính ). Cấu trúc cây PST là sự kết hợp của hàng đợi ưu tiên (Priority Queue) và cây nhị phân tìm kiếm (Binary Search Tree) vào trong cùng một cấu trúc. Cấu trúc PST có nhiều ứng dụng trong hình học tính toán (xem thêm tại [1]). Một trong những ứng dụng nổi bật là dùng để truy vấn các điểm trong một vùng hình chữ nhật vô hạn một bên. Chúng ta sẽ thảo luận ứng dụng đó ở cuối bài. Để đơn giản cho việc trình bày và ứng dụng cây PST, chúng ta xét bài toán sau:  Ví du tập  (các điểm màu xanh trong hình dưới đây) và  (điểm màu tím trong hình dưới đây). Các điểm nhỏ hơn điểm  là  (là các điểm nằm trong hoặc nằm trên đường bao của vùng màu xanh trong hình dưới đây).Biểu diễn các nút trong C:Chúng ta có thể dễ dàng thiết kế giải thuật có độ phức tạp  giải bài toán trên bằng cách với mỗi điểm   trong , ta duyệt qua tất cả các điểm trong  và in ra những điểm nhỏ hơn .  Trong trường hợp tồi nhất khi  với mọi  thì thuật toán trên là thuật toán tối ưu. Tuy nhiên trong trường hợp với mỗi , chỉ có  điểm trong  nhỏ hơn  thì thuật toán trên quá tốn kém. Sử dụng PST, chúng ta có thể thiết kế giải thuật tốt hơn nhiều khi  lớn. Trọng tâm của bài này là định lý sau: Như vậy, sử dụng cấu trúc cây PST, ta có thể giải Problem 1 trong thời gian  trong đó  là số điểm cần phải in ra trong lời giải tối ưu. Cấu trúc cây PST là kết hợp của cấu trúc  nổi tiếng và Binary Search Tree. Nếu bạn đọc đã từng thực thi thuật toán tìm cây khung nhỏ nhất (Minimum Spanning Tree) thì có lẽ đã bắt gặp cấu trúc Heap rồi. Trước hết mình nhắc lại một số khái niệm cơ bản nhất của min-Heap. Min-Heap là một cấu trúc cây nhị phân thỏa mãn các tính chất sau:Ví du tập các giá trị  có cấu trúc Heap biểu diễn minh họa trong hình dưới đây:
 Từ tính chất Heap ta có thể chứng minh (bằng quy nạp) được rằng giá trị khóa ở gốc là giá trị nhỏ nhất trong tập các khóa của cây (do đó gọi là min-heap). Từ tính cân bằng mạnh ta có thể suy ra chiều cao của một Heap với  nút tối đa là .  Tính cân bằng này gọi là mạnh vì nút ở mức lá phải là liên tục từ trái sang phải.  So với các cây nhị phân tìm kiếm thì Heap đơn giản hơn, mềm dẻo hơn và là một cấu trúc cân bằng mà sự cân bằng đó có thể được duy trì khá đơn giản khi thực hiện các thao tác trên heap mà không cần phải có thêm thông tin phụ. Do đó các thao tác với Heap thông thường chỉ mất thời gian . Chi tiết thêm về Heap có lẽ mình sẽ blog vào một lúc nào đó, tạm thời bạn đọc tham khảo thêm tại [2]. Một cây nhị phân PST biểu diễn tập điểm  là một cây thỏa mãn tính chất sau:Chú ý trong tính chia đôi, ta cho phép cả cây con trái và con phải của  có các điểm tung độ bằng . Điều này là cần thiết để đảm bảo tính cân bằng. Ví dụ nếu ta chỉ cho cây con trái có điểm có tọa độ  và con phải có tọa độ  thì không thể đảm bảo tính cân bằng trong trường hợp tất cả các điểm trong  có cùng tung độ.Ví dụ cây PST với tập  như trên được biểu diễn ở hình sau. Các cặp giá trị ở phần background màu xanh của mỗi nút là một điểm biểu diễn bởi nút đó. Giá trị ở phần dưới là điểm chia .Ta có thể quan sát thấy việc tìm kiếm theo tọa độ  của các điểm được "tích hợp" vào cây thông qua tính chất Heap và tìm kiếm theo tọa độ  của các điểm được "tích hợp" thông qua tính chia đôi. Tính cân bằng đảm bảo chiều cao của cây là . Với các tính chất đó, ta có thể nhận thấy rằng PST là một cấu trúc phù hợp để tìm kiếm hai chiều với độ phức tạp của mỗi thao tác tìm kiếm là .  Dễ thấy cấu trúc cây PST có bộ nhớ là . Giả sử chúng ta đã xây dựng được cây PST, kí hiệu là , biểu diễn tập điểm , ta sẽ thực hiện truy vấn với mỗi điểm . Để in ra các điểm nhỏ hơn , ta sẽ so sánh  với cây , bắt đầu từ nút gốc. Gọi  là một nút trong  mà ta đang so sánh với :Giả mã của thủ tục truy vấn như sau:  
Code C:Từ phân tích ở trên, ta suy ra: Phần tiếp theo chúng ta sẽ tìm hiểu cách xây dựng cây PST trong thời gian Gọi  là tập các điểm trong . Ta sẽ xây dựng cây PST một cách đệ quy như sau:Ví dụ với tập , các bước xây dựng cây PST được mô tả trong hình sau:
Giả mã của thuật toán: Thủ tục  chọn ra điểm chia  như mô tả ở bước 1 trong thời gian . Thủ tục này mình đã blog trước đây, các bạn xem lại tại bài viết .  Ta thấy chọn điểm với hoành độ nhỏ nhất có thể thực hiện trong  bằng cách duyệt qua tất cả các phần tử trong mảng. Chọn  cũng có thể thực hiện trong  như đã nói ở trên. Chia  ra thành 2 phần  và  mất . Gọi  là thời gian xây dựng cây PST. Do  và  xấp xỉ , ta suy ra công thức đệ quy:    trên ta được . Do đó: Từ Lemma 1 và Lemma 2, ta dễ dàng suy ra Theorem 1. Thực thi theo đúng thuật toán trên cũng khá mất thời gian do phải thực thi thuật toán chọn median trong thời gian . Trong bước chọn median, để đơn giản, ta có thể sắp xếp các điểm theo , sau đó thực hiện chọn. Thời gian của bước sắp xếp là  và do đó thời gian của thuật toán là:  Từ đó suy ra  . Không quá tệ!!!!Tuy nhiên, ta có thể cải tiến ý tưởng này thành  như sau: Sắp xếp các điểm trong  theo tọa độ  ngay từ ban đầu với thời gian . Khi đó, việc chọn median có thể thực hiện trong thời gian  vì các điểm trong  là đã sắp xếp theo . Do đó, thuật toán xây dựng cây PST sẽ như sau:  Code C:
Coming soon!Code đầy đủ của bài viết: [1] McCreight, Edward M.  SIAM Journal on Computing 14.2 (1985): 257-276.
[2] Todd Wittman, , UCLA, 2010.
[3] de Berg, Mark; van Kreveld, Marc; Overmars, Mark; Schwarzkopf, Otfried (2000). . Computational Geometry: algorithms and applications (2nd ed.). Springer-Verlag Berlin Heidelberg New York. doi:10.1007/978-3-540-77974-2 Trong một trò chơi chỉ có một người chơi và có  lá bài. Người chơi đó có hai thuộc tính được biểu diễn bởi hai biến số nguyên  và . Mỗi lá bài có 4 thuộc tính được biểu diễn bới 4 số nguyên; lá bài thứ  có thuộc tính là . Trong mỗi bước, người chơi được chọn một con bài. Tuy nhiên, người chơi đó chỉ có thể chọn con bài có hai thuộc tính . Khi người chơi chọn con bài đó, thì thuộc tính của người chơi đổi thành . Người chơi chiến thắng khi chọn được con bài thứ . Ban đầu người chơi có thuộc tính là . Bài toán đặt ra là tìm số nước đi ít để nhất người chiến thắng.:  Dòng đầu tiên là số nguyên dương  với .  dòng tiếp theo, mỗi dòng là 4 số nguyên dương . Dòng đầu tiên in ra số nguyên , là số nước đi ít nhất để chiến thắng. Dòng tiếp theo in ra  số nguyên, số thứ  là số thứ tự của quân bài mà người chơi sẽ chọn trong nước thứ  của lời giải tối ưu. Nếu có nhiều cách đi thì chỉ cần in ra một trong số đó.Nếu không có cách nào để người chơi có thể chiến thắng, in ra -1.
Test 1:
4
0 0 3 4
2 2 5 3
4 1 1 7
5 3 8 8
Ouptut:
3
1 2 4Test 2:
2
0 0 4 6
5 1 1000000000 1000000000
Ouptut:
-1 , , , , , , Trackback link: Powered by  and 