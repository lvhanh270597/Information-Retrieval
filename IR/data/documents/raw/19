Giải thuật cho hệ thống gợi ý với dữ liệu lớn -- A Recommendation Algorithm for Big Data
http://www.giaithuatlaptrinh.com/?p=1320
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Bài này chúng ta sẽ nghiên cứu kĩ thuật thiết kế giải thuật cho một hệ thống gợi ý với dữ liệu rất lớn (lên tới 100 triệu user và 100 triệu items). Trọng tâm của bài này là sử dụng phép băm. Gọi  và  lần lượt là tập các user, item trong hệ thống. Một chú ý quan trọng của bài này đó là dữ liệu của chúng ta là rất lớn, do đó tất cả các giải thuật với độ phức tạp  là đều không thể sử dụng được.Giải thuật gợi ý thường được chia thành 3 dạng chính:Trong bài này, chúng ta chỉ tập trung vào . Giải thuật lọc cộng tác lại chia thành 2 nhóm chính:Mặc dù hai phương pháp này khác nhau về mặt khái niệm, các thức thực thi thì lại tương tự nhau. Do đó, trong bài này, chúng ta chỉ tập trung vào một phương pháp, mà cụ thể là phương pháp dựa trên user.Trước hết chúng ta sẽ nói đến độ đo tương tự. Thông thường với dữ liệu có số chiều cao mà thưa như visit log, người ta sử dụng 2 độ đo chính là độ đo Cosine và độ đo Jaccard. Tại sao các độ đo khác không phù hợp thì chúng ta không bàn thêm ở đây (xem thêm tại ).Với độ đo Cosine, chúng ta coi mỗi user như một vector với mỗi chiều tương ứng với một item. Sự tương tự giữa 2 user được tính là Cosin giữa 2 vector tương ứng. Do độ đo Cosine sử dụng căn bậc 2, một thao tác khá tốn kém, nên ta sẽ không dùng. Như vậy, lựa chọn còn lại là độ đo Jaccard.Độ đo Jaccard giữa 2 tập hợp  và  được định nghĩa như sau:  Ví dụ ,  thì độ đo Jaccard của  và  là:  Độ đo Jaccard áp dụng cho hai user cho trước chính là độ tương tự giữa 2 tập item tương ứng mà 2 user đó thăm. Ví dụ  đã thăm các item  và  đã thăm các item  thì độ tương tự giữa  và  là .Sau khi ta đã thống nhất một độ đo tương tự, ta có thể thực hiện gợi ý đơn giản như sau:  Hai vòng lặp ngoài cùng sử dụng  bước lặp. Tính  mất thời gian , trong trường hợp tồi nhất. Trong thực tế, số các item được xem bởi một user thường nhỏ hơn tổng số items rất nhiều, và có thể coi là . Như vậy, trong trường hợp lạc quan nhất thì thời gian của thuật toán vẫn là . Trong thuật toán trên, với mỗi user , ta chỉ quan tâm đến các user  mà  (giá trị thực tến của  thường là ). Trong thực tế, các user có  thường không quá nhiều (khoảng vài ngàn). Tuy nhiên, thuật toán trên phải duyệt qua tất cả các user để lọc ra những user có độ tương tự cao với . Một ý tưởng cải tiến khá tự nhiên đó là: sử dụng một hàm băm  thỏa mãn: Nếu  thì  sẽ được băm vào cùng một cụm (với xác suất cao), và ngược lại.Ở đây, ta nói với xác suất cao là vì các hàm băm tốt, về mặt lý thuyết, đều phải là các hàm băm ngẫu nhiên.  Hàm băm  với tính chất như trên được gọi là hàm băm LSH (Locality Senstive Hashing). Giả sử hàm băm  như thế tồn tại, giải thuật  có thể được viết lại như sau: Chúng ta có thể dễ dàng nhận ra trong kịch bản tốt nhất, thời gian của thuật toán trên là Trong phần này chúng ta sẽ thảo luận cách thức thực thi  thuật toán . Trước hết ta tạm quên đi Condition 1, thay vào đó, ta xem xét gợi ý với hàm băm đơn giản sau:  
Hàm () về cơ bản trả về chỉ nhỏ nhất trong hoán vị  trong số các item mà  đã xem trong quá khứ. Ví dụ ta có 3 items:  và user  thăm . Giả sử hoán vị chúng ta sinh ra ngẫu nhiên là . Có nghĩa là  có chỉ số 3,  có chỉ số 1, và  có chỉ số 2. () sẽ trả về  vì 2 là chỉ số nhỏ nhất trong tập chỉ số .Câu hỏi mà ta sẽ tìm hiểu với hàm băm này đó là xác suất hai user  và  có cũng mã băm (băm vào cùng một cụm) là bao nhiêu?  trong đó ()
 
 Dễ thấy, trong tập  item , xác suất để một item bất kì có chỉ số nhỏ nhất trong hoán vị ngẫu nhiên  là . Mở rộng ra, xác suất để một item bất kì trong một tập con các item  của  có chỉ số nhỏ nhất trong hoán vị ngẫu nhiên  là . Do đó, xác xuất để  chính là xác suất mà một phần tử (bất kì) trong tập hợp  trở thành phần tử có chỉ số nhỏ nhất trong tập hợp . Xác suất này chính là .Từ phân tích ở trên, ta thấy, hàm băm  mà ta chọn thông qua hoán vị ngẫu nhiên  có một tính chất khá thú vị đó là xác suất hai user được băm vào một cụm bằng độ tương tự Jaccard giữa hai user đó. Tuy nhiên, ta chưa thể áp dụng ngay ý tưởng này vào gợi ý được vì còn hai lí do:Ta sẽ giải quyết vấn đề đầu tiên trước.Phần này ta sẽ nghiên cứu phương pháp đơn giản để tăng cường xác suất sao cho hàm băm ở trên thỏa mãn Condition 1. Thay vì chỉ sử dụng một hàm băm, ta sẽ sử dụng  hàm băm  MinHash như trên (bằng cách chọn  hoán vị ngẫu nhiên khác nhau). Chia  hàm băm này thành  nhóm, mỗi nhóm  hàm băm. Với mỗi user, ví dụ , ta sẽ băm  vào  cụm, trong đó mỗi cụm sẽ tương ứng với  hàm băm.Ví dụ với , ta chia hàm băm thành 10 nhóm, mỗi nhóm 3 hàm băm. 10 Nhóm đó là , ,,. Như vậy, mỗi user  sẽ được phân vào 10 cụm, đó là:   
Ví dụ với , thì ta có . Từ đó ta suy ra xác suất để hai user với độ tương tự ít nhất  được băm vào cùng ít nhất một cụm là . Rõ ràng xác suất này cao hơn nhiều so với . Hay nói cách khác, ta đã tăng cường được xác suất mà hai users được băm vào cùng một cụm. Trong thực tế, với  ngưỡng  cho trước, ta chỉ việc chọn  sao cho phù hợp. Vấn đề đầu tiên coi như đã xong. Ta tiếp tục với vấn đề thứ 2: làm sao để thực hiện hàm băm với hoán vĩ ngẫu nhiên?Như đã phân tích ở trên, ta cần  bít để mô tả một hoán vị ngẫu nhiên. Rất may, dựa vào phân tích của Theorem 1, ta thấy  chúng ta không nhất thiết phải sử dụng hoán vị ngẫu nhiên để thực hiện hàm băm . Tính chất mà chúng ta cần đó là một hàm (ngẫu nhiên) có thể ánh xạ tập hợp  vào tập các số nguyên  (ví dụ 64 bít) sao cho xác suất để một phần tử bất kì trong  có giá trị (ảnh) nhỏ nhất trong  là . Điều này lại gợi cho chúng ta sử dụng hàm băm. Hàm băm thỏa mãn tính chất này người ta gọi là hàm băm Minwise Independent Hashing (MIH) [4]. Mình sẽ không đi sâu thêm ở đây vì lý thuyết của loại hàm băm này khá phức tạp. Các bạn xem thêm tại [4] và cách xấp xỉ hàm băm này trong [5].Sau đây là giải mã của giải thuật đầy đủ, kết hợp tất cả các ý tưởng ở trên.   Dễ thấy trong kịch bản tốt nhất, thời gian của thuật toán là  vì số lượng hàm băm  mà ta chọn trong thực tể chỉ khoảng vài chục đến vài trăm. 
[1] Das, Abhinandan S., Mayur Datar, Ashutosh Garg, and Shyam Rajaram.  Proceedings of the 16th International Conference on World Wide Web. ACM, 2007.
[2] Jure Leskovec, Anand Rajaraman, Jeff Ullman. , 2nd Edition, Chapter 3.
[3] FNV Hash function: http://isthe.com/chongo/tech/comp/fnv/, accessed 08/01/2012
[4] Broder, Andrei Z., Moses Charikar, Alan M. Frieze, and Michael Mitzenmacher.  In Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing, pp. 327-336. ACM, 1998.
[5] Indyk, Piotr.  Journal of Algorithms 38.1 (2001): 84-90. , , , , , Trackback link: Powered by  and 