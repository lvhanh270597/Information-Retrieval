Thuật toán Miller-Rabin kiểm tra tính  nguyên tố -- Miller-Rabin Primality Testing
http://www.giaithuatlaptrinh.com/?p=278
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong phần này chúng ta sẽ tìm hiểu bài toán kiểm tra tính nguyên tố (primality testing) của một số nguyên. Đây là một bài toán có rất nhiều ứng dụng trong các lĩnh vực của tin học, đặc biệt trong bảo mật thông tin. Bài toán phát biểu như sau: 
Bằng cách duyệt qua mỗi phần tử  và kiểm tra xem  có phải là ước của  hay không, ta có thể giải bài toán này trong thời gian  (có thể tăng tốc thêm một chút bằng cách chỉ kiểm tra  và các số lẻ).  Thuật toán  không phải là thuật toán có thời gian đa thức (polynomial time) vì đầu vào có thể biểu diễn bởi  bit trong khi thời gian tính toán là . Do đó, thuật toán này không thể áp dụng cho các số  rất lớn. Bài toán kiểm tra tính nguyên tố có thể được thực hiện trong thời gian đa thức hay không là một câu hỏi mở trong một khoảng thời gian rất dài và được giải quyết năm 2002 bởi Manindra Agrawal, Neeraj Kayal, và Nitin Saxena (thuật toán ). Tuy nhiên thuật toán AKS sử dụng  thao tác bít và vì vậy không phù hợp với các ứng dụng thực tế. Thuật toán Miller-Rabin là thuật toán ngẫu nhiên kiểm tra tính nguyên tố sử dụng  thao tác bít với xác suất lỗi thấp. Do đó, thuật toán này được áp dụng khả phổ biển trong các ứng dụng thực tế. Ban đầu, thuật toán này được đề xuất bở Miller [1] và là thuật toán tất định (deterministic). Sau đó, Rabin [2] sửa đổi thành thuật toán ngẫu nhiên. Về lịch sử của thuật toán xem thêm tại . Do phân tích các thuật toán trong phần này dùng một số kiến thức về đồng dư và lý thuyết nhóm, mình sẽ trình bày các bổ đề và thuật toán trước. Chứng minh và phân tích mình sẽ đẩy về cuối bài viết.Trước hết chúng ta xem xét thuật toán dựa trên . Định lý nhỏ Fermat phát biểu như sau:   Dựa trên Fermat's Little Theorem, ta có thuật toán kiểm tra số nguyên tố của một số nguyên:   Code của giả  mã bằng C:Trong giả mã trên, hàm () tính ước số chung lớn nhất giữa hai số nguyên  dựa trên . Hàm này sử dụng  thao tác cơ bản (cộng, trừ, modulo). Các thao tác cơ bản này đều được thực hiện sử dụng số phép thao tác bít bằng số lương bít biểu diễn. Hàm  () tính  sử dụng  phép nhân 2 số  bít. Để đơn giản ta sẽ giả sử phép nhân 2 số  bít được thực hiện sử dụng  thao tác bít ( về mặt , ta có thể thực hiện phép nhân sử dụng  thao tác bít).  Do đó, ta có: Theo định lí Fermat, thuật toán  luôn trả lại kết quả đúng nếu đầu vào  là số nguyên tố. Hầu hết các thuật toán kiểm tra nguyên tố ngẫu nhiên thỏa mãn tính chất này. Tuy nhiên, nếu đầu vào  là một hợp số thì thuật toán vẫn có thể trả lại PRIME. Một thuật toán ngẫu nhiên kiểm tra tính nguyên tố gọi là  nếu với một đầu vào là hợp số, đầu ra của thuật toán là PRIME. Với thuật toán , giả sử  là một hợp số, thuật toán sẽ trả lại PRIME nếu số  lựa chọn ngẫu nhiên trong thuật toán thỏa mãn . Tồi tệ hơn nữa, tồn tại những hợp số  (gọi là số ) thỏa mãn tính chất: với mọi số , . Do đó, thuật toán  chỉ trả lại COMPOSITE khi . Tuy nhiên, các ước số của  cũng là những số lớn thì xác suất chọn được số nguyên  có  rất nhỏ. Tóm lại, nếu   là số Carmichael thì thuật Fermat có lỗi khá cao. May mắn là số lượng các số Carmichael  (so với ), do đó, thuật toán   vẫn được sử dụng trong một số ứng dụng.Ngược lại, nếu  không phải là số Carmichael, thuật toán  trả lại kết qủa đúng với xác xuất khá cao:   Do đó, bằng cách thực hiện lặp lại thuật toán  10 lần, xác suất lỗi của thuật toán chỉ còn .  



Thuật toán Miller-Rabin có độ chnh xác khá cao ngay cả khi đầu vào là số Carmichael. Thuật toán được xây dựng dựa trên định lí sau:  hoặc  Tồn tại  thỏa mãn  và 
 
: Gọi số nguyên  là căn bậc 2 đồng dư của  modulo  nếu . Nếu  là một số nguyên tố, ta có thể dễ dàng chứng minh được  là căn bậc 2 đồng dư duy nhất của  modulo . Gọi , ta có:  Gọi  là số nhỏ nhất sao cho . Số  tồn tại vì . Theo phương trình , ta có  và do đó, .  Từ đó ta suy ra Theorem 3.Gọi  là một bằng chứng (witness) cho biết  là hợp số nếu cả  và  trong Theorem 3 đều không thỏa mãn. Với bằng chứng  và số nguyên , thủ tục () sẽ trả về COMPOSITE nếu  là bằng chứng cho biết  là hợp số và trả về PRIME nếu ngược lại. Giả mã của thuật toán Miller-Rabin kiểm tra tính nguyên tố như sau:    Code của giả mã bằng C:Trong giả mã trên,  chỉ phụ thuộc vào . Do đó, bạn có thể tiết kiệm bộ nhớ một chút bằng cách sử dụng hai biến  thay vì cả mảng . Thủ tục  thực hiện  thao tác bít để tách .  Thủ tục  sử dụng  phép nhân hai số  bít và  phép toán cơ bản. Do , ta suy ra:  Ví dụ:  là số Carmichael, hãy xem thuật toán Miller-Rabi thực hiện như thế nào. Trước hếtt tách , do đó . Giả sử , ta có: Do , thuật toán Miller-Rabin sẽ trả lại 
 Theo Theorem 3, thuật toán Miller-Rabin luôn trả lại  nếu đầu vào  là số nguyên tố. Cũng như thuật toán Fermat, thuật toán Miller-Rabin cũng có lỗi nếu đầu vào là hợp số. Tuy nhiên, ngay cả khi đầu vào  là số Carmichael, thuật toán Miller-Rabin có lỗi khá nhỏ. Do đó thuật toán này thường được sử dụng trong thực tế để kiểm tra tính nguyên tố của một số nguyên.    
Về mặt lý thuyết có thể chứng minh được xác suất lỗi của thuật toán Miller-Rabin trong Theorem 5 là . Tuy nhiên chứng minh sẽ phức tạp hơn. : Xét  số sau:  Giả sử tồn tại hai số  sao cho  . Do  là một số nguyên tố, ta suy ra  hoặc . Cả hai trường hợp đều không thể xảy ra. Từ đó suy ra không có hai số nào trong  số trên đồng dư. Do đó, số dư của dãy số trên khi lấy modulo  là hoán vị của . Do đó:



 Từ đó suy ra định lý Fermat. Một   là một cấu trúc đại số gồm một tập hợp  và một phép toán  kết hợp hai phần tử của  tạo ra một phần tử thứ 3 thỏa mãn 4 tiên đề sau:Ví dụ  với  là một nhóm. Bạn có thể kiểm tra 4 tiên đề của phép  thao tác trên tập hợp các số nguyên. Chú ý:  với  không phải là một nhóm vì  có phần tử nghịch đảo là . Một nhóm  được gọi là hữu hạn nếu số lượng các phần tử của , thường gọi là bậc của nhóm v kí hiệu là , hữu hạn. Một nhóm  là một nhóm con của  nếu hai phép toán thao tác trên  hai tập này là một và . Định lý nổi tiếng Largrange cho biết mối quan hệ giữa bậc của một nhóm và bậc của nhóm con của nó:  divides   Ví dụ:   là nhóm con của chính nó. Ví dụ khác:  trong đó  là một nhóm con của . Gọi  là tập các số nguyên tố cùng nhau với  và nhỏ hơn . Phép nhân đồng dư  định nghĩa trên trên  như sau: với ,  là tích của  lấy đồng dư modulo . Ta sẽ chứng minh:   là một nhóm với . Ta kiểm tra 4 tiên đề của nhóm: 3 tiên đề đầu không khó để kiểm tra và coi như bài tập cho bạn đọc. Với tiên đề cuối cùng, gọi  là một phần tử của . Do , theo , tồn tại hai số nguyên  sao cho . Suy ra, , do đó,  là phần tử nghịch đảo của . Từ đoạn này về cuối, ta chỉ xét nhóm  và các nhóm con của nó. Để đơn giản, ta sẽ bỏ toán tử trong kí hiệu của nhóm, i.e,  sử dụng luôn kí hiệu tập hợp  thay cho .: Nếu , thuật toán Fermat sẽ trả lại . Phép kiểm tra ước chung lớn nhất chỉ thực sự hiệu quả (xác xuất tìm được số  như vậy ) khi  là số chẵn. Do đó, hiệu quả của thuật toán Fermat nằm ở bước kiểm tra . Số  ngẫu nhiên sau bước kiểm tra ước chung lớn nhất với  sẽ là một phần tử của nhóm . Giả sử  là một hợp số và không là số Carmichael. Thuật toán Fermat sẽ trả lại  (có lỗi)  nếu số  chọn ngẫu nhiên thỏa mãn: . Gọi . Nhận thấy  (coi như bài tập cho bạn đọc) là một nhóm con của  (với phép nhân đồng dư module ). Do  không phải là số  Carmichael,  là một nhóm con đúng của  (). Theo định lý Lagrange,  là một ước số của , do đó, . Từ đó suy ra xác xuất có lỗi của thuật toán Fermat là:   Ta chỉ cần chứng minh Theorem 5 với trường hợp  là số Carmichael vì phép thử Fermat là một thủ tục con của thuật toán Miller-Rabin. Trước hết ta chứng minh:: Không có số Carmichael có dạng  với  và  là một số nguyên tố. Thật vậy, giả sử Claim 1 là sai, i.e, tồn tại số Carmichael có dạng . Nhóm  có bậc  trong đó  là . Từ đó suy ra  vớ mọi . Do  là số Carmichael, , từ đó suy ra: . Tuy nhiên, điều này là không thể vì  chia hết  cho  còn  thì không. Do đó Claim 1 là đúng.Như vậy,  không phải là lũy thừa của một số nguyên tố. Gọi  là một  nếu tồn tại  sao cho . Định nghĩa . Ta sẽ chứng minh:: Nếu  là một hợp số lẻ và không phải là lũy thừa của một số nguyên tố thì  là một nhóm con đúng của .Ta sẽ tìm một số  mà . Trước hết ta có thể kiểm tra (coi như bài tập cho bạn đọc) các tiên đề của nhóm đối với . Vì  là một hợp số lẻ và không phải là lũy thừa của một số nguyên tố, tồn tại  lẻ, nguyên tố cùng nhau, sao cho . Vì  là một số mũ tồi, tồn tại  sao cho . Áp dụng Chinese Remainder Theorem, ta tìm được  sao cho: \begin{array}{lcl} b & \equiv & a  \mod N_1 \\ b & \equiv  & 1 \mod N_2 \end{array} Từ đó ta suy ra  và . Nếu , ta có . Ta có hai trường hợp:Do đó, . Như vậy, Claim 2 là đúng. Gọi  với  là số mũ tồi lớn nhất.  tồn tại vì  lẻ và . Giả sử  không phải là bằng chứng cho biết  là hợp số. Gọi  là số trong Theorem 3, có hai trường hợp:Theo Claim 2,  là một nhóm con đúng của , ta có xác suất số ngẫu nhiên  là . Từ đó suy ra Theorem 5.Thông thường trong các ứng dụng, chúng ta phải kiểm tra tính nguyên tố của các số rất lớn. Các số này có số lượng bít biểu diễn lớn, do đó, rất dễ bị hiện tượng tràn số nếu chúng ta thực thi không cẩn thận. Xét trường hợp  là số nguyên 31 bít, khi thực hiện tính  sử dụng thủ tục () ở trên, chúng ta sẽ phải thực hiên phép nhân  hoặc  với  là các số nguyên 31 bít. Kết quả của các phép nhân này có thể vượt quá 32 bít, và do đó chúng ta sẽ bị tràn số nếu chúng ta sử dụng kiểu  (giả sử bạn sử dụng ngôn ngữ ). Ta có thể giải quyết vấn đề này như sau. Trước hết tính . Sau đó, ta sẽ khai báo một biến kiểu unsigned long long để lưu giữ kết quả của  trước khi lấy . Bạn có thể áp dụng kĩ thuật trên cho .  Tuy nhiên không phải lúc nào chúng ta cũng có thể sử dụng biến kiểu dữ liệu lớn hơn. Giả sử kiểu dữ liệu lớn nhất chúng ta có là  bít (thông thường là 64 bít hoặc 128 bít), trong khi  có kích thước  bít (như trong ). Để tính tích , ta thể sử dụng hai số  bít để lưu trữ tích của hai số  bít trước khi lấy modulo, tuy nhiên ta sẽ phải tự thực hiện phép modulo. May mắn là có một kĩ thuật giúp chúng ta tính  sử dụng các số  bít mà không phải thực hiện lai phép modulo. Tuy nhiên, chúng ta sẽ phải sử dụng  thao tác bít cho phép nhân . Thuật toán như sau: 
Mình khuyến khích bạn đọc thực thi và áp dụng vào bài toán kiểm tra tính nguyên tố . Code cho bài toán này mình đính ở cuối bài. Code: , .
[1] Miller, Gary L.  Journal of Computer and System Sciences 13.3 (1976): 300-317.
[2] Rabin, Michael O.  Journal of Number Theory 12.1 (1980): 128-138.
[3]  Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford. , Chapter 31. MIT Press and McGraw-Hill (2001). ISBN 0-262-03293-7.
[4] James R. Lee, , University of Washington, Winter 2008.  , , , Trackback link:  on                     Chỗ cái hàm FermatTesting, câu return cuối là PRIME bác ad ơi. on                     Đúng rồi bạn. trong code thật mình để Prime. Lỗi đánh máy. Cám ơn bạn đã chỉ ra. Hùng on                     Anh cho em hỏi là, trong research , thì với cùng 1 cài đặt hoàn toàn như nhau, thuật toán ngẫu nhiên có xác suất lỗi <1/2 thì việc chứng minh <1/4 có nhiều ý nghĩa không ạ? Còn trong thực hành thì sao ạ?
Dĩ nhiên là nếu chứng minh được 1/4 thì số lần lặp chỉ cần bằng 1 nửa so với nếu chỉ chứng minh được 1/2. on                     Anh cho em hỏi là trong research, với cùng với cài đặt hoàn toàn như nhau, thuật toán ngẫu nhiên có xác suất lỗi <1/2, thì việc chứng minh tiếp <1/4 có nhiều ý nghĩa không ạ? còn trong thực tế thì sao ạ?
Dĩ nhiên là nếu chứng minh được <1/4 thì số lần lặp chỉ cần bằng một nửa so với chỉ chứng minh được 1/2 on                     Câu hỏi của bạn rất hay. Câu hỏi này để trả lời đầy đủ thì rất dài. Nhưng mình tạm trả lời ngắn gọn như sau:Nếu nói về ý nghĩa thì mình nghĩ là nhiều. Thứ nhất nó làm thay đổi cách hiểu về thuật toán (nếu thực sự xưa nay người ta chỉ mới chứng minh dc 1/2 nhưng có vừa mới có người chứng minh được 1/4). Thứ hai, các phân tích mới thường mang vào những ý tưởng mới hoặc công cụ mới. Các ý tưởng này có thể sẽ mở ra những hướng mới, không chỉ với bài toán hiện tại mà cả các bài toán liên quan. Trong thực tế thì cac phân tích mới không thay đổi tính chất của thuật toán hiện tại, nhưng nó thay đổi cách mà chúng ta nghĩ về nó và ứng dụng nó. Ví dụ anh A nghĩ ra một thuật toán A đơn giản, với xác suất 1/2, và có thể 1/4 nhưng chưa ai chứng minh được, còn anh B nghĩ ra thuật toán B, có thể chậm hơn 1.5 lần, nhưng đảm bảo xác suất 1/4.  Nếu cài đặt thì có thể bạn sẽ chọn A hoặc B tùy vào bài toán. Nhưng nếu anh C chứng minh được thuật toán anh A có xác suất 1/4 thì có lẽ chả có lí do gì mà bạn chọn B cả. Hùng on                     Vâng ạ, cám ơn a đã giải đáp rõ ràng ạ. on                     Đối với code C cần highlight, bạn có thể dùng trang , tạo file .c và lấy link nhúm ở phần embed on                     Cám ơn bạn đã gợi ý. Thực ra C code không phải là trọng tâm. Chủ yếu là mình minh họa cho một số bạn chưa quen nhiều với lập trình. Còn các bạn đã quen thì hiểu ý tưởng là các bạn đã code được rồi.Powered by  and 