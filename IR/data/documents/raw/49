Bảng băm và các cơ chế giải quyết xung đột cơ bản -- Hashing and  collision  handling
http://www.giaithuatlaptrinh.com/?p=967
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Bài này mình lượt qua cấu trúc dữ liệu bảng băm (hash table), hàm băm (hash functions) và một số cơ chế giải quyết xung đột (collision handling). Mục tiêu của bài này là đưa ra một cách nhìn tổng quan về cách thức thiết kế bảng băm. Mọi cơ sở toán học mình sẽ viết và link trong các bài sau.
 Một cấu trúc dữ liệu mà chúng ta cũng thường xuyên áp dụng cho thao tác tìm kiếm đó là cây cân bằng (ví dụ  hoặc ).  trong Java chính là sử dụng cây Red-Black để hỗ trợ tìm kiếm. Do tính cân bằng, cấu trúc dữ liệu cây này sẽ cho phép chúng ta thực hiện tìm kiếm trong thời gian . Bảng băm chúng ta sẽ thảo luận trong bài này sẽ cho phép chúng ta thực hiện thao tác tìm kiếm trong thời gian kì vọng . Gọi  là tập  phần tử ta muốn lưu trữ trong bảng băm. Các phần tử của tập hợp mà chúng ta lưu trữ thường từ một tập lớn hơn  mà ta gọi là  (ground set). Tập gốc ta xét ở đây có lực lượng hữu hạn nhưng rất lớn so với  và .  Ví dụ: nếu tập gốc là tập các tên người với tối đa là  kí tự thì kích thước tối đa của tập gốc là  (ta sử dụng bảng chữ cái tiếng Việt). Nếu giả sử tập dữ liệu trong bảng băm là tên của người thực thì con số   lớn hơn rất nhiều so với  (dân số Việt Nam).  Bảng băm là một mảng  có kích thước . Để lưu trữ dữ liệu vào bảng băm, ta sẽ dùng một  (hash function). Một hàm băm:  
 là một ánh xạ gán cho mỗi phần tử của tập   một vị trí trong bảng . Cụ thể, phần tử  sẽ được lưu tại ô  của bảng và ta nói  được băm vào vị trí  và  được gọi là  (hash code) của .  Xem hình minh họa dưới đây.Hai thao tác chính của bảng băm đó là: đưa một phần tử mới vào bảng băm và tìm xem một phần tử có nằm ở trong bảng băm hay không. Giả mã:  Do  lớn hơn , theo nguyên lí , một hoặc nhiều phần tử của tập  có thể sẽ được băm vào cùng một vị trí của bảng. Ta gọi hiện tượng đó là  (collision). Do xung đột làm quá trình tìm kiếm trở nên phức tạp hơn, ta sẽ cần một chiến lược để đối phó với nó mà ta gọi là chiến lược giải quyết xung đột. Trước khi thảo luận các cách chiến lược này, ta sẽ thảo luận về cách chọn hàm băm trước vì xung đột nhiều hay ít đều phụ thuộc vào hăm băm mà ta chọn.Tuy xung đột không thể tránh được, ta có thể làm giảm được xung đột bằng cách chọn một hàm băm tốt. Chú ý ta chỉ lưu  phần tử của tập gốc vào bảng. Do ta có thể không có bất kì thông tin nào về các phần tử mà ta sẽ lưu trong bảng, ta  chọn một hàm băm  tất định được vì theo nguyên lí nhốt chim, với bất kì hàm băm  nào, ít nhất   phần tử trong tập  sẽ có cùng một mã băm. Do đó, nếu  phần tử của tập hợp ta muốn lưu trong bảng đều có cùng mã băm thì sẽ là một điều vô cùng tồi tệ. Đây chính là lúc ta cần đến . Thay vì sử dụng một hàm băm cố định, ta sẽ chọn ra ngẫu nhiên một hàm băm  từ một họ các hàm băm  mà ta thiết kế từ trước sao cho khi chọn ngẫu nhiên như vậy, xác suất đụng độ là nhỏ: 
 Ta dùng dấu xấp xỉ ở trên vì các phân tích dưới đây sẽ không thay đổi nhiều nếu thay 1 bằng một hằng số  bất kì.  (băm nhân-multiplicative hashing) Ta chọn một số nguyên tố  lớn hơn   và định định nghĩa: 
 Họ hàm băm ta xây dựng là . (băm nhân nhị phân-binary multiplicative hashing)  Gọi  là số nguyên dương nhỏ nhấ tsao cho  . Chọn . Với mỗi số nguyên dương   không lớn quá , ta định nghĩa: 
 Họ hàm băm ta xây dựng là . Trong bài , nếu chọn ngẫu nhiên một hàm băm  (hoặc ) từ  ( hoặc từ ) để thực hiện băm thì xác suất đụng độ sẽ là cỡ .Hàm băm tốt, bên cạnh tính chất làm giảm sự đụng độ, phải là một hàm có thể nhanh chóng tính được mã băm với một khóa cho trước. Rõ ràng một hàm băm có xác xuất đụng độ nhỏ nhưng mỗi lần tính mã băm của một khóa mất đến vài giây thì ta không nên chọn. Do đó, việc thiết kế hàm băm tốt sẽ là một bài toán cực kì khó. Trong hai  họ hàm băm ở hai ví dụ trên, họ hàm băm trong ví dụ 2 có thể được tính nhanh hơn rất nhiều họ hàm băm trong ví dụ 1 vì các thao tác mod và chia đều được thực hiện tương đương bằng thao tác  và dịch phải (shift-right):  Xem thêm tại các . Có lẽ nhiều bạn đọc biết một cách chọn hàm băm rất phổ biến đó là . Như đã nói ở trên, đây là một ý tưởng tồi tệ vì hàm băm này là một hàm băm tất định. Nếu các khóa đều có cùng đồng dư với  thì đụng độ sẽ rất lớn.   của Java jdk-7 sử dụng hàm băm này   với . Ưu điểm khi chọn  chính là: , do đó, hàm băm được tính rất hiệu quả bằng các phép toán bit. Điểm yếu, như đã nói ở trên, là nếu các giá trị đầu vào có cùng  bít cuối (cùng đồng dư với ) thì sẽ được băm vào cùng một vị trí. Để tránh điều này, trước khi băm, HashMap của java sẽ dùng một hàm để "băm lại" hashcode đầu vào. Mục đích của băm lại là làm cho đầu vào trông giống ngẫu nhiên.  Dù như vậy thì về mặt lý thuyết, đây cũng không phải cách tốt. Bạn đọc nếu có sử dụng HashMap của Java thì cũng nên biết rõ những vấn đề này. Tóm lại hai điều cần nhớ khi thiết kế hàm băm tốt:Giả sử ta đã có một hàm băm tốt (thỏa mãn ), sau đây ta sẽ thảo luận các chiến lược giải quyết xung đột.Ta sẽ nghiên cứu ba phương pháp giải quyết xung đột chủ yếu: xích ngăn cách (separate chaining), băm địa chỉ mở (open addressing) và băm hoàn hảo (perfect hashing). Đây có lẽ là cách thức giải quyết xung đột đơn giản nhất và trực quan nhất. Ta sẽ dùng một danh sách liên kết, gọi là xích ngăn cách, để liên kết các phần tử có cùng mã băm (xem hình dưới đây). HashMap trong Java sử dụng ý tưởng này.  Giả mã:  
Code C:   Gọi  là biến ngẫu nhiên chiều dài của danh sách chứa khóa . Trong bài cơ sở toán học của , ta sẽ chứng minh:   Như vậy, theo , kì vọng thời gian để tìm kiếm một số  tỉ lệ với hệ số tải . Điều này cũng khá trực quan vì nếu bảng càng lớn thì khả năng đụng độ càng nhỏ. Hệ số tải mặc định trong HashMap của Java là 0.75. Phương trình  cho chúng ta biết kì vọng chiều dài của danh sách   là  (giả sử hệ số tải là ). Tuy nhiên, mình muốn lưu ý bạn đọc,  trong tất cả các danh sách của bảng là cỡ  (chứng minh  sử dụng mô hình ném , chi tiết bạn đọc xem thêm tại bài cơ sở toán học của xích ngăn cách). Điều đó cho thấy trong trường hợp xấu nhất, ta có thể phải trả một thời gian tìm kiếm xấp xỉ . May mắn là sẽ không có nhiều danh sách trong bảng có chiều dài lớn như vậy vì kì vọng chiều dài chỉ là hằng số mà thôi.Một ý tưởng khác để giảm chiều dài của danh sách dài nhất đó là sử dụng hai hàm băm  để băm vào hai vị trí khác nhau của bảng. Trong hai danh sách , nếu danh sách nào ngắn hơn thì ta sẽ đặt phần tử  vào đó. Khi tìm kiếm thì ta phải duyệt cả hai danh sách để tìm. Cũng theo mô hình ném bóng vào rổ (phân tích phức tạp hơn rất nhiều, xem thêm tại bài cơ sở toán học của xích ngăn cách), danh sách dài nhất có kì vọng chiều dài cỡ . Hàm này gần như có thể coi là hằng số.Trong phương pháp giải quyết xung đột bằng xích ngăn cách, khá nhiều ô của bảng rỗng trong khi một số ô khác lại chứa khá nhiều phần tử. Ngoài ra, ta cần duy trì một danh sách các con trỏ để liên kết các phần tử lại với nhau. Các liên kết này đương nhiên là sẽ tốn thêm bộ nhớ.Ý tưởng của  (open addressing) là mỗi ô của bảng chỉ lưu , do đó ta không cần danh sách móc nối. Chú ý:  Xung đột sẽ được băm địa chỉ mở giải quyết bằng cách sử dụng  hàm băm độc lập , sao cho: Khi băm một khóa , ta sẽ lần lượt kiểm tra  từ ô  của bảng cho đến . Nếu tìm thấy một ô trống đầu tiên thì lưu  vào đó. Do   là một hoán vị của , quá trình tìm kiếm ô trống luôn kết thúc sau tối đa  bước. Giả mã: Hình ví dụ dưới đây minh họa băm 4 khóa vào bảng  sử dụng địa chỉ mở. Ngay lần đầu tiên băm khoá "Huy" sử dụng , ta tìm được ô trống, do đó, ta đặt khóa "Huy" vào ô trống này. Khi băm khóa "Hà" lần đầu tiên (sử dụng ) vào ô 7, ta thấy ô này đã có khóa. Do đó, ta băm lần hai (sử dụng ) vào ô  5. Ô 5 cũng đã có khóa, do đó, ta phải băm lần ba (sử dụng ) vào ô 2. Vì ô 2 trống, ta đặt khóa "Hà" vào đó. Hình  chính là trạng thái của bảng băm sau khi đã băm 4 khóa.Để tìm kiếm bảng băm địa chỉ mở ta sẽ thực hiện dò bảng (probing): bắt đầu từ vị trí  cho đến vị trí . Nếu  có trong bảng thì ta sẽ tìm được  ở một ô  nào đó. Nếu  không chứa trong bảng, trong quá trình dò, ta sẽ bắt gặp một ô rỗng hoặc duyệt qua đến  mà vẫn chưa tìm được . Giả mã: 
Code C:Trong phần cơ sở toán học của băm địa chỉ mở (), ta sẽ chứng minh hai định lý sau:      
 Hai định lý trên cho chúng ta biết thời gian  khi dò một khóa trong bảng. Tuy nhiên, trong trường hợp xấu nhất, số phép dò kì vọng là . Chúng ta sẽ tìm hiểu thêm tại phần cơ sở toán học.Trong thực tế, việc thiết kế  hàm băm ngẫu nhiên  thỏa mãn mã băm đôi một khác nhau với một khóa cho trước là việc vô cùng khó. Cho dù ta có thực hiện được thì chi phí thời gian có lẽ cũng không nhỏ. Do đó, trong thực tế, ta chấp nhận các hàm băm "phụ thuộc" với nhau ở một mức độ nào đó, mỗi mức độ cho chúng ta một phép dò khác nhau. Ta sẽ nghiên cứu: dò tuyến tính, dò nhị phân, dò bậc hai và băm kép.Trong phép dò tuyến tính (linear probing), ta sẽ chỉ sử dụng  hàm băm tốt  để định nghĩa  hàm băm như sau:  Điểm mạnh của phương pháp dò tuyến tính này là thực thi đơn giản. Tuy nhiên, các giá trị băm sẽ có xu hướng tụm lại với nhau thành một dãy con liên tục của . Ngoài ra, khi hệ số tải gần bằng 1 thì tìm kiếm với dò tuyến tính cực kì kém hiệu quả.  Dò nhị phân (binary probing) vừa lợi dụng điểm mạnh của dò tuyến tính, vừa có thể tính nhanh được trong thực tế. Như đã nhắc đến ở trên, chọn  cho phép chúng ta chuyển các thao tác nhân, chia, mod về các thao tác xử lí bít. Do đó, ta có thể tính được hàm băm rất nhanh.  Dò nhị phân cũng sử dụng tư tưởng này. Chọn  và sử dụng một hàm băm tốt  để định nghĩa  hàm băm:  
Trong đó  là phép XOR bít.Tương tự như trong phép dò tuyến tính, nhưng thay vì sử dụng hàm tuyến tính, trong phép dò bậc hai (quadratic probing), ta sẽ dùng hàm bậc 2 để thiết kế  hàm băm :  Phương pháp dò bậc hai về mặt lý thuyết tốt hơn dò tuyến tính. Ta sẽ đi sâu chi tiết trong bài sau.Băm kép (double hashing) sử dụng hai hàm băm độc lập  để định nghĩa  hàm băm :  Cũng như dò bậc hai, phương pháp này tốt hơn về mặt lý thuyết. Tuy nhiên, trong thực tế, phương pháp này sẽ hơi chậm hơn.Như chúng ta thảo luận ở phần xích ngăn cách, mặc dù kì vọng thời gian tìm kiếm là  (giả sử hệ số tải là hằng số), trong trường hợp xấu nhất, thời gian tìm kiếm có thể lên tới  gần xấp xỉ . Đôi khi  là một con số không hề nhỏ. Ta có thể làm giảm hiệu ứng xấu nhất đó bằng cách giảm hệ số tải (tăng kích thước của bảng băm). Giả sử chúng ta sử dụng bảng băm với số lượng ô . Ta sẽ chứng minh ngắn gọn, nếu ta chọn như vậy, số lượng đụng độ chỉ là hằng số. Nếu số lượng đụng độ là hằng số thì đương nhiên danh sách dài nhất trong bảng cũng có kì vọng chiều dài là hằng số.Gọi  là biến ngẫu nhiên 0/1 trong đó  nếu hai khóa  xảy ra đụng độ, i.e, , và  nếu ngược lại. Theo , . Gọi  là tổng số đụng độ trong bảng băm. Ta có:  Do   là biến ngẫu nhiên 0/1, . Ta có:  Tuy nhiên,  là một con số quá lớn và không thực tế. Tưởng tượng ta chỉ băm 1000 phần tử mà cần tới 1 triệu bộ nhớ. Băm hoàn kết hợp cả nhận xét trên và ý tưởng của xích ngăn cách để làm giảm thời gian tìm kiếm xấu nhất xuống  mà bảng chỉ cần bộ nhớ  (nó được gọi là băm hoành hảo là vì thế). Băm hoàn hảo sẽ  sử dụng hai hàm băm tốt  và bảng băm hai chiều . Mỗi hàng của bảng băm  sẽ được coi như một bảng băm phụ, có kích thước phụ thuộc vào đầu vào. Khi băm vào bảng, ta thực hiện băm theo 2 pha: Pha đầu tiên, sử dụng  để băm  vào   của bảng . Gọi  là số lượng phần tử được băm cùng vào hàng thứ  sau pha đầu tiên. Trong pha thứ 2, với mỗi hàng , ta cấp phát một bộ nhớ  cho hàng . Sau đó, ta coi hàng này như một bảng băm và dùng  để băm các phần tử  có cùng mã băm  vào ô  của hàng này. Đụng độ lần 2 này sẽ được giải quyết sử dụng xích ngăn cách. Xem hình minh họa dưới đây. Như phân tích ở trên, do bảng băm phụ này có kích thước là bình phương số lượng phần tử được lưu trong hàng, đụng độ khi băm lần 2 này là . Do đó, tìm kiếm có thể được thực hiện trong . Một điểm cần lưu ý nữa là kích thước của các bảng băm con tương ứng với các hàng khác nhau có thể khác nhau. Cụ thể, bảng băm con thứ  (là ) có kích thước . Do đó, khi băm vào bảng băm con  trong pha 2 sử dụng hàm băm , địa chỉ thực sự trong bảng băm con là .Giả mã: 
Để tìm một khóa , theo định nghĩa, khóa này nằm trong danh sách . Do đó, ta chỉ cần duyệt qua danh sách đó. Theo phân tích ở trên, thời gian duyệt qua danh sách trong trường hợp xấu nhất là . 
Code C:Vấn đề quan tam còn lại của chúng ta là bảng băm hoàn hảo sẽ cần dùng đến bao nhiêu bộ nhớ.  Trong phần cơ sở toán học của băm hoàn hảo , chúng ta sẽ chứng minh kì vọng bộ nhớ của băm hoàn hảo là  khi :   Chúng ta đã tìm hiểu 3 phương pháp chính để giải quyết xung đột: xích ngăn cách, địa chỉ mở và băm hoàn hảo. Trong thực tế thiết kế bảng băm,iên ta nên chọn phương pháp nào? Sau đây là một số yếu tố có thể giúp ta chọn được phương án giải quyết xung đột tốt nhất.Trong các ứng dụng mà chúng ta phải thường xuyên thêm và xóa phần tử khỏi bảng, xích ngăn cách sẽ là một lựa chọn tốt. Băm hoàn hảo, bên cạnh việc khó thực thi, có lẽ không phù hợp với các ứng dụng này. Như mô tả ở trên, khi băm trong pha 2, chúng ta cần phải biết trước số lượng phần tử xung đột trong một ô để cấp phát bộ nhớ. Việc cấp phát này sẽ rất mất thời gian nếu ta liên tục thêm và xóa  phần tử khỏi bảng. Định địa chỉ mở cũng khó áp dụng trong trường hợp này vì nếu hệ số tải lên tới xấp xỉ 1 thì tìm kiếm trong định địa chỉ mở cực kì chậm (xem công thức  và ). Với xích ngăn cách, ngay cả khi , danh sách dài nhất cũng chỉ khoảng . Ngược lại, trong các ứng dụng mà chúng ta chủ yếu thực hiện tìm kiếm, ít khi phải thêm hay xóa phần tử khỏi bảng (ví dụ ứng dụng từ điển chẳng hạn) thì băm hoàn hảo sẽ là một lựa chọn tốt. Như đã nhắc đến ở trên, băm hoàn hảo có thời gian kì vọng trong trường hợp  cũng chỉ là  và bộ nhớ kì vọng là . Tương tự như băm hoàn hảo, nếu ứng dụng của chúng ta chủ yếu thực hiện tìm kiếm nhưng chúng ta lại có thêm thông tin về tần suất truy nhập khóa, thì ta có thể sử dụng băm địa chỉ mở. Cơ chế của băm địa chỉ mở cho ta thấy các khóa băm càng sớm thì số bước dò trong tìm kiếm càng ngắn. Do đó, ta có thể băm các khóa theo thứ tự giảm dần của tần suất truy nhập. Một điểm chú ý duy nhất với băm địa chỉ mở là không nên để hệ số tải vượt qúa .Trong code dưới đây, mình sử dụng hàm băm nhân nhị phân (họ hàm băm trong ví dụ 2)Code: , , . [1] Donald E. Knuth. , Volume 3: (2nd Ed.) Sorting and Searching. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA, 1998.
[2] Jeff Erickson. . UIUC, 2013.
[3] Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.   (2nd ed.). Chapter 12. McGraw-Hill Higher Education, 2001. , , , , , , , Trackback link: Powered by  and 