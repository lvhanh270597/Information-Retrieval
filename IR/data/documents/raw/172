Cây hậu tố -- Suffix Tree
http://www.giaithuatlaptrinh.com/?p=420
Nơi tổng hợp và chia sẻ những kiến thức liên quan tới giải thuật nói chung và lý thuyết khoa học máy tính nói riêng.   in  | Trong bài trước ta đã tìm hiểu các thuật toán tìm kiếm xâu với thời gian  trong đó  là độ dài của văn bản và  là độ dài của xâu tìm kiếm. Mỗi thuật toán có đặc tính và ứng dụng riêng [2]:  là thuật toán tìm kiếm tuyến tính đơn giản nhất,  là thuật toán có thời gian sublinear trong thực tế,  có ý nghĩa về mặt lịch sử cũng như ý tưởng của thuật toán và thuật toán này còn có thể được mở rộng ra trong trường hợp thời gian thực và tìm kiếm một tập nhiều mẫu,  được  trong phát hiện đạo văn.  Tuy nhiên, tất cả các thuật toán này đều rất khó mở rộng khi chúng ta muốn thực hiện các truy vấn (query) văn bản. Một số truy vấn thường gặp như: 
Ngoài hai truy vấn cuối cùng, các truy vấn còn lại có thể được thực hiện lặp đi lặp lại với các xâu mẫu  khác nhau. Ta có thể tưởng tượng trong thực tế văn bản  có kích thước lớn còn xâu mẫu  có kích thước nhỏ. Do đó, một truy vấn có thể coi là  nếu thời gian thực hiện truy vấn chỉ phụ thuộc vào độ dài của , không phụ thuộc vào độ dài của . Phương pháp đầu tiên chúng ta có thể nghĩ tới đó là tìm một cách biểu diễn  sao cho việc thực hiện các truy vấn được thực hiện hiệu quả. Thời gian để biểu diễn  sẽ được tính vào thời gian tiền xử lí. Thông thường, thời gian tiền xử lí là khá lớn. Cây hậu tố (suffix tree), được đề xuất bởi Weiner [1] vào năm 1973, là một trong những cách biểu diễn có thể trả lời  các truy vấn trên một cách hiệu quả. Điều đặc biệt là cây hậu tố có thể được xây dựng trong thời gian .  Knuth, theo , đã gọi thuật toán xây dựng cây hậu tố của Winer là "giải thuật của năm 1973". 
Ví dụ: , hình dưới đây biểu diễn cây hậu tố  với 6 nút lá.

Một điều đặc biệt chú ý là . Ví dụ  không có cây hậu tố biểu diễn nào thỏa mãn 5 tính chất ở trên (mình khuyến khích bạn đọc nên thử xây dựng). Lí do (sau khi bạn thử xây dựng  bạn sẽ thấy)   không có cây hậu tố tương ứng là vì hậu tố  là tiền tố của hậu tố . Tổng quát hóa ta sẽ thấy:   có cây hậu tố biểu diễn nó khi và chỉ khi  có một hậu tố là tiền tố của một hậu tố khác.Do đó, để đảm bảo ta luôn có thể xây dựng được cây hậu tố cho mọi văn bản đầu vào, ta sẽ thêm kí tự $ không thuộc bảng chữ cái vào cuối của văn bản . Dễ thấy sau khi thêm $, trường hợp của nhận xét trên không bao giờ xảy ra. Từ đoạn này trở đi của bài viết, ta luôn giả sử $. Ta sẽ biểu diễn cây hậu tố dưới dạng cấu trúc cây. Về cơ bản, mỗi nút của cây hậu tố sẽ có các thông tin sau: Nếu có các thông tin khác lưu trữ để tăng tốc thuật toán xây dựng thì chúng ta sẽ bổ sung sau.Hậu tố  với  được gọi là hậu tố thứ  của  và kí hiệu là . Với mỗi nút  của cây hậu tố ,  là xâu con thu được bằng cách ghép (concatenation) các xâu con của các cạnh trên đường đi từ nút gốc đến  của . Độ dài của xâu  được gọi là string depth và kí hiệu là  ( là viết tắt của string depth).  Giả sử chúng ta đã xây dựng được cây hậu tố cho . Sử dụng cây hậu tố, ta có thể trả lời một số truy vấn ở trên như sau:Giả mã của các truy vấn này được cho ở phần phụ lục ở cuối bài. Dưới đây, chúng ta giới thiệu thuật toán đơn giản với thời gian  xây dựng cây hậu tố.  Bài tiếp theo chúng ta sẽ làm quen với thuật toán .Ta lần lượt xây dựng cây hậu tố bằng cách chèn lần lượt các hậu tố , trong đó  là hậu tố thứ  của , vào cây hậu tố hiện tại. Cây hậu tố  chỉ có 1 nút lá (và một nút gốc) biểu diễn hậu tố . Tại bước thứ , thuật toán chèn hậu tố  vào cây hậu tố hiện tại . Để chèn hậu tố  vào cây hậu tố hiện tại , ta sẽ:Ví dụ  Cây hậu tối khi chèn  và  lần lượt tương ứng với trường hợp (I) và (II) sẽ như ở hình vẽ sau:
 Giả mã của thuật toán như sau:      
Code của giả mã bằng C. Code đầy đủ được đính ở cuối bài. Trước hết ta phân tích xem cây hậu tố ở trên có tối đa bao nhiêu nút. Dễ dàng thấy số nút lá của cây hậu tố là , bằng kích thước của văn bản đầu vào, vì mỗi nút lá ứng với một hậu tố. Trong quá trình xây dựng cây hậu tố, một nút trong chỉ xuất hiện khi chèn thêm một hậu tố mới. Do đó, số nút trong của cây không thể vượt quá  là số nút lá. Do đó, cây hậu tố có tối đa  nút. Nếu biểu diễn con trỏ tới các nút con bằng mảng như thực hiện ở trên, thì cần  con trỏ cho mỗi nút trong của cây. Do đó, mỗi nút chiếm bộ nhớ là  để biểu diễn và tổng bộ nhớ cần để biểu diễn cây là . Tuy nhiên, nếu ta biểu diễn con trỏ tới các nút con là một danh sách, thì số lượng con trỏ của tất cả các nút trong không lớn hơn số cạnh của cây hậu tố. Vì cây hậu tố có tối đa  nút, nó sẽ có tối đa  cạnh và do đó số con trỏ đó không quá . Như vậy, bộ nhớ để biểu diễn cây trong trường hợp này là .Về mặt thời gian, có thể thấy rằng thuật toán xây dựng cây hậu tố trong  bước. Bước thứ  tìm kiếm hậu tố  trong cây hậu tố đang xây dựng hiện tại. Bước này sử dụng  (là chiều dài của hậu tố ) phép so sánh để tìm kiếm. Do đó, tổng thời gian của thuật toán là . Code của giả mã bằng C: 
Code của giả mã bằng C:Như đã nhắc đến ở trên, để thực hiện truy vấn này, với mỗi nút , chúng ta lưu thêm một trường  lưu số lượng nút lá của cây con gốc . Thông tin này có thể được cập nhật trong quá trình xây dựng cây mà không làm giảm thời gian tiệm cận xây dựng cây.   
Code của giả mã bằng C:Để thực hiện truy vấn này, với mỗi nút , chúng ta lưu thêm một trường  lưu string depth của nút . Thông tin này có thể được cập nhật trong quá trình xây dựng cây mà không làm giảm thời gian tiệm cận xây dựng cây.    
Code của giả mã bằng C: 
Code của giả mã bằng C:Code: . [1] Weiner, Peter.  Switching and Automata Theory, 1973. SWAT'08. IEEE Conference Record of 14th Annual Symposium on. IEEE, 1973.
[2] Gusfield, Dan. . Cambridge university press, 1997.
[3]  Carl Kingsford. . CMSC 423, CMU.[] Hậu tố của một xâu  là một xâu con của  có dạng  với  là một số nào đó thỏa mãn . Ví dụ  thì  là một hậu tố của . Chú ý  là hậu tố của chính nó. [] Một hậu tố của  được gọi là một hậu tố riêng (proper suffix) nếu hậu tố đó khác .  , , Trackback link: Powered by  and 