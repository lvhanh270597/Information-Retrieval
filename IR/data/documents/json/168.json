{"content": "Bài viết gốc : Mathematics for_Topcoders - đăng bởi dimkadimon trên Topcoder Giới_thiệu : Nhiều người thi Topcoder phàn_nàn khi trong đề có quá nhiều Toán – điểm yếu của họ .\nCá_nhân tôi là một người rất yêu_Toán , vì_vậy có_lẽ tôi sẽ có chút thiên_vị trong vấn_đề này .\nNhưng tôi hoàn_toàn tin_tưởng rằng , các bài_tập nên có ít_nhất một_chút Toán_học và Khoa_học máy_tính phải đi liền với Toán_học .\nThật khó có_thể tưởng_tượng khi mà_cả hai lĩnh_vực này cũng tồn_tại mà không_hề có bất_kỳ sự tương_tác nào lẫn_nhau .\nNgày_nay , Toán_học được áp_dụng rất nhiều trong Tin_học để giải những hệ_phương_trình hàng nghìn ẩn hay tìm nghiệm xấp_xỉ đối_với những phương_trình mà không có_công thức nghiệm tổng_quát .\nToán_học còn được sử_dụng rộng_rãi trong việc nghiên_cứu về Khoa_học máy_tính , cũng_như là áp_dụng cho các thuật_toán về đồ_thị ( graph algorithms ) và lĩnh_vực thị_giác máy_tính ( Computer_Vision ) .\nBài viết này sẽ phân_tích về lý_thuyết và ứng_dụng của một_vài cấu_trúc Toán_học phổ_biến .\nCác chủ_đề được đề_cập tới bao_gồm : Số_nguyên_tố .\nƯớc_chung lớn nhất (GCD) .\nHình_học cơ_bản .\nHệ cơ_số .\nPhân_số và số_phức .\nSố_nguyên_tố : Một_số tự_nhiên là số_nguyên_tố khi và chỉ khi nó chỉ chia_hết_cho 1 và chính nó .\nVí_dụ như 2 , 3 , 5 , 79 , 311 và 1931 đều là số_nguyên_tố , trong_khi 21 thì không_phải , bởi nó chia_hết_cho 3 và 7 .\nĐể xác_định xem một_số tự_nhiên n có_phải là số_nguyên_tố hay_không , ta chỉ_cần đơn_giản kiểm_tra xem nó có chia_hết_cho bất_kỳ số nào nhỏ hơn nó và lớn 1 hay_không .\nChúng_ta có_thể sử_dụng phép_chia có_dư (toán tử %) để kiểm_tra khả_năng chia_hết của nó : Java for ( int i = 2 ; i lt; n ; i ++) if ( n % i == 0 ) return false ; return true ; Pascal for i : = 2 to n - 1 do if ( n mod i = 0 ) then exit ( false ); exit ( true ); Chúng_ta còn có_thể làm_cho đoạn mã này chạy nhanh hơn_nữa bằng việc nhận_ra rằng , ta chỉ_cần xét khả_năng chia_hết_cho mọi giá_trị i lớn hơn 1 và nhỏ hơn hoặc bằng với phần nguyên của căn bậc 2 của n , tạm gọi_là m .\nTại_sao lại thế nhỉ ?\nĐấy là bởi_vì nếu n chia_hết_cho bất_kỳ số nào lớn hơn m thì kết_quả nhận được cũng chỉ là một_số nhỏ hơn hoặc bằng m .\nMột cải_tiến nữa_là : ta thấy rằng không tồn_tại bất_kỳ một_số nguyên_tố chẵn nào lớn hơn 2 .\nNhư_vậy , sau khi đã kiểm_tra rằng n là số_lẻ thì ta có_thể an_tâm tăng biến i lên 2 giá_trị .\nĐây sẽ là đoạn mã áp_dụng phương_thức kiểm_tra số_nguyên_tố mới nhất này : Java public boolean isPrime ( int n ) if ( n lt;= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; int m = Math .\nsqrt ( n ); for ( int i = 3 ; i lt;= m ; i += 2 ) if ( n % i == 0 ) return false ; return true ; Pascal function IsPrime ( n : Integer ) : Boolean ; var i : Integer ; m : Integer ; begin if ( n lt;= 1 ) exit ( false ); if ( n = 2 ) exit ( true ); if ( n mod 2 = 0 ) exit ( false ); i : = 3 ; m : = trunc ( sqrt ( n )); while ( i lt;= m ) do begin if ( n mod i = 0 ) exit ( false ); inc ( i , 2 ); end ; exit ( true ); end ; Giả_sử chúng_ta cần phải tìm mọi số_nguyên_tố trong_khoảng 1 , 100000 , thì chẳng_lẽ ta phải gọi hàm kiểm_tra 100000 lần sao ?\nViệc lặp_đi lặp_lại các phép kiểm_tra tương_tự thật_sự không hiệu_quả chút_nào .\nTrong tình_huống này , phương_pháp tối_ưu nhất chính là sử_dụng Sàng nguyên_tố Eratosthenes (Sieve of Eratosthenes) .\nSàng nguyên_tố Eratosthenes sẽ xác_định toàn_bộ những số_nguyên_tố trong_khoảng 2 , n .\nTrước_hết , sàng nguyên_tố sẽ giả_định mọi số_tự_nhiên từ 2 đến n là số_nguyên_tố .\nKế_đến , nó sẽ chọn ra số_nguyên_tố đầu_tiên và xóa đi những bội nhỏ hơn bằng n của số_nguyên_tố đó .\nVà nó lại tiếp_tục quá_trình bằng lựa một_số nguyên_tố tiếp_theo và xóa đi các bội của nó .\nQuá_trình này sẽ tiếp_tục diễn ra cho_đến khi mà mọi số đều đã xử_lý .\nVí_dụ , ta sẽ tìm các số_nguyên_tố trong_khoảng 2 , 20 .\nTrước_hết , ta hãy ghi ra dãy_số đó : 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Bởi_vì 2 là số_nguyên_tố đầu_tiên , nên ta sẽ loại_bỏ đi tất_cả những bội của 2 và nhỏ hơn bằng 20 .\n2 3 5 7 9 11 13 15 17 19 Bởi_vì 3 là số đầu_tiên chưa bị bỏ , nên ta sẽ lựa_chọn 3 là số_nguyên_tố tiếp_theo và loại_bỏ đi tất_cả những bội của 3 và nhỏ hơn bằng 20 .\n2 3 5 7 11 13 17 19 Tiếp đến , ta sẽ chọn 5 , ta thấy không còn bội nào của 5 nhỏ hơn bằng 20 còn sót nên ta lại tiếp_tục xét đến 7 , . . .\nVà giờ thì tất_cả những số còn sót lại chính là các số_nguyên_tố mà ta cần tìm .\nDưới_đây là đoạn mã cho Sàng nguyên_tố Eratosthenes : Java public boolean sieve ( int n ) boolean prime = new boolean n + 1 ; Arrays .\nfill ( prime , true ); prime 0 = false ; prime 1 = false ; int m = Math .\nsqrt ( n ); for ( int i = 2 ; i lt;= m ; i ++) if ( prime i ) for ( int k = i i ; k lt;= n ; k += i ) prime k = false ; return prime ; Pascal //mảng kiểm_tra số_nguyên_tố prime0 . . n function sieve ( n : Integer ) : Boolean ; var i , m : Integer ; begin fillchar ( prime , sizeof ( prime ) , 1 ); prime 0 : = false ; prime 1 : = false ; m : = trunc ( sqrt ( n )); for i : = 2 to m do if ( prime i ) then for j : = i to n div i do prime i j : = false ; end ; Ở đoạn mã trên , ta sẽ tạo một mảng prime , nơi sẽ chứa các giá_trị nguyên trong_khoảng 0 , n .\nPrimei là true nếu i là số_nguyên_tố và ngược_lại .\nVòng_lặp bên_ngoài sẽ tìm_kiếm số_nguyên_tố tiếp_theo , trong_khi vòng_lặp bên_trong sẽ loại_bỏ đi tất_cả những bội nhỏ hơn bằng n của số_nguyên_tố đó .\nƯớc_chung lớn nhất Ước_chung lớn nhất (Greatest Common_Divisor) của hai số_tự_nhiên a và b là số_lớn nhất mà_cả a và b đều chia_hết .\nĐể tìm được GCD(a , b) , một_cách đơn_giản , ta có_thể lấy số nhỏ hơn trong hai số a và b rồi giảm_dần cho_đến khi_nào có được một_số mà_cả a và b đều cùng chia_hết_cho số đó .\nJava for ( int i = Math .\nmin ( a , b ); i gt;= 1 ; i --) if ( a % i == 0 amp;amp; b % i == 0 ) return i ; Pascal for i : = min ( a , b ) downto 1 do if ( a mod i = 0 ) and ( b mod i = 0 ) then exit ( i ); Mặc_dù phương_pháp này đủ nhanh để đáp_ứng phần_lớn các trường_hợp , song ta vẫn còn một_cách nhanh hơn_nữa , đó chính là thuật_toán Euclid .\nThuật_toán Euclid sẽ lặp_đi lặp_lại việc xử_lý hai số cho_đến khi mà phần dư của chúng bằng 0 .\nVí_dụ , giả_sử chúng_ta muốn tìm ước_chung lớn nhất của hai số 2336 và 1314 .\nĐầu_tiên , ta sẽ phân_tích_số lớn hơn_là 2336 thành bội của 1314 cộng thêm cho phần dư .\n2336 = 1314 x 1 + 1022 Ta sẽ thực_hiện tương_tự với 1314 và 1022 .\n1314 = 1022 x 1 + 292 Ta tiếp_tục quá_trình cho_đến khi phần dư bằng 0 .\n1022 = 292 x 3 + 146 292 = 146 x 2 + 0 Và phần dư cuối_cùng mà khác 0 chính là ước_chung lớn nhất mà ta cần tìm .\nVậy ước_chung lớn nhất của 1314 và 2336 chính là 146 .\nThuật_toán trên sẽ được mô_phỏng lại bằng một đoạn mã đệ_quy đơn_giản : Java // giả_định rằng a và b đều khác 0 public int GCD ( int a , int b ) if ( b == 0 ) return a ; return GCD ( b , a % b ); Pascal // giả_định a và b đều khác 0 function GCD ( a , b : Integer ) : Integer ; begin if ( b = 0 ) then exit ( a ) else exit ( GCD ( b , a mod b )); end ; Đặc_biệt , thuật_toán Euclid còn được áp_dụng trong việc tìm bội_chung nhỏ nhất (LCM) của hai số_tự_nhiên .\nVí_dụ , bội_chung nhỏ nhất của 6 và 9 là 18 vì 18 là số nhỏ nhất mà chia_hết_cho cả a lẫn b .\nDưới_đây là đoạn mã cho việc tìm bội_chung nhỏ nhất : Java public int LCM ( int a , int b ) return b a / GCD ( a , b ); Pascal function LCM ( a , b : Integer ) : Integer ; begin exit ( a b / GCD ( a , b )); end ; Một chú_ý cuối_cùng đó là việc thuật_toán Euclid còn có_thể dùng để giải phương_trình tìm nghiệm nguyên Diophantine .\nĐó là những phương_trình có hệ_số và ẩn_số_nguyên (a , b , c , x , y \\in N) và được biểu_diễn như_sau : ax + by = c Xem thêm : Thuật_toán Euclid mở_rộng Hình_học Đôi_khi , bài_toán yêu_cầu ta tìm phần giao của các hình_chữ_nhật với các cạnh song_song trục tọa_độ .\nCó rất nhiều cách để biểu_diễn một hình_chữ_nhật .\nĐối_với hệ trục tọa_độ Cartesian , thì cách biểu_diễn phổ_biến nhất chính là lưu_giữ giá_trị tọa_độ của góc trái - dưới và góc phải - trên của hình_chữ_nhật .\nGiả_sử chúng_ta có hai hình_chữ_nhật R1 và R2 .\nĐặt (x1 , y1) là tọa_độ góc trái - dưới , (x2 , y2) là tọa_độ góc phải - trên của hình_chữ_nhật R1 .\nTương_tự với R2 , ta đặt (x3 , y3) , (x4 , y4) lần_lượt là tọa_độ góc trái - dưới và góc phải - trên của R2 .\nPhần giao của R1 và R2 sẽ là hình_chữ_nhật R3 có tọa_độ trái - dưới là (max(x1 , x3) , max(y1 , y3)) và tọa_độ góc phải - trên là (min(x2 , x4) , min(y2 , y4)) .\nNếu max(x1 , x3) gt; min(x2 , x4) hoặc max(y1 , y3) gt; min(y2 , y4) thì sẽ không tồn_tại hình_chữ_nhật R3 , hay nói các khác là R1 và R2 không giao nhau .\nCông_thức này còn được mở_rộng ra hơn không_gian 2 chiều giống_như là trong bài CuboidJoin (SRM 191 , Div 2 Hard) .\nThường thì , khi làm_bài chúng_ta sẽ phải đối_mặt với những đa_giác mà đỉnh của nó là số_nguyên .\nNhững đa_giác đó được gọi_là Đa_giác lưới (lattice polygon) .\nTrong phần hướng_dẫn cơ_bản về khái_niệm hình_học ( Geometry_Concepts ) , lbackstrom đã trình_bày một_cách ngắn_gọn cách tính diện_tích thông_qua các cạnh của đa_giác .\nBây_giờ , giả_sử_ta không biết được chính_xác vị_trí các cạnh mà thay vào đó ta có được các giá_trị sau : B = số_lượng điểm nằm ở trên cạnh đa_giác (Boundary) I = số_lượng điểm nằm trong đa_giác (Inside) Thật vi_diệu , thông_qua hai giá_trị trên ta có_thể tính được diện_tích đa_giác bằng công_thức sau : Diện_tích = B/2 + I - 1 Công_thức trên được gọi_là định_lý Pick được chứng_minh bởi Georg_Alexander_Pick (1859 – 1943) .\nĐể chứng_minh được rằng định_lý Pick có tính_chất bao_quát cho toàn_bộ mọi đa_giác lưới , ta chứng_minh theo 4 bước : Bước 1 : chứng_minh định_lý Pick đúng_với mọi hình_chữ_nhật lưới , có cạnh song_song với trục tọa_độ .\nBước 2 : chứng_minh được định_lý Pick vẫn đúng_với mọi tam_giác_vuông có hai cạnh song_song với trục tọa_đô (bởi chúng là phân_nửa diện_tích một hình_chữ_nhật lưới có tọa_độ một đỉnh là góc_vuông của tam_giác và có cạnh là các cạnh góc_vuông của tam giác) .\nBước 3 : chứng_minh định_lý Pick đúng_với mọi tam_giác , bởi một tam_giác bất_kỳ đều có_thể biểu_diễn thành một hình_chữ_nhật bằng cách ghép_cặp với một_vài tam_giác_vuông khác .\nBước 4 : ta thấy rằng mọi cặp 2 đa_giác lưới có chung cạnh sẽ tạo_thành một đa_giác lưới khác bằng cách xóa đi cạnh chung , và mọi đa_giác lưới đều có_thể tạo ra bằng cách ghép các hình_tam_giác .\nTổng_hợp lại 4 bước trên và ta sẽ thu được kết_quả rằng định_lý Pick đúng_với mọi đa_giác lưới .\nĐịnh_lý Pick khá hữu_ích khi ta cần tìm số điểm có tọa_độ nguyên bên_trong một đa_giác lớn .\nMột công_thức đáng nhớ khác đó chính là công_thức Euler dành cho các khối đa_diện .\nKhối đa_diện được định_nghĩa_là một khối (một đa giác) mà ta có_thể chia thành nhiều đa_giác nhỏ hơn .\nCác đa_giác nhỏ hơn được gọi_là mặt , cách đỉnh của mặt cũng được gọi_là đỉnh của khối đa_diện và tương_tự , các cạnh của mặt cũng gọi_là cạnh .\nDưới_đây là công_thức Euler .\nV - E + F = 2 , với : V = số đỉnh của khối E = số cạnh của khối F = số mặt của khối Ví_dụ , xét một hình_vuông mà_cả hai đường_chéo đều được vẽ .\nTa sẽ có V = 5 , E = 8 và F = 5 (phần nằm ngoài hình_vuông cũng được coi_như là một mặt) , ta sẽ có V - E + F = 2 .\nTa có_thể sử_dụng quy_nạp để chứng_minh nó như_sau : Ta sẽ bắt_đầu với V = 2 , vì mỗi đỉnh đều cần phải có ít_nhất một cạnh .\nVà nếu V = 2 thì chỉ_có xảy_ra duy_nhất một dạng khối đa_diện mà_thôi .\nĐó là dạng khối đa_diện mà hai cạnh sẽ nối với E đỉnh .\nKhối đa_diện nãy cũng sẽ có E mặt , (E-1 mặt_bên trong hình và 1 mặt ngoài hình) .\nThế nên V - E + F = 2 - E + E = 2 (điều phải chứng minh) .\nGiờ ta giả_sử định_lý Euler đúng_với V từ 2 , n , xét V = n+1 .\nChọn một cạnh w bất_kỳ .\nGiờ giả_định w nối với tất_cả những lưới còn_lại có G đỉnh .\nNếu bỏ_đi cạnh w này và những đỉnh mà nó nối , ta sẽ có_một lưới với n cạnh , E - G đỉnh và F-G+1 mặt .\nTừ giả_định trên ta có : (n) - (E - G) + (F - G + 1) = 2 (n+1) - E + F = 2 Vậy với V = n+1 , ta cũng vẫn thu được kết_quả là V - E + F = 2 .\nVậy là với phương_pháp quy_nạp toán_học , ta đã chứng_minh được định_lý Euler .\nHệ cơ_số : Một trong những bài_toán mà người thi Topcoder đối_mặt nhiều nhất đó chính là việc chuyển_đổi số_từ hệ cơ_số nhị_phân sang hệ cơ_số thập_phân và ngược_lại (cùng với nhiều hệ cơ_số khác) .\nVậy hệ cơ_số nghĩa_là gì ?\nTa sẽ bắt_đầu với hệ cơ_số tiêu_chuẩn (hệ thập phân) .\nXét số 4325 ở hệ cơ_số 10 .\nTa thấy 4325 có_thể phân_tích thành 5 + 210 + 31010 + 4101010 .\nChú_ý rằng mỗi \"giá trị\" của chữ_số tiếp_theo sau của số được nhân thêm tích_số 10 khi ta xét từ phải qua trái .\nHệ nhị_phân cũng hoạt_động theo cách tương_tự như_thế .\nNó sử_dụng hai chữ_số 0 và 1 và \"giá trị\" của từng chữ_số sẽ được nhân thêm 2 khi ta xét từ phải qua trái .\nVí_dụ , số 1011 ở dạng nhị_phân có_thể biểu_diễn thành 1 + 12 + 022 + 1222 = 1 + 2 + 8 = 11 và trở_lại thành số ở hệ_thập_phân là 11 .\nVà đây chính là cách để ta chuyển từ số ở hệ nhị_phân (hoặc bất_kỳ hệ_số nào) về hệ cơ_số thập_phân .\nSau_đây là đoạn mã để chuyển số n từ một hệ cơ_số b (2 \\le b \\le n) thành hệ cơ_số thập_phân .\nJava public int toDecimal ( int n , int b ) int result = 0 ; int multiplier = 1 ; while ( n gt; 0 ) result += n % 10 multiplier ; multiplier = b ; n /= 10 ; return result ; Pascal function ToDectimal ( n , b : Integer ) : Integer ; var mul : Integer = 1 ; begin result : = 0 ; while ( n gt; 0 ) do begin result : = result + ( n mod 10 ) mul ; mul : = mul b ; n : = n div 10 ; end ; end ; Người dùng Java hẳn sẽ rất vui khi biết rằng vẫn có cách khác đơn_giản hơn để thực_hiện việc này .\nreturn Integer .\nparseInt ( \"\" + n , b ); Để chuyển một_số từ hệ_thập phần về hệ nhị_phân cũng khá đơn_giản .\nGiả_sử_ta muốn chuyển số 43 từ hệ_thập_phân về hệ nhị_phân .\nTại bước_đầu của_công thức ta sẽ chia đôi 43 và lưu lại giá_trị phần dư , tiếp_tục xử_lý với số được chia đôi đó cho_đến khi nó bằng 0 .\nVà danh_sách số_dư sau cuối_cùng cũng chính là cách biểu_diễn số nhị_phân cần tìm .\n43/2 = 21 + dư 1 21/2 = 10 + dư 1 10/2 = 5 + dư 0 5/2 = 2 + dư 1 2/2 = 1 + dư 0 1/2 = 0 + dư 1 Vậy 43 sẽ được biểu_diễn thành 101011 ở dạng nhị_phân .\nBằng việc thay số 2 thành số b , ta có_thể chuyển từ hệ_thập_phân về bất_kỳ hệ cơ_số b nào (2) : Java public int fromDecimal ( int n , int b ) int result = 0 ; int multiplier = 1 ; while ( n gt; 0 ) result += n % b multiplier ; multiplier = 10 ; n /= b ; return result ; Pascal function FromDecimal ( n , b : Integer ) : Integer ; var mul : Integer = 1 ; begin result : = 0 ; while ( n gt; 0 ) do begin result : = result + ( n mod b ) mul ; mul : = mul 10 ; n : = n div b ; end ; end ; Đối_với trường_hợp b lớn hơn 10 , ta sẽ xử_dụng các ký_tự không_phải chữ_số để đại_diện cho các số_từ 10 trở_lên .\nVí_dụ , ta sẽ để A đại_diện cho 10 , B cho 11 , . . .\nĐoạn mã sau_đây sẽ cho_phép ta chuyển từ số_thập_phân sang bất_kỳ hệ cơ_số nào (lên đến 20) .\nJava public String fromDecimal2 ( int n , int b ) String chars = \"0123456789ABCDEFGHIJ\" ; String result = \"\" ; while ( n gt; 0 ) result = chars .\ncharAt ( n % b ) + result ; n /= b ; return result ; Pascal function FromDecimal2 ( n , b : Integer ) : String ; var chars : string = 0123456789ABCDEFGHIJ ; begin result : = ; while ( n gt; 0 ) do begin result : = chars n mod b + 1 + result ; n : = n div b ; end ; end ; Trong_Java , ta có_thể sử_dụng những cách tắt sau để chuẩn từ hệ_thập_phân sang như hệ_số thông_dụng khác , như_là hệ nhị_phân , hệ bát phân , hệ_thập lục phân .\nInteger .\ntoBinaryString ( n ); Integer .\ntoOctalString ( n ); Integer .\ntoHexString ( n ); Phân_số và số_phức Phân_số thường được gặp rất nhiều trong các bài_tập .\nThường thì vấn_đề khó_khăn nhất mà ta cần phải đối_mặt đó chính là việc biểu_diễn các phân_số đó .\nMặc_dù nó hoàn_toàn khả_thi trong việc tạo ra một lớp (class) khác để lưu_trữ một_cách đầy_đủ các thông_tin về_phần số , nhưng trong nhiều trường_hợp thì cách thường_dùng nhất_là sử_dụng mảng lưu 2 giá_trị bằng cách ghép_cặp (pair) .\nÝ_tưởng là ta sẽ lưu_số đầu_tiên là tử_số , số thứ_hai là mẫu_số .\nTa sẽ bắt_đầu bằng việc nhân hai phân_số a và b : Java public int multiplyFractions ( int a , int b ) int c = a 0 b 0 , a 1 b 1 ; return c ; Pascal type ps = record x , y : Integer ; end ; function multiplyFractions ( a , b : ps ) : ps ; var c : ps ; begin c .\nx : = a .\nx b .\nx ; c .\ny : = a .\ny b .\ny ; exit ( c ); end ; Cộng phân_số thì_có một_chút phức_tạp hơn , bởi chỉ_có nhưng phân_số có cùng mẫu_số mới có_thể cộng trực_tiếp .\nTrước_hết ta sẽ tìm mẫu_số_chung của hai phân_số và nhân_tử số hai phân_số theo tỉ_số giữa mẫu_số cũ với mẫu_số_chung .\nMẫu_số_chung là số có_thể chia_hết_cho cả mẫu của hai phân_số , hay đơn_giản hơn đó chính là bội_chung nhỏ nhất của hai mẫu_số .\nVí_dụ để cộng hai phân_số 4/9 và 1/6 .\nBội_chung nhỏ nhất của 9 và 6 là 18 .\nĐể chuyển_đổi hai phân_số ta sẽ lấy phân_số thứ nhất nhân cho 2/2 và số thứ_hai cho 3/3 .\n4/9 + 1/6 = (42)/(9 2) + (1 3)/(6 3) = 8/18 + 3/18 Một_khi hai phân_số đã có mẫu_số bằng_nhau , thì ta chỉ_cần đơn_giản cộng hai phân_số đó lại và nhận kết_quả cuối_cùng là phân_số 11/18 .\nTrừ cũng rất đơn_giản , chỉ khác_nhau ở bước cuối_cùng .\n4/9 - 1/6 = 8/18 - 3/18 = 5/18 Đây là đoạn mã cho chương_trình công hai phân_số : Java public int addFractions ( int a , int b ) int denom = LCM ( a 1 , b 1 ); int c = denom / a 1 a 0 + denom / b 1 b 0 , denom ; return c ; Pascal function addFractions ( a , b : ps ) : ps ; var denom : Integer ; begin denom : = LCM ( a .\ny , b .\ny ); result .\nx : = denom div a .\ny a .\nx + denom div b .\ny b .\nx ; result .\ny : = denom ; end ; Cuối_cùng , nó rất cần_thiết để biết được cách tối_giản phân_số_thành phân_số tối_giản .\nVà phân_số chỉ tối_giản khi và chỉ khi ước_chung lớn nhất của tử_số và mẫu_số là 1 .\nChúng_ta sẽ làm như_sau : Java public void reduceFraction ( int a ) int b = GCD ( a 0 , a 1 ); a 0 /= b ; a 1 /= b ; Pascal procedure reduceFraction ( var a : ps ); var b : Integer ; begin b : = GCD ( a .\nx , a .\ny ); a .\nx : = a .\nx div b ; a .\ny : = a .\ny div b ; end ; Bằng phương_pháp tương_tự , ta cũng có_thể biểu_diễn được số_phức .\nMột_cách tổng_quát , số_phức được biểu_diễn dưới dạng a + ib với a , b là số_thực và i là căn bậc hai của -1 .\nVí_dụ , để cộng hai số_phức , ta sẽ cộng đơn_giản như_sau : m + n = (a + bi) + (c + di) = (a + c) + (b + d) Việc nhân hai số_phức cũng tương_tự như việc nhân_số thực , trừ việc ii bằng -1 .\nm n = (a + ib) (c + id) = ac + iad + ibc + (i2)bd = (ac - bd) + i(ad + bc) Bằng việc lưu_trữ phần số_thực ở phần_tử thứ nhất và phần số_phức ở phần_tử thứ_hai trong một mảng hai giá_trị như đoạn mã dưới_đây : Java public int multiplyComplex ( int m , int n ) int prod = m 0 n 0 - m 1 n 1 , m 0 n 1 + m 1 n 0 ; return prod ; Pascal function multiplyComplex ( m , n : ps ) : ps ; begin result .\nx : = m .\nx n .\nx - m .\ny n .\ny ; result .\ny : = m .\nx n .\ny + m .\ny n .\nx ; end ; Tổng_kết : Tổng_kết lại , tôi chỉ muốn nói rằng bạn không_thể đạt rating cao ở Topcoder mà không nắm rõ Toán_học và những thuật_toán nêu trên .\nThường thì một trong những chủ_đề Toán_học thường gặp nhất trong các bài_tập đó là số_nguyên_tố .\nTiếp đó là những bài về hệ cơ_số , mà nguyên_nhân chủ_yếu là_vì máy_tính hoạt_động dựa trên hệ nhị_phân , nên ta cần phải_biết cách chuyển từ hệ nhị_phân về hệ_thập_phân .\nCòn công_thức tính ước_chung lớn nhất (GCD) và bội_chung nhỏ nhất (LCM) thì được dùng nhiều trong cả những bài_tập \"thuần toán\" và cả hình_học .\nCuối_cùng , tôi viết chủ_đề Phân_số và số_phức là việc nó không chỉ_cần thiết cho việc thi Topcoder , mà bởi nó còn vô_cùng quan_trọng khi làm_việc với những con_số .\n\n", "tagged": "Bài/N viết/V gốc/N :/CH Mathematics/Np for_Topcoders/Np -/CH đăng/V bởi/E dimkadimon/Np trên/E Topcoder/Np Giới_thiệu/V :/CH Nhiều/A người/N thi/V Topcoder/Np phàn_nàn/Np khi/N trong/E đề/V có/V quá/R nhiều/A Toán/N –/CH điểm/N yếu/A của/E họ/P ./CH\nCá_nhân/N tôi/P là/V một/M người/N rất/R yêu_Toán/Np ,/CH vì_vậy/C có_lẽ/X tôi/P sẽ/R có/V chút/L thiên_vị/Np trong/E vấn_đề/N này/P ./CH\nNhưng/C tôi/P hoàn_toàn/A tin_tưởng/V rằng/C ,/CH các/L bài_tập/Np nên/C có/V ít_nhất/A một_chút/L Toán_học/N và/Cc Khoa_học/N máy_tính/N phải/V đi/V liền/R với/E Toán_học/N ./CH\nThật/R khó/A có_thể/R tưởng_tượng/V khi/N mà_cả/Np hai/M lĩnh_vực/N này/P cũng/R tồn_tại/V mà/C không_hề/Np có/V bất_kỳ/A sự/N tương_tác/V nào/P lẫn_nhau/Np ./CH\nNgày_nay/N ,/CH Toán_học/N được/V áp_dụng/V rất/R nhiều/A trong/E Tin_học/N để/E giải/N những/L hệ_phương_trình/Np hàng/N nghìn/M ẩn/V hay/Cc tìm/V nghiệm/V xấp_xỉ/A đối_với/E những/L phương_trình/Np mà/C không/R có_công/Np thức/V nghiệm/V tổng_quát/Np ./CH\nToán_học/N còn/R được/V sử_dụng/V rộng_rãi/A trong/E việc/N nghiên_cứu/V về/E Khoa_học/N máy_tính/N ,/CH cũng_như/C là/V áp_dụng/V cho/E các/L thuật_toán/N về/E đồ_thị/Np (/CH graph/Np algorithms/Np )/CH và/Cc lĩnh_vực/N thị_giác/Np máy_tính/N (/CH Computer_Vision/Np )/CH ./CH\nBài/N viết/V này/P sẽ/R phân_tích/V về/E lý_thuyết/Np và/Cc ứng_dụng/V của/E một_vài/L cấu_trúc/N Toán_học/N phổ_biến/V ./CH\nCác/L chủ_đề/Np được/V đề_cập/V tới/E bao_gồm/V :/CH Số_nguyên_tố/Np ./CH\nƯớc_chung/Np lớn/A nhất/A (GCD)/Np ./CH\nHình_học/Np cơ_bản/A ./CH\nHệ/N cơ_số/N ./CH\nPhân_số/Np và/Cc số_phức/Np ./CH\nSố_nguyên_tố/Np :/CH Một_số/L tự_nhiên/A là/V số_nguyên_tố/Np khi/N và/Cc chỉ/R khi/N nó/P chỉ/R chia_hết_cho/Np 1/M và/Cc chính/T nó/P ./CH\nVí_dụ/C như/C 2/M ,/CH 3/M ,/CH 5/M ,/CH 79/M ,/CH 311/Np và/Cc 1931/M đều/R là/V số_nguyên_tố/Np ,/CH trong_khi/Np 21/M thì/C không_phải/Np ,/CH bởi/E nó/P chia_hết_cho/Np 3/M và/Cc 7/M ./CH\nĐể/E xác_định/V xem/V một_số/L tự_nhiên/A n/Ny có_phải/Np là/V số_nguyên_tố/Np hay_không/Np ,/CH ta/P chỉ_cần/Np đơn_giản/A kiểm_tra/V xem/V nó/P có/V chia_hết_cho/Np bất_kỳ/A số/N nào/P nhỏ/A hơn/A nó/P và/Cc lớn/A 1/M hay_không/Np ./CH\nChúng_ta/P có_thể/R sử_dụng/V phép_chia/Np có_dư/Np (toán/Np tử/V %)/Np để/E kiểm_tra/V khả_năng/N chia_hết/Np của/E nó/P :/CH Java/Np for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M lt;/Np n/Ny ;/CH i/M ++)/Np if/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH return/Np false/Np ;/CH return/Np true/Np ;/CH Pascal/Np for/Np i/M :/CH =/CH 2/M to/A n/Ny -/CH 1/M do/E if/Np (/CH n/Ny mod/Np i/M =/CH 0/M )/CH then/Np exit/Np (/CH false/Np );/CH exit/Np (/CH true/Np );/CH Chúng_ta/P còn/R có_thể/R làm_cho/Np đoạn/Nc mã/N này/P chạy/V nhanh/A hơn_nữa/C bằng/E việc/N nhận_ra/Np rằng/C ,/CH ta/P chỉ_cần/Np xét/V khả_năng/N chia_hết_cho/Np mọi/L giá_trị/N i/M lớn/A hơn/A 1/M và/Cc nhỏ/A hơn/A hoặc/Cc bằng/E với/E phần/N nguyên/A của/E căn/Nc bậc/N 2/M của/E n/Ny ,/CH tạm/A gọi_là/V m/Nu ./CH\nTại_sao/X lại/R thế/P nhỉ/I ?/CH\nĐấy/P là/V bởi_vì/E nếu/C n/Ny chia_hết_cho/Np bất_kỳ/A số/N nào/P lớn/A hơn/A m/Nu thì/C kết_quả/N nhận/V được/V cũng/R chỉ/R là/V một_số/L nhỏ/A hơn/A hoặc/Cc bằng/E m/Nu ./CH\nMột/M cải_tiến/V nữa_là/X :/CH ta/P thấy/V rằng/C không/R tồn_tại/V bất_kỳ/A một_số/L nguyên_tố/N chẵn/Np nào/P lớn/A hơn/A 2/M ./CH\nNhư_vậy/X ,/CH sau/E khi/N đã/R kiểm_tra/V rằng/C n/Ny là/V số_lẻ/Np thì/C ta/P có_thể/R an_tâm/A tăng/V biến/V i/M lên/V 2/M giá_trị/N ./CH\nĐây/P sẽ/R là/V đoạn/Nc mã/N áp_dụng/V phương_thức/N kiểm_tra/V số_nguyên_tố/Np mới/R nhất/A này/P :/CH Java/Np public/Np boolean/Np isPrime/Np (/CH int/Np n/Ny )/CH if/Np (/CH n/Ny lt;=/Np 1/M )/CH return/Np false/Np ;/CH if/Np (/CH n/Ny ==/Np 2/M )/CH return/Np true/Np ;/CH if/Np (/CH n/Ny %/CH 2/M ==/Np 0/M )/CH return/Np false/Np ;/CH int/Np m/Nu =/CH Math/Np ./CH\nsqrt/Np (/CH n/Ny );/CH for/Np (/CH int/Np i/M =/CH 3/M ;/CH i/M lt;=/Np m/Nu ;/CH i/M +=/Np 2/M )/CH if/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH return/Np false/Np ;/CH return/Np true/Np ;/CH Pascal/Np function/Np IsPrime/Np (/CH n/Ny :/CH Integer/Np )/CH :/CH Boolean/Np ;/CH var/Np i/M :/CH Integer/Np ;/CH m/Nu :/CH Integer/Np ;/CH begin/Np if/Np (/CH n/Ny lt;=/Np 1/M )/CH exit/Np (/CH false/Np );/CH if/Np (/CH n/Ny =/CH 2/M )/CH exit/Np (/CH true/Np );/CH if/Np (/CH n/Ny mod/Np 2/M =/CH 0/M )/CH exit/Np (/CH false/Np );/CH i/M :/CH =/CH 3/M ;/CH m/Nu :/CH =/CH trunc/Np (/CH sqrt/Np (/CH n/Ny ));/Np while/Np (/CH i/M lt;=/Np m/Nu )/CH do/E begin/Np if/Np (/CH n/Ny mod/Np i/M =/CH 0/M )/CH exit/Np (/CH false/Np );/CH inc/Np (/CH i/M ,/CH 2/M );/CH end/Np ;/CH exit/Np (/CH true/Np );/CH end/Np ;/CH Giả_sử/Np chúng_ta/P cần/V phải/V tìm/V mọi/L số_nguyên_tố/Np trong_khoảng/Np 1/M ,/CH 100000/M ,/CH thì/C chẳng_lẽ/R ta/P phải/V gọi/V hàm/Np kiểm_tra/V 100000/M lần/N sao/P ?/CH\nViệc/N lặp_đi/Np lặp_lại/Np các/L phép/N kiểm_tra/V tương_tự/A thật_sự/A không/R hiệu_quả/N chút_nào/Np ./CH\nTrong/E tình_huống/N này/P ,/CH phương_pháp/N tối_ưu/A nhất/A chính/T là/V sử_dụng/V Sàng/Np nguyên_tố/N Eratosthenes/Np (Sieve/Np of/E Eratosthenes)/Np ./CH\nSàng/Np nguyên_tố/N Eratosthenes/Np sẽ/R xác_định/V toàn_bộ/L những/L số_nguyên_tố/Np trong_khoảng/Np 2/M ,/CH n/Ny ./CH\nTrước_hết/N ,/CH sàng/Np nguyên_tố/N sẽ/R giả_định/Np mọi/L số_tự_nhiên/Np từ/E 2/M đến/E n/Ny là/V số_nguyên_tố/Np ./CH\nKế_đến/Np ,/CH nó/P sẽ/R chọn/V ra/V số_nguyên_tố/Np đầu_tiên/A và/Cc xóa/V đi/V những/L bội/Np nhỏ/A hơn/A bằng/E n/Ny của/E số_nguyên_tố/Np đó/P ./CH\nVà/Cc nó/P lại/R tiếp_tục/V quá_trình/N bằng/E lựa/V một_số/L nguyên_tố/N tiếp_theo/V và/Cc xóa/V đi/V các/L bội/Np của/E nó/P ./CH\nQuá_trình/N này/P sẽ/R tiếp_tục/V diễn/V ra/V cho_đến/E khi/N mà/C mọi/L số/N đều/R đã/R xử_lý/V ./CH\nVí_dụ/C ,/CH ta/P sẽ/R tìm/V các/L số_nguyên_tố/Np trong_khoảng/Np 2/M ,/CH 20/M ./CH\nTrước_hết/N ,/CH ta/P hãy/R ghi/V ra/V dãy_số/Np đó/P :/CH 2/M 3/M 4/M 5/M 6/M 7/M 8/M 9/M 10/M 11/M 12/M 13/M 14/M 15/M 16/M 17/M 18/M 19/M 20/M Bởi_vì/E 2/M là/V số_nguyên_tố/Np đầu_tiên/A ,/CH nên/C ta/P sẽ/R loại_bỏ/V đi/V tất_cả/P những/L bội/Np của/E 2/M và/Cc nhỏ/A hơn/A bằng/E 20/M ./CH\n2/M 3/M 5/M 7/M 9/M 11/M 13/M 15/M 17/M 19/M Bởi_vì/E 3/M là/V số/N đầu_tiên/A chưa/R bị/V bỏ/V ,/CH nên/C ta/P sẽ/R lựa_chọn/V 3/M là/V số_nguyên_tố/Np tiếp_theo/V và/Cc loại_bỏ/V đi/V tất_cả/P những/L bội/Np của/E 3/M và/Cc nhỏ/A hơn/A bằng/E 20/M ./CH\n2/M 3/M 5/M 7/M 11/M 13/M 17/M 19/M Tiếp/V đến/E ,/CH ta/P sẽ/R chọn/V 5/M ,/CH ta/P thấy/V không/R còn/R bội/Np nào/P của/E 5/M nhỏ/A hơn/A bằng/E 20/M còn/R sót/V nên/C ta/P lại/R tiếp_tục/V xét/V đến/E 7/M ,/CH ./CH ./CH ./CH\nVà/Cc giờ/N thì/C tất_cả/P những/L số/N còn/R sót/V lại/R chính/T là/V các/L số_nguyên_tố/Np mà/C ta/P cần/V tìm/V ./CH\nDưới_đây/Np là/V đoạn/Nc mã/N cho/E Sàng/Np nguyên_tố/N Eratosthenes/Np :/CH Java/Np public/Np boolean/Np sieve/Np (/CH int/Np n/Ny )/CH boolean/Np prime/Np =/CH new/Np boolean/Np n/Ny +/CH 1/M ;/CH Arrays/Np ./CH\nfill/Np (/CH prime/Np ,/CH true/Np );/CH prime/Np 0/M =/CH false/Np ;/CH prime/Np 1/M =/CH false/Np ;/CH int/Np m/Nu =/CH Math/Np ./CH\nsqrt/Np (/CH n/Ny );/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M lt;=/Np m/Nu ;/CH i/M ++)/Np if/Np (/CH prime/Np i/M )/CH for/Np (/CH int/Np k/N =/CH i/M i/M ;/CH k/N lt;=/Np n/Ny ;/CH k/N +=/Np i/M )/CH prime/Np k/N =/CH false/Np ;/CH return/Np prime/Np ;/CH Pascal/Np //CH kiểm_tra/V số_nguyên_tố/Np prime0/Np ./CH ./CH n/Ny function/Np sieve/Np (/CH n/Ny :/CH Integer/Np )/CH :/CH Boolean/Np ;/CH var/Np i/M ,/CH m/Nu :/CH Integer/Np ;/CH begin/Np fillchar/Np (/CH prime/Np ,/CH sizeof/Np (/CH prime/Np )/CH ,/CH 1/M );/CH prime/Np 0/M :/CH =/CH false/Np ;/CH prime/Np 1/M :/CH =/CH false/Np ;/CH m/Nu :/CH =/CH trunc/Np (/CH sqrt/Np (/CH n/Ny ));/Np for/Np i/M :/CH =/CH 2/M to/A m/Nu do/E if/Np (/CH prime/Np i/M )/CH then/Np for/Np j/Np :/CH =/CH i/M to/A n/Ny div/Np i/M do/E prime/Np i/M j/Np :/CH =/CH false/Np ;/CH end/Np ;/CH Ở/E đoạn/Nc mã/N trên/E ,/CH ta/P sẽ/R tạo/V một/M mảng/N prime/Np ,/CH nơi/N sẽ/R chứa/V các/L giá_trị/N nguyên/A trong_khoảng/Np 0/M ,/CH n/Ny ./CH\nPrimei/Np là/V true/Np nếu/C i/M là/V số_nguyên_tố/Np và/Cc ngược_lại/X ./CH\nVòng_lặp/Np bên_ngoài/Np sẽ/R tìm_kiếm/V số_nguyên_tố/Np tiếp_theo/V ,/CH trong_khi/Np vòng_lặp/Np bên_trong/Np sẽ/R loại_bỏ/V đi/V tất_cả/P những/L bội/Np nhỏ/A hơn/A bằng/E n/Ny của/E số_nguyên_tố/Np đó/P ./CH\nƯớc_chung/Np lớn/A nhất/A Ước_chung/Np lớn/A nhất/A (Greatest/Np Common_Divisor)/Np của/E hai/M số_tự_nhiên/Np a/Ni và/Cc b/Ni là/V số_lớn/Np nhất/A mà_cả/Np a/Ni và/Cc b/Ni đều/R chia_hết/Np ./CH\nĐể/E tìm/V được/V GCD(a/Np ,/CH b)/Np ,/CH một_cách/N đơn_giản/A ,/CH ta/P có_thể/R lấy/V số/N nhỏ/A hơn/A trong/E hai/M số/N a/Ni và/Cc b/Ni rồi/C giảm_dần/Np cho_đến/E khi_nào/Np có/V được/V một_số/L mà_cả/Np a/Ni và/Cc b/Ni đều/R cùng/A chia_hết_cho/Np số/N đó/P ./CH\nJava/Np for/Np (/CH int/Np i/M =/CH Math/Np ./CH\nmin/Np (/CH a/Ni ,/CH b/Ni );/CH i/M gt;=/Np 1/M ;/CH i/M --)/Np if/Np (/CH a/Ni %/CH i/M ==/Np 0/M amp;amp;/Np b/Ni %/CH i/M ==/Np 0/M )/CH return/Np i/M ;/CH Pascal/Np for/Np i/M :/CH =/CH min/Np (/CH a/Ni ,/CH b/Ni )/CH downto/Np 1/M do/E if/Np (/CH a/Ni mod/Np i/M =/CH 0/M )/CH and/Np (/CH b/Ni mod/Np i/M =/CH 0/M )/CH then/Np exit/Np (/CH i/M );/CH Mặc_dù/C phương_pháp/N này/P đủ/A nhanh/A để/E đáp_ứng/V phần_lớn/N các/L trường_hợp/N ,/CH song/C ta/P vẫn/R còn/R một_cách/N nhanh/A hơn_nữa/C ,/CH đó/P chính/T là/V thuật_toán/N Euclid/Np ./CH\nThuật_toán/N Euclid/Np sẽ/R lặp_đi/Np lặp_lại/Np việc/N xử_lý/V hai/M số/N cho_đến/E khi/N mà/C phần/N dư/A của/E chúng/P bằng/E 0/M ./CH\nVí_dụ/C ,/CH giả_sử/Np chúng_ta/P muốn/V tìm/V ước_chung/Np lớn/A nhất/A của/E hai/M số/N 2336/Np và/Cc 1314/Np ./CH\nĐầu_tiên/A ,/CH ta/P sẽ/R phân_tích_số/Np lớn/A hơn_là/Np 2336/Np thành/V bội/Np của/E 1314/Np cộng/V thêm/V cho/E phần/N dư/A ./CH\n2336/Np =/CH 1314/Np x/CH 1/M +/CH 1022/Np Ta/P sẽ/R thực_hiện/V tương_tự/A với/E 1314/Np và/Cc 1022/Np ./CH\n1314/Np =/CH 1022/Np x/CH 1/M +/CH 292/Np Ta/P tiếp_tục/V quá_trình/N cho_đến/E khi/N phần/N dư/A bằng/E 0/M ./CH\n1022/Np =/CH 292/Np x/CH 3/M +/CH 146/Np 292/Np =/CH 146/Np x/CH 2/M +/CH 0/M Và/Cc phần/N dư/A cuối_cùng/A mà/C khác/A 0/M chính/T là/V ước_chung/Np lớn/A nhất/A mà/C ta/P cần/V tìm/V ./CH\nVậy/P ước_chung/Np lớn/A nhất/A của/E 1314/Np và/Cc 2336/Np chính/T là/V 146/Np ./CH\nThuật_toán/N trên/E sẽ/R được/V mô_phỏng/Np lại/R bằng/E một/M đoạn/Nc mã/N đệ_quy/Np đơn_giản/A :/CH Java/Np //CH giả_định/Np rằng/C a/Ni và/Cc b/Ni đều/R khác/A 0/M public/Np int/Np GCD/Np (/CH int/Np a/Ni ,/CH int/Np b/Ni )/CH if/Np (/CH b/Ni ==/Np 0/M )/CH return/Np a/Ni ;/CH return/Np GCD/Np (/CH b/Ni ,/CH a/Ni %/CH b/Ni );/CH Pascal/Np //CH giả_định/Np a/Ni và/Cc b/Ni đều/R khác/A 0/M function/Np GCD/Np (/CH a/Ni ,/CH b/Ni :/CH Integer/Np )/CH :/CH Integer/Np ;/CH begin/Np if/Np (/CH b/Ni =/CH 0/M )/CH then/Np exit/Np (/CH a/Ni )/CH else/Np exit/Np (/CH GCD/Np (/CH b/Ni ,/CH a/Ni mod/Np b/Ni ));/Np end/Np ;/CH Đặc_biệt/A ,/CH thuật_toán/N Euclid/Np còn/R được/V áp_dụng/V trong/E việc/N tìm/V bội_chung/Np nhỏ/A nhất/A (LCM)/Np của/E hai/M số_tự_nhiên/Np ./CH\nVí_dụ/C ,/CH bội_chung/Np nhỏ/A nhất/A của/E 6/M và/Cc 9/M là/V 18/M vì/E 18/M là/V số/N nhỏ/A nhất/A mà/C chia_hết_cho/Np cả/P a/Ni lẫn/C b/Ni ./CH\nDưới_đây/Np là/V đoạn/Nc mã/N cho/E việc/N tìm/V bội_chung/Np nhỏ/A nhất/A :/CH Java/Np public/Np int/Np LCM/Np (/CH int/Np a/Ni ,/CH int/Np b/Ni )/CH return/Np b/Ni a/Ni //CH GCD/Np (/CH a/Ni ,/CH b/Ni );/CH Pascal/Np function/Np LCM/Np (/CH a/Ni ,/CH b/Ni :/CH Integer/Np )/CH :/CH Integer/Np ;/CH begin/Np exit/Np (/CH a/Ni b/Ni //CH GCD/Np (/CH a/Ni ,/CH b/Ni ));/Np end/Np ;/CH Một/M chú_ý/V cuối_cùng/A đó/P là/V việc/N thuật_toán/N Euclid/Np còn/R có_thể/R dùng/V để/E giải/N phương_trình/Np tìm/V nghiệm/V nguyên/A Diophantine/Np ./CH\nĐó/P là/V những/L phương_trình/Np có/V hệ_số/N và/Cc ẩn_số_nguyên/Np (a/Np ,/CH b/Ni ,/CH c/Ni ,/CH x/CH ,/CH y/N \\in/Np N)/Np và/Cc được/V biểu_diễn/V như_sau/Np :/CH ax/Ny +/CH by/Np =/CH c/Ni Xem/V thêm/V :/CH Thuật_toán/N Euclid/Np mở_rộng/V Hình_học/Np Đôi_khi/R ,/CH bài_toán/N yêu_cầu/V ta/P tìm/V phần/N giao/V của/E các/L hình_chữ_nhật/N với/E các/L cạnh/N song_song/A trục/N tọa_độ/Np ./CH\nCó/V rất/R nhiều/A cách/N để/E biểu_diễn/V một/M hình_chữ_nhật/N ./CH\nĐối_với/E hệ/N trục/N tọa_độ/Np Cartesian/Np ,/CH thì/C cách/N biểu_diễn/V phổ_biến/V nhất/A chính/T là/V lưu_giữ/V giá_trị/N tọa_độ/Np của/E góc/N trái/Nc -/CH dưới/E và/Cc góc/N phải/V -/CH trên/E của/E hình_chữ_nhật/N ./CH\nGiả_sử/Np chúng_ta/P có/V hai/M hình_chữ_nhật/N R1/Np và/Cc R2/Np ./CH\nĐặt/V (x1/Np ,/CH y1)/Np là/V tọa_độ/Np góc/N trái/Nc -/CH dưới/E ,/CH (x2/Np ,/CH y2)/Np là/V tọa_độ/Np góc/N phải/V -/CH trên/E của/E hình_chữ_nhật/N R1/Np ./CH\nTương_tự/A với/E R2/Np ,/CH ta/P đặt/V (x3/Np ,/CH y3)/Np ,/CH (x4/Np ,/CH y4)/Np lần_lượt/R là/V tọa_độ/Np góc/N trái/Nc -/CH dưới/E và/Cc góc/N phải/V -/CH trên/E của/E R2/Np ./CH\nPhần/N giao/V của/E R1/Np và/Cc R2/Np sẽ/R là/V hình_chữ_nhật/N R3/Np có/V tọa_độ/Np trái/Nc -/CH dưới/E là/V (max(x1/Np ,/CH x3)/Np ,/CH max(y1/Np ,/CH y3))/Np và/Cc tọa_độ/Np góc/N phải/V -/CH trên/E là/V (min(x2/Np ,/CH x4)/Np ,/CH min(y2/Np ,/CH y4))/Np ./CH\nNếu/C max(x1/Np ,/CH x3)/Np gt;/Np min(x2/Np ,/CH x4)/Np hoặc/Cc max(y1/Np ,/CH y3)/Np gt;/Np min(y2/Np ,/CH y4)/Np thì/C sẽ/R không/R tồn_tại/V hình_chữ_nhật/N R3/Np ,/CH hay/Cc nói/V các/L khác/A là/V R1/Np và/Cc R2/Np không/R giao/V nhau/N ./CH\nCông_thức/N này/P còn/R được/V mở_rộng/V ra/V hơn/A không_gian/N 2/M chiều/N giống_như/Np là/V trong/E bài/N CuboidJoin/Np (SRM/Np 191/Np ,/CH Div/Np 2/M Hard)/Np ./CH\nThường/R thì/C ,/CH khi/N làm_bài/Np chúng_ta/P sẽ/R phải/V đối_mặt/V với/E những/L đa_giác/Np mà/C đỉnh/N của/E nó/P là/V số_nguyên/Np ./CH\nNhững/L đa_giác/Np đó/P được/V gọi_là/V Đa_giác/Np lưới/N (lattice/Np polygon)/Np ./CH\nTrong/E phần/N hướng_dẫn/V cơ_bản/A về/E khái_niệm/N hình_học/Np (/CH Geometry_Concepts/Np )/CH ,/CH lbackstrom/Np đã/R trình_bày/V một_cách/N ngắn_gọn/A cách/N tính/V diện_tích/N thông_qua/V các/L cạnh/N của/E đa_giác/Np ./CH\nBây_giờ/P ,/CH giả_sử_ta/Np không/R biết/V được/V chính_xác/A vị_trí/N các/L cạnh/N mà/C thay/V vào/E đó/P ta/P có/V được/V các/L giá_trị/N sau/E :/CH B/Ni =/CH số_lượng/N điểm/N nằm/V ở/E trên/E cạnh/N đa_giác/Np (Boundary)/Np I/M =/CH số_lượng/N điểm/N nằm/V trong/E đa_giác/Np (Inside)/Np Thật/R vi_diệu/Np ,/CH thông_qua/V hai/M giá_trị/N trên/E ta/P có_thể/R tính/V được/V diện_tích/N đa_giác/Np bằng/E công_thức/N sau/E :/CH Diện_tích/N =/CH B/Ni +/CH I/M -/CH 1/M Công_thức/N trên/E được/V gọi_là/V định_lý/Np Pick/Np được/V chứng_minh/V bởi/E Georg_Alexander_Pick/Np (1859/Np –/CH 1943)/Np ./CH\nĐể/E chứng_minh/V được/V rằng/C định_lý/Np Pick/Np có/V tính_chất/N bao_quát/V cho/E toàn_bộ/L mọi/L đa_giác/Np lưới/N ,/CH ta/P chứng_minh/V theo/V 4/M bước/V :/CH Bước/V 1/M :/CH chứng_minh/V định_lý/Np Pick/Np đúng_với/Np mọi/L hình_chữ_nhật/N lưới/N ,/CH có/V cạnh/N song_song/A với/E trục/N tọa_độ/Np ./CH\nBước/V 2/M :/CH chứng_minh/V được/V định_lý/Np Pick/Np vẫn/R đúng_với/Np mọi/L tam_giác_vuông/Np có/V hai/M cạnh/N song_song/A với/E trục/N tọa_đô/Np (bởi/Np chúng/P là/V phân_nửa/Np diện_tích/N một/M hình_chữ_nhật/N lưới/N có/V tọa_độ/Np một/M đỉnh/N là/V góc_vuông/Np của/E tam_giác/N và/Cc có/V cạnh/N là/V các/L cạnh/N góc_vuông/Np của/E tam/M giác)/Np ./CH\nBước/V 3/M :/CH chứng_minh/V định_lý/Np Pick/Np đúng_với/Np mọi/L tam_giác/N ,/CH bởi/E một/M tam_giác/N bất_kỳ/A đều/R có_thể/R biểu_diễn/V thành/V một/M hình_chữ_nhật/N bằng/E cách/N ghép_cặp/Np với/E một_vài/L tam_giác_vuông/Np khác/A ./CH\nBước/V 4/M :/CH ta/P thấy/V rằng/C mọi/L cặp/N 2/M đa_giác/Np lưới/N có/V chung/A cạnh/N sẽ/R tạo_thành/Np một/M đa_giác/Np lưới/N khác/A bằng/E cách/N xóa/V đi/V cạnh/N chung/A ,/CH và/Cc mọi/L đa_giác/Np lưới/N đều/R có_thể/R tạo/V ra/V bằng/E cách/N ghép/V các/L hình_tam_giác/Np ./CH\nTổng_hợp/V lại/R 4/M bước/V trên/E và/Cc ta/P sẽ/R thu/V được/V kết_quả/N rằng/C định_lý/Np Pick/Np đúng_với/Np mọi/L đa_giác/Np lưới/N ./CH\nĐịnh_lý/Np Pick/Np khá/R hữu_ích/A khi/N ta/P cần/V tìm/V số/N điểm/N có/V tọa_độ/Np nguyên/A bên_trong/Np một/M đa_giác/Np lớn/A ./CH\nMột/M công_thức/N đáng/V nhớ/V khác/A đó/P chính/T là/V công_thức/N Euler/Np dành/V cho/E các/L khối/N đa_diện/Np ./CH\nKhối/N đa_diện/Np được/V định_nghĩa_là/Np một/M khối/N (một/Np đa/Z giác)/Np mà/C ta/P có_thể/R chia/V thành/V nhiều/A đa_giác/Np nhỏ/A hơn/A ./CH\nCác/L đa_giác/Np nhỏ/A hơn/A được/V gọi_là/V mặt/N ,/CH cách/N đỉnh/N của/E mặt/N cũng/R được/V gọi_là/V đỉnh/N của/E khối/N đa_diện/Np và/Cc tương_tự/A ,/CH các/L cạnh/N của/E mặt/N cũng/R gọi_là/V cạnh/N ./CH\nDưới_đây/Np là/V công_thức/N Euler/Np ./CH\nV/Nu -/CH E/Ni +/CH F/Np =/CH 2/M ,/CH với/E :/CH V/Nu =/CH số/N đỉnh/N của/E khối/N E/Ni =/CH số/N cạnh/N của/E khối/N F/Np =/CH số/N mặt/N của/E khối/N Ví_dụ/C ,/CH xét/V một/M hình_vuông/N mà_cả/Np hai/M đường_chéo/Np đều/R được/V vẽ/V ./CH\nTa/P sẽ/R có/V V/Nu =/CH 5/M ,/CH E/Ni =/CH 8/M và/Cc F/Np =/CH 5/M (phần/Np nằm/V ngoài/E hình_vuông/N cũng/R được/V coi_như/Np là/V một/M mặt)/Np ,/CH ta/P sẽ/R có/V V/Nu -/CH E/Ni +/CH F/Np =/CH 2/M ./CH\nTa/P có_thể/R sử_dụng/V quy_nạp/Np để/E chứng_minh/V nó/P như_sau/Np :/CH Ta/P sẽ/R bắt_đầu/V với/E V/Nu =/CH 2/M ,/CH vì/E mỗi/L đỉnh/N đều/R cần/V phải/V có/V ít_nhất/A một/M cạnh/N ./CH\nVà/Cc nếu/C V/Nu =/CH 2/M thì/C chỉ_có/Np xảy_ra/Np duy_nhất/A một/M dạng/N khối/N đa_diện/Np mà_thôi/T ./CH\nĐó/P là/V dạng/N khối/N đa_diện/Np mà/C hai/M cạnh/N sẽ/R nối/V với/E E/Ni đỉnh/N ./CH\nKhối/N đa_diện/Np nãy/P cũng/R sẽ/R có/V E/Ni mặt/N ,/CH (E-1/Np mặt_bên/Np trong/E hình/N và/Cc 1/M mặt/N ngoài/E hình)/Np ./CH\nThế/P nên/C V/Nu -/CH E/Ni +/CH F/Np =/CH 2/M -/CH E/Ni +/CH E/Ni =/CH 2/M (điều/Np phải/V chứng/N minh)/Np ./CH\nGiờ/N ta/P giả_sử/Np định_lý/Np Euler/Np đúng_với/Np V/Nu từ/E 2/M ,/CH n/Ny ,/CH xét/V V/Nu =/CH n+1/Np ./CH\nChọn/V một/M cạnh/N w/Nu bất_kỳ/A ./CH\nGiờ/N giả_định/Np w/Nu nối/V với/E tất_cả/P những/L lưới/N còn_lại/Np có/V G/Nu đỉnh/N ./CH\nNếu/C bỏ_đi/Np cạnh/N w/Nu này/P và/Cc những/L đỉnh/N mà/C nó/P nối/V ,/CH ta/P sẽ/R có_một/Np lưới/N với/E n/Ny cạnh/N ,/CH E/Ni -/CH G/Nu đỉnh/N và/Cc F-G+1/Np mặt/N ./CH\nTừ/E giả_định/Np trên/E ta/P có/V :/CH (n)/Np -/CH (E/Np -/CH G)/Np +/CH (F/Np -/CH G/Nu +/CH 1)/Np =/CH 2/M (n+1)/Np -/CH E/Ni +/CH F/Np =/CH 2/M Vậy/P với/E V/Nu =/CH n+1/Np ,/CH ta/P cũng/R vẫn/R thu/V được/V kết_quả/N là/V V/Nu -/CH E/Ni +/CH F/Np =/CH 2/M ./CH\nVậy/P là/V với/E phương_pháp/N quy_nạp/Np toán_học/N ,/CH ta/P đã/R chứng_minh/V được/V định_lý/Np Euler/Np ./CH\nHệ/N cơ_số/N :/CH Một/M trong/E những/L bài_toán/N mà/C người/N thi/V Topcoder/Np đối_mặt/V nhiều/A nhất/A đó/P chính/T là/V việc/N chuyển_đổi/V số_từ/Np hệ/N cơ_số/N nhị_phân/Np sang/V hệ/N cơ_số/N thập_phân/Np và/Cc ngược_lại/X (cùng/Np với/E nhiều/A hệ/N cơ_số/N khác)/Np ./CH\nVậy/P hệ/N cơ_số/N nghĩa_là/V gì/P ?/CH\nTa/P sẽ/R bắt_đầu/V với/E hệ/N cơ_số/N tiêu_chuẩn/N (hệ/Np thập/Np phân)/Np ./CH\nXét/V số/N 4325/Np ở/E hệ/N cơ_số/N 10/M ./CH\nTa/P thấy/V 4325/Np có_thể/R phân_tích/V thành/V 5/M +/CH 210/M +/CH 31010/Np +/CH 4101010/Np ./CH\nChú_ý/V rằng/C mỗi/L \"giá/Np trị\"/Np của/E chữ_số/Np tiếp_theo/V sau/E của/E số/N được/V nhân/N thêm/V tích_số/Np 10/M khi/N ta/P xét/V từ/E phải/V qua/V trái/Nc ./CH\nHệ/N nhị_phân/Np cũng/R hoạt_động/N theo/V cách/N tương_tự/A như_thế/X ./CH\nNó/P sử_dụng/V hai/M chữ_số/Np 0/M và/Cc 1/M và/Cc \"giá/Np trị\"/Np của/E từng/R chữ_số/Np sẽ/R được/V nhân/N thêm/V 2/M khi/N ta/P xét/V từ/E phải/V qua/V trái/Nc ./CH\nVí_dụ/C ,/CH số/N 1011/Np ở/E dạng/N nhị_phân/Np có_thể/R biểu_diễn/V thành/V 1/M +/CH 12/M +/CH 022/Np +/CH 1222/Np =/CH 1/M +/CH 2/M +/CH 8/M =/CH 11/M và/Cc trở_lại/V thành/V số/N ở/E hệ_thập_phân/Np là/V 11/M ./CH\nVà/Cc đây/P chính/T là/V cách/N để/E ta/P chuyển/V từ/E số/N ở/E hệ/N nhị_phân/Np (hoặc/Np bất_kỳ/A hệ_số/N nào)/Np về/E hệ/N cơ_số/N thập_phân/Np ./CH\nSau_đây/Np là/V đoạn/Nc mã/N để/E chuyển/V số/N n/Ny từ/E một/M hệ/N cơ_số/N b/Ni (2/Np \\le/Np b/Ni \\le/Np n)/Np thành/V hệ/N cơ_số/N thập_phân/Np ./CH\nJava/Np public/Np int/Np toDecimal/Np (/CH int/Np n/Ny ,/CH int/Np b/Ni )/CH int/Np result/Np =/CH 0/M ;/CH int/Np multiplier/Np =/CH 1/M ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH result/Np +=/Np n/Ny %/CH 10/M multiplier/Np ;/CH multiplier/Np =/CH b/Ni ;/CH n/Ny /=/Np 10/M ;/CH return/Np result/Np ;/CH Pascal/Np function/Np ToDectimal/Np (/CH n/Ny ,/CH b/Ni :/CH Integer/Np )/CH :/CH Integer/Np ;/CH var/Np mul/Np :/CH Integer/Np =/CH 1/M ;/CH begin/Np result/Np :/CH =/CH 0/M ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH do/E begin/Np result/Np :/CH =/CH result/Np +/CH (/CH n/Ny mod/Np 10/M )/CH mul/Np ;/CH mul/Np :/CH =/CH mul/Np b/Ni ;/CH n/Ny :/CH =/CH n/Ny div/Np 10/M ;/CH end/Np ;/CH end/Np ;/CH Người/N dùng/V Java/Np hẳn/R sẽ/R rất/R vui/A khi/N biết/V rằng/C vẫn/R có/V cách/N khác/A đơn_giản/A hơn/A để/E thực_hiện/V việc/N này/P ./CH\nreturn/Np Integer/Np ./CH\nparseInt/Np (/CH \"\"/Np +/CH n/Ny ,/CH b/Ni );/CH Để/E chuyển/V một_số/L từ/E hệ_thập/Np phần/N về/E hệ/N nhị_phân/Np cũng/R khá/R đơn_giản/A ./CH\nGiả_sử_ta/Np muốn/V chuyển/V số/N 43/M từ/E hệ_thập_phân/Np về/E hệ/N nhị_phân/Np ./CH\nTại/E bước_đầu/N của_công/Np thức/V ta/P sẽ/R chia/V đôi/M 43/M và/Cc lưu/V lại/R giá_trị/N phần/N dư/A ,/CH tiếp_tục/V xử_lý/V với/E số/N được/V chia/V đôi/M đó/P cho_đến/E khi/N nó/P bằng/E 0/M ./CH\nVà/Cc danh_sách/N số_dư/Np sau/E cuối_cùng/A cũng/R chính/T là/V cách/N biểu_diễn/V số/N nhị_phân/Np cần/V tìm/V ./CH\n43/M =/CH 21/M +/CH dư/A 1/M 21/M =/CH 10/M +/CH dư/A 1/M 10/M =/CH 5/M +/CH dư/A 0/M 5/M =/CH 2/M +/CH dư/A 1/M 2/M =/CH 1/M +/CH dư/A 0/M 1/M =/CH 0/M +/CH dư/A 1/M Vậy/P 43/M sẽ/R được/V biểu_diễn/V thành/V 101011/Np ở/E dạng/N nhị_phân/Np ./CH\nBằng/E việc/N thay/V số/N 2/M thành/V số/N b/Ni ,/CH ta/P có_thể/R chuyển/V từ/E hệ_thập_phân/Np về/E bất_kỳ/A hệ/N cơ_số/N b/Ni nào/P (2)/Np :/CH Java/Np public/Np int/Np fromDecimal/Np (/CH int/Np n/Ny ,/CH int/Np b/Ni )/CH int/Np result/Np =/CH 0/M ;/CH int/Np multiplier/Np =/CH 1/M ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH result/Np +=/Np n/Ny %/CH b/Ni multiplier/Np ;/CH multiplier/Np =/CH 10/M ;/CH n/Ny /=/Np b/Ni ;/CH return/Np result/Np ;/CH Pascal/Np function/Np FromDecimal/Np (/CH n/Ny ,/CH b/Ni :/CH Integer/Np )/CH :/CH Integer/Np ;/CH var/Np mul/Np :/CH Integer/Np =/CH 1/M ;/CH begin/Np result/Np :/CH =/CH 0/M ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH do/E begin/Np result/Np :/CH =/CH result/Np +/CH (/CH n/Ny mod/Np b/Ni )/CH mul/Np ;/CH mul/Np :/CH =/CH mul/Np 10/M ;/CH n/Ny :/CH =/CH n/Ny div/Np b/Ni ;/CH end/Np ;/CH end/Np ;/CH Đối_với/E trường_hợp/N b/Ni lớn/A hơn/A 10/M ,/CH ta/P sẽ/R xử_dụng/Np các/L ký_tự/Np không_phải/Np chữ_số/Np để/E đại_diện/N cho/E các/L số_từ/Np 10/M trở_lên/A ./CH\nVí_dụ/C ,/CH ta/P sẽ/R để/E A/Ni đại_diện/N cho/E 10/M ,/CH B/Ni cho/E 11/M ,/CH ./CH ./CH ./CH\nĐoạn/Nc mã/N sau_đây/Np sẽ/R cho_phép/V ta/P chuyển/V từ/E số_thập_phân/Np sang/V bất_kỳ/A hệ/N cơ_số/N nào/P (lên/Np đến/E 20)/Np ./CH\nJava/Np public/Np String/Np fromDecimal2/Np (/CH int/Np n/Ny ,/CH int/Np b/Ni )/CH String/Np chars/Np =/CH \"0123456789ABCDEFGHIJ\"/Np ;/CH String/Np result/Np =/CH \"\"/Np ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH result/Np =/CH chars/Np ./CH\ncharAt/Np (/CH n/Ny %/CH b/Ni )/CH +/CH result/Np ;/CH n/Ny /=/Np b/Ni ;/CH return/Np result/Np ;/CH Pascal/Np function/Np FromDecimal2/Np (/CH n/Ny ,/CH b/Ni :/CH Integer/Np )/CH :/CH String/Np ;/CH var/Np chars/Np :/CH string/Np =/CH 0123456789ABCDEFGHIJ/Np ;/CH begin/Np result/Np :/CH =/CH ;/CH while/Np (/CH n/Ny gt;/Np 0/M )/CH do/E begin/Np result/Np :/CH =/CH chars/Np n/Ny mod/Np b/Ni +/CH 1/M +/CH result/Np ;/CH n/Ny :/CH =/CH n/Ny div/Np b/Ni ;/CH end/Np ;/CH end/Np ;/CH Trong_Java/Np ,/CH ta/P có_thể/R sử_dụng/V những/L cách/N tắt/V sau/E để/E chuẩn/N từ/E hệ_thập_phân/Np sang/V như/C hệ_số/N thông_dụng/A khác/A ,/CH như_là/V hệ/N nhị_phân/Np ,/CH hệ/N bát/N phân/V ,/CH hệ_thập/Np lục/V phân/V ./CH\nInteger/Np ./CH\ntoBinaryString/Np (/CH n/Ny );/CH Integer/Np ./CH\ntoOctalString/Np (/CH n/Ny );/CH Integer/Np ./CH\ntoHexString/Np (/CH n/Ny );/CH Phân_số/Np và/Cc số_phức/Np Phân_số/Np thường/R được/V gặp/V rất/R nhiều/A trong/E các/L bài_tập/Np ./CH\nThường/R thì/C vấn_đề/N khó_khăn/A nhất/A mà/C ta/P cần/V phải/V đối_mặt/V đó/P chính/T là/V việc/N biểu_diễn/V các/L phân_số/Np đó/P ./CH\nMặc_dù/C nó/P hoàn_toàn/A khả_thi/A trong/E việc/N tạo/V ra/V một/M lớp/N (class)/Np khác/A để/E lưu_trữ/Np một_cách/N đầy_đủ/A các/L thông_tin/N về_phần/Np số/N ,/CH nhưng/C trong/E nhiều/A trường_hợp/N thì/C cách/N thường_dùng/Np nhất_là/X sử_dụng/V mảng/N lưu/V 2/M giá_trị/N bằng/E cách/N ghép_cặp/Np (pair)/Np ./CH\nÝ_tưởng/N là/V ta/P sẽ/R lưu_số/Np đầu_tiên/A là/V tử_số/Np ,/CH số/N thứ_hai/N là/V mẫu_số/Np ./CH\nTa/P sẽ/R bắt_đầu/V bằng/E việc/N nhân/N hai/M phân_số/Np a/Ni và/Cc b/Ni :/CH Java/Np public/Np int/Np multiplyFractions/Np (/CH int/Np a/Ni ,/CH int/Np b/Ni )/CH int/Np c/Ni =/CH a/Ni 0/M b/Ni 0/M ,/CH a/Ni 1/M b/Ni 1/M ;/CH return/Np c/Ni ;/CH Pascal/Np type/Np ps/Np =/CH record/Np x/CH ,/CH y/N :/CH Integer/Np ;/CH end/Np ;/CH function/Np multiplyFractions/Np (/CH a/Ni ,/CH b/Ni :/CH ps/Np )/CH :/CH ps/Np ;/CH var/Np c/Ni :/CH ps/Np ;/CH begin/Np c/Ni ./CH\nx/CH :/CH =/CH a/Ni ./CH\nx/CH b/Ni ./CH\nx/CH ;/CH c/Ni ./CH\ny/N :/CH =/CH a/Ni ./CH\ny/N b/Ni ./CH\ny/N ;/CH exit/Np (/CH c/Ni );/CH end/Np ;/CH Cộng/V phân_số/Np thì_có/X một_chút/L phức_tạp/A hơn/A ,/CH bởi/E chỉ_có/Np nhưng/C phân_số/Np có/V cùng/A mẫu_số/Np mới/R có_thể/R cộng/V trực_tiếp/A ./CH\nTrước_hết/N ta/P sẽ/R tìm/V mẫu_số_chung/N của/E hai/M phân_số/Np và/Cc nhân_tử/Np số/N hai/M phân_số/Np theo/V tỉ_số/N giữa/N mẫu_số/Np cũ/A với/E mẫu_số_chung/N ./CH\nMẫu_số_chung/N là/V số/N có_thể/R chia_hết_cho/Np cả/P mẫu/N của/E hai/M phân_số/Np ,/CH hay/Cc đơn_giản/A hơn/A đó/P chính/T là/V bội_chung/Np nhỏ/A nhất/A của/E hai/M mẫu_số/Np ./CH\nVí_dụ/C để/E cộng/V hai/M phân_số/Np 4/M và/Cc 1/M ./CH\nBội_chung/Np nhỏ/A nhất/A của/E 9/M và/Cc 6/M là/V 18/M ./CH\nĐể/E chuyển_đổi/V hai/M phân_số/Np ta/P sẽ/R lấy/V phân_số/Np thứ/N nhất/A nhân/N cho/E 2/M và/Cc số/N thứ_hai/N cho/E 3/M ./CH\n4/M +/CH 1/M =/CH (42)/Np 2)/Np +/CH (1/Np 3)/Np 3)/Np =/CH 8/M +/CH 3/M Một_khi/X hai/M phân_số/Np đã/R có/V mẫu_số/Np bằng_nhau/Np ,/CH thì/C ta/P chỉ_cần/Np đơn_giản/A cộng/V hai/M phân_số/Np đó/P lại/R và/Cc nhận/V kết_quả/N cuối_cùng/A là/V phân_số/Np 11/M ./CH\nTrừ/V cũng/R rất/R đơn_giản/A ,/CH chỉ/R khác_nhau/Np ở/E bước/V cuối_cùng/A ./CH\n4/M -/CH 1/M =/CH 8/M -/CH 3/M =/CH 5/M Đây/P là/V đoạn/Nc mã/N cho/E chương_trình/N công/N hai/M phân_số/Np :/CH Java/Np public/Np int/Np addFractions/Np (/CH int/Np a/Ni ,/CH int/Np b/Ni )/CH int/Np denom/Np =/CH LCM/Np (/CH a/Ni 1/M ,/CH b/Ni 1/M );/CH int/Np c/Ni =/CH denom/Np //CH a/Ni 1/M a/Ni 0/M +/CH denom/Np //CH b/Ni 1/M b/Ni 0/M ,/CH denom/Np ;/CH return/Np c/Ni ;/CH Pascal/Np function/Np addFractions/Np (/CH a/Ni ,/CH b/Ni :/CH ps/Np )/CH :/CH ps/Np ;/CH var/Np denom/Np :/CH Integer/Np ;/CH begin/Np denom/Np :/CH =/CH LCM/Np (/CH a/Ni ./CH\ny/N ,/CH b/Ni ./CH\ny/N );/CH result/Np ./CH\nx/CH :/CH =/CH denom/Np div/Np a/Ni ./CH\ny/N a/Ni ./CH\nx/CH +/CH denom/Np div/Np b/Ni ./CH\ny/N b/Ni ./CH\nx/CH ;/CH result/Np ./CH\ny/N :/CH =/CH denom/Np ;/CH end/Np ;/CH Cuối_cùng/A ,/CH nó/P rất/R cần_thiết/A để/E biết/V được/V cách/N tối_giản/Np phân_số_thành/Np phân_số/Np tối_giản/Np ./CH\nVà/Cc phân_số/Np chỉ/R tối_giản/Np khi/N và/Cc chỉ/R khi/N ước_chung/Np lớn/A nhất/A của/E tử_số/Np và/Cc mẫu_số/Np là/V 1/M ./CH\nChúng_ta/P sẽ/R làm/V như_sau/Np :/CH Java/Np public/Np void/Np reduceFraction/Np (/CH int/Np a/Ni )/CH int/Np b/Ni =/CH GCD/Np (/CH a/Ni 0/M ,/CH a/Ni 1/M );/CH a/Ni 0/M /=/Np b/Ni ;/CH a/Ni 1/M /=/Np b/Ni ;/CH Pascal/Np procedure/Np reduceFraction/Np (/CH var/Np a/Ni :/CH ps/Np );/CH var/Np b/Ni :/CH Integer/Np ;/CH begin/Np b/Ni :/CH =/CH GCD/Np (/CH a/Ni ./CH\nx/CH ,/CH a/Ni ./CH\ny/N );/CH a/Ni ./CH\nx/CH :/CH =/CH a/Ni ./CH\nx/CH div/Np b/Ni ;/CH a/Ni ./CH\ny/N :/CH =/CH a/Ni ./CH\ny/N div/Np b/Ni ;/CH end/Np ;/CH Bằng/E phương_pháp/N tương_tự/A ,/CH ta/P cũng/R có_thể/R biểu_diễn/V được/V số_phức/Np ./CH\nMột_cách/N tổng_quát/Np ,/CH số_phức/Np được/V biểu_diễn/V dưới/E dạng/N a/Ni +/CH ib/Np với/E a/Ni ,/CH b/Ni là/V số_thực/Np và/Cc i/M là/V căn/Nc bậc/N hai/M của/E -1/Np ./CH\nVí_dụ/C ,/CH để/E cộng/V hai/M số_phức/Np ,/CH ta/P sẽ/R cộng/V đơn_giản/A như_sau/Np :/CH m/Nu +/CH n/Ny =/CH (a/Np +/CH bi)/Np +/CH (c/Np +/CH di)/Np =/CH (a/Np +/CH c)/Np +/CH (b/Np +/CH d)/Np Việc/N nhân/N hai/M số_phức/Np cũng/R tương_tự/A như/C việc/N nhân_số/Np thực/A ,/CH trừ/V việc/N ii/M bằng/E -1/Np ./CH\nm/Nu n/Ny =/CH (a/Np +/CH ib)/Np (c/Np +/CH id)/Np =/CH ac/Np +/CH iad/Np +/CH ibc/Np +/CH (i2)bd/Np =/CH (ac/Np -/CH bd)/Np +/CH i(ad/Np +/CH bc)/Np Bằng/E việc/N lưu_trữ/Np phần/N số_thực/Np ở/E phần_tử/N thứ/N nhất/A và/Cc phần/N số_phức/Np ở/E phần_tử/N thứ_hai/N trong/E một/M mảng/N hai/M giá_trị/N như/C đoạn/Nc mã/N dưới_đây/Np :/CH Java/Np public/Np int/Np multiplyComplex/Np (/CH int/Np m/Nu ,/CH int/Np n/Ny )/CH int/Np prod/Np =/CH m/Nu 0/M n/Ny 0/M -/CH m/Nu 1/M n/Ny 1/M ,/CH m/Nu 0/M n/Ny 1/M +/CH m/Nu 1/M n/Ny 0/M ;/CH return/Np prod/Np ;/CH Pascal/Np function/Np multiplyComplex/Np (/CH m/Nu ,/CH n/Ny :/CH ps/Np )/CH :/CH ps/Np ;/CH begin/Np result/Np ./CH\nx/CH :/CH =/CH m/Nu ./CH\nx/CH n/Ny ./CH\nx/CH -/CH m/Nu ./CH\ny/N n/Ny ./CH\ny/N ;/CH result/Np ./CH\ny/N :/CH =/CH m/Nu ./CH\nx/CH n/Ny ./CH\ny/N +/CH m/Nu ./CH\ny/N n/Ny ./CH\nx/CH ;/CH end/Np ;/CH Tổng_kết/V :/CH Tổng_kết/V lại/R ,/CH tôi/P chỉ/R muốn/V nói/V rằng/C bạn/N không_thể/R đạt/V rating/Np cao/A ở/E Topcoder/Np mà/C không/R nắm/V rõ/A Toán_học/N và/Cc những/L thuật_toán/N nêu/V trên/E ./CH\nThường/R thì/C một/M trong/E những/L chủ_đề/Np Toán_học/N thường/R gặp/V nhất/A trong/E các/L bài_tập/Np đó/P là/V số_nguyên_tố/Np ./CH\nTiếp/V đó/P là/V những/L bài/N về/E hệ/N cơ_số/N ,/CH mà/C nguyên_nhân/N chủ_yếu/A là_vì/Np máy_tính/N hoạt_động/N dựa/V trên/E hệ/N nhị_phân/Np ,/CH nên/C ta/P cần/V phải_biết/N cách/N chuyển/V từ/E hệ/N nhị_phân/Np về/E hệ_thập_phân/Np ./CH\nCòn/R công_thức/N tính/V ước_chung/Np lớn/A nhất/A (GCD)/Np và/Cc bội_chung/Np nhỏ/A nhất/A (LCM)/Np thì/C được/V dùng/V nhiều/A trong/E cả/P những/L bài_tập/Np \"thuần/Np toán\"/Np và/Cc cả/P hình_học/Np ./CH\nCuối_cùng/A ,/CH tôi/P viết/V chủ_đề/Np Phân_số/Np và/Cc số_phức/Np là/V việc/N nó/P không/R chỉ_cần/Np thiết/N cho/E việc/N thi/V Topcoder/Np ,/CH mà/C bởi/E nó/P còn/R vô_cùng/R quan_trọng/A khi/N làm_việc/V với/E những/L con_số/N ./CH\n\n", "title": "Toán học trong Tin học\n", "link": "http://vnoi.info/wiki/translate/topcoder/Mathematics-for-Topcoders\n"}