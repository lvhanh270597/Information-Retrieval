{"content": "Tác_giả : Nguyễn_RR Thành_Trung Bài_toán Cho một dãy_số A gồm N phần_tử .\nCần thực_hiện Q truy_vấn , mỗi truy_vấn (i , j) yêu_cầu tìm mode(A_i , . . . , A_j) .\n(Mode của một_tập hợp là giá_trị xuất_hiện nhiều lần nhất trong tập_hợp đó) .\nGiới_hạn : N , Q , A_i \\le 105 .\nKhi đọc đề một bài_toán truy_vấn kiểu này , có_lẽ CTDL đầu_tiên mà các bạn nghĩ đến_là Interval_Tree .\nNhưng có_điều gì đó không ổn trong bài này : Khi có thông_tin của 2 nút con l , mid và mid+1 , r , rất khó để tìm được bất_kỳ thông_tin hữu_ích nào của l , r .\nDuyệt Chúng_ta xuất_phát từ thuật_toán duyệt hồn_nhiên như_sau : Với mỗi truy_vấn , ta for từ trái sang phải , đếm_số lần xuất_hiện .\nTrong_khi đếm thì ta_cập nhật kết_quả .\nCode đơn_giản như_sau : function mode ( l , r ) : // Khởi tạo mảng count = toàn 0 res = - 1 ; for i = l . .\nr : count A i += 1 ; if res == - 1 or count A i gt; count res : res = A i ; return res ; Dễ thấy , thuật_toán duyệt này có độ phức_tạp O(N_Q) .\nCó 2 lý_do chính khiến thuật_toán này chạy chậm : Khởi tạo mảng count mỗi lần mất O(N) .\nVới mỗi truy_vấn , phải tính lại mảng count từ_đầu .\nTa có_thể cải_tiến được như_sau : Sau khi trả_lời truy_vấn l_1 , r_1 , để trả_lời truy_vấn l_2 , r_2 , bạn chỉ_cần thay_đổi mảng đếm một_cách phù_hợp .\nCụ_thể : Nếu l_2 gt; l_1 , giảm số lần xuất_hiện của A_l_1 , . . . , A_l_2-1 Nếu l_2 lt; l_1 , tăng số lần xuất_hiện của A_l_2 , . . . , A_l_1-1 Tương_tự với r_1 và r_2 .\nĐể cập_nhật số lần xuất_hiện lớn nhất_thì có_thể dùng thêm set .\nNhư_vậy , độ phức_tạp của ta là tổng l_i - l_i-1 + r_i - r_i-1 , nhân thêm \\mathcalO(logN) để đếm và tìm phần_tử lớn nhất của mảng đếm .\nThuật_toán Mo Thuật_toán Mo là một_cách sắp_xếp lại các truy_vấn , sao_cho tổng l_i - l_i-1 + r_i - r_i-1 không quá O(N \\sqrtN + Q \\sqrtN) .\nThứ_tự các truy_vấn được định_nghĩa qua hàm so_sánh dưới_đây .\nS = sqrt ( N ); bool cmp ( Query_A , Query_B ) // so_sánh 2 truy_vấn if ( A .\nl / S ! = B .\nl / S ) return A .\nl / S lt; B .\nl / S ; return A .\nr lt; B .\nr ; Giải_thích : Ta chia dãy thành các block (nhóm) độ_dài S = \\sqrtN .\nNếu đầu trái của truy_vấn nằm ở 2 block khác_nhau , ta sắp_xếp theo đầu trái .\nNgược_lại (đầu trái của truy_vấn nằm ở cùng 1 block) , ta sắp_xếp theo đầu phải .\nChứng_minh : Mos algorithm có độ phức_tạp là O(N \\sqrtN + Q \\sqrtN) .\nĐể hiểu tại_sao độ phức_tạp của thuật_toán đạt được như_vậy , chúng_ta hãy cùng xem việc di_chuyển các đoạn l_1 , r_1 thành l_2 , r_2 : Di_chuyển l_1 \\rightarrow l_2 : Nếu l_1 và l_2 cùng block : Với mỗi thao_tác , độ phức_tạp không quá \\sqrtN .\nDo_đó , độ phức_tạp trong trường_hợp này của cả Q thao_tác là O(Q \\sqrtN) .\nNếu l_1 và l_2 khác block : Vì ta ưu_tiên sort theo block chứa l , nên trường_hợp này xảy_ra không quá \\sqrtN lần .\nỞ trường_hợp này , ta mất độ phức_tạp tối_đa là O(N) , nên với tất_cả các thao_tác , độ phức_tạp là O(N \\sqrtN) .\nDi_chuyển r_1 \\rightarrow r_2 : Nếu l_1 và l_2 cùng block : Vì trong cùng một block r được sắp_xếp tăng dần , nên với mỗi block của l , ta chỉ mất độ phức_tạp tổng là O(N) .\nDo có \\sqrtN block khác_nhau của l , nên tổng_độ phức_tạp trong trường_hợp này là O(N \\sqrtN) .\nNếu l_1 và l_2 khác block : Như_trên đã phân_tích , ta chỉ_có \\sqrtN lần đổi block , mỗi lần đổi block ta mất độ phức_tạp O(N) để di_chuyển r .\nDo_đó tổng_độ phức_tạp của trường_hợp này là O(N \\sqrtN) .\nVậy , độ phức_tạp là O(N \\sqrtN + Q \\sqrtN) .\nÁp_dụng Sử_dụng Mos_Algorithm , bạn đã có_thể thu được một thuật_toán hoàn_chỉnh cho bài này với độ phức_tạp O(N \\sqrtN + Q \\sqrtN) : Sort tất_cả các truy_vấn theo Mos_Algorithm .\nGọi_S(N) là một mảng gồm N set (có thể cài bằng hash table (bảng băm)) .\nS(i) chứa tất_cả các số xuất_hiện đúng i lần .\nGọi_A(val) = số lần xuất_hiện của val .\nĐặt max là chỉ_số lớn nhất của mảng S mà S(max) khác rỗng .\nTa sẽ thêm và xóa_một số trong O(1) như_sau : Thêm 1 số v : Xóa v khỏi S(A(v)) .\nTăng_A(v) thêm 1 .\nThêm v vào S(A(v)) .\nNếu_A(v) gt; max , cập_nhật max .\nXóa 1 số v : Xóa v khỏi S(A(v)) .\nGiảm_A(v) đi 1 .\nThêm v vào S(A(v)) .\nNếu_S(max) rỗng , giảm max đi 1 .\nVì tổng_các thao_tác thêm và xóa khi áp_dụng Mos_Algorithm không quá O(N \\sqrtN + Q \\sqrtN) , ta thu được một thuật_toán với độ phức_tạp này .\nMở_rộng Với mục_đích làm_bài toán khó hơn , ta xét trường_hợp mà CTDL của ta chỉ cho_phép thực_hiện đúng 2 thao_tác : Insert : Thêm 1 phần_tử vào CTDL , thao_tác này có độ phức_tạp là O(logN) hoặc O(1) .\nSnapshot : Lưu lại trạng_thái hiện_tại của CTDL .\nThao_tác này có độ phức_tạp O(N) .\nRollback : Hồi_phục lại trạng_thái của CTDL ở lần Snapshot cuối .\nThao_tác này cũng có độ phức_tạp là O(N) .\nMột ví_dụ của CTDL loại này là Disjoint set , và việc xử_lý truy_vấn xuất_hiện trong bài_toán Codechef - GERALD07 .\nCách làm vẫn là áp_dụng Mos algorithm , tuy_nhiên vì không_thể xóa phần_tử , nên ta không_thể di_chuyển từ l_1 sang l_2 một_cách dễ_dàng được .\nĐể đơn_giản , chúng_ta chỉ xét những truy_vấn l , r mà l và r rơi vào 2 block khác_nhau .\nĐể giải_quyết việc không di_chuyển ngược được , sau khi trả_lời truy_vấn l , r , chúng_ta cần_dùng Rollback để đưa l về cuối block chứa l .\nSau_đó , khi trả_lời truy_vấn l_2 , r_2 , chúng_ta chỉ_cần thực_hiện Insert từ r+1 đến r_2 và từ l_2 đến cuối block chứa l_2 .\nChi_tiết cài_đặt : rt = sqrt ( n ); init (); // this initializes our data structure (clears it) snapshot (); for all queries q if q .\nr - q .\nl + 1 lt;= rt + 1 // we process light queries for j : = q .\nl to q .\nr insert ( j ); store answer for query q ; rollback (); last_bucket = - 1 ; for all queries q if q .\nr - q .\nl + 1 lt;= rt + 1 : continue ; bucket = q .\nl / rt ; if bucket ! = last_bucket init (); l = ( bucket + 1 ) rt ; // right border of the_bucket r = q .\nr ; for j : = l to r insert ( j ); last_bucket = bucket ; while r lt; q .\nr insert ( ++ r ); snapshot (); for j : = q .\nl to l - 1 insert ( j ); store answer for query q ; rollback (); Bài_tập áp_dụng Codeforces_Yandex 2011 Round 2 - D_Codechef - GERALD07\n", "tagged": "Tác_giả/N :/CH Nguyễn_RR/Np Thành_Trung/Np Bài_toán/N Cho/E một/M dãy_số/Np A/Ni gồm/V N/Ny phần_tử/N ./CH\nCần/V thực_hiện/V Q/Ny truy_vấn/Np ,/CH mỗi/L truy_vấn/Np (i/Np ,/CH j)/Np yêu_cầu/V tìm/V mode(A_i/Np ,/CH ./CH ./CH ./CH ,/CH A_j)/Np ./CH\n(Mode/Np của/E một_tập/Np hợp/V là/V giá_trị/N xuất_hiện/V nhiều/A lần/N nhất/A trong/E tập_hợp/N đó)/Np ./CH\nGiới_hạn/V :/CH N/Ny ,/CH Q/Ny ,/CH A_i/Np \\le/Np 105/Np ./CH\nKhi/N đọc/V đề/V một/M bài_toán/N truy_vấn/Np kiểu/N này/P ,/CH có_lẽ/X CTDL/Np đầu_tiên/A mà/C các/L bạn/N nghĩ/V đến_là/Np Interval_Tree/Np ./CH\nNhưng/C có_điều/X gì/P đó/P không/R ổn/A trong/E bài/N này/P :/CH Khi/N có/V thông_tin/N của/E 2/M nút/N con/Nc l/Ny ,/CH mid/Np và/Cc mid+1/Np ,/CH r/Np ,/CH rất/R khó/A để/E tìm/V được/V bất_kỳ/A thông_tin/N hữu_ích/A nào/P của/E l/Ny ,/CH r/Np ./CH\nDuyệt/V Chúng_ta/P xuất_phát/V từ/E thuật_toán/N duyệt/V hồn_nhiên/A như_sau/Np :/CH Với/E mỗi/L truy_vấn/Np ,/CH ta/P for/Np từ/E trái/Nc sang/V phải/V ,/CH đếm_số/Np lần/N xuất_hiện/V ./CH\nTrong_khi/Np đếm/V thì/C ta_cập/Np nhật/N kết_quả/N ./CH\nCode/Np đơn_giản/A như_sau/Np :/CH function/Np mode/Np (/CH l/Ny ,/CH r/Np )/CH :/CH //CH Khởi/V tạo/V mảng/N count/Np =/CH toàn/R 0/M res/Np =/CH -/CH 1/M ;/CH for/Np i/M =/CH l/Ny ./CH ./CH\nr/Np :/CH count/Np A/Ni i/M +=/Np 1/M ;/CH if/Np res/Np ==/Np -/CH 1/M or/Np count/Np A/Ni i/M gt;/Np count/Np res/Np :/CH res/Np =/CH A/Ni i/M ;/CH return/Np res/Np ;/CH Dễ/A thấy/V ,/CH thuật_toán/N duyệt/V này/P có/V độ/N phức_tạp/A O(N_Q)/Np ./CH\nCó/V 2/M lý_do/N chính/T khiến/V thuật_toán/N này/P chạy/V chậm/A :/CH Khởi/V tạo/V mảng/N count/Np mỗi/L lần/N mất/V O(N)/Np ./CH\nVới/E mỗi/L truy_vấn/Np ,/CH phải/V tính/V lại/R mảng/N count/Np từ_đầu/Np ./CH\nTa/P có_thể/R cải_tiến/V được/V như_sau/Np :/CH Sau/E khi/N trả_lời/V truy_vấn/Np l_1/Np ,/CH r_1/Np ,/CH để/E trả_lời/V truy_vấn/Np l_2/Np ,/CH r_2/Np ,/CH bạn/N chỉ_cần/Np thay_đổi/V mảng/N đếm/V một_cách/N phù_hợp/V ./CH\nCụ_thể/A :/CH Nếu/C l_2/Np gt;/Np l_1/Np ,/CH giảm/V số/N lần/N xuất_hiện/V của/E A_l_1/Np ,/CH ./CH ./CH ./CH ,/CH A_l_2-1/Np Nếu/C l_2/Np lt;/Np l_1/Np ,/CH tăng/V số/N lần/N xuất_hiện/V của/E A_l_2/Np ,/CH ./CH ./CH ./CH ,/CH A_l_1-1/Np Tương_tự/A với/E r_1/Np và/Cc r_2/Np ./CH\nĐể/E cập_nhật/V số/N lần/N xuất_hiện/V lớn/A nhất_thì/Np có_thể/R dùng/V thêm/V set/N ./CH\nNhư_vậy/X ,/CH độ/N phức_tạp/A của/E ta/P là/V tổng/N l_i/Np -/CH l_i-1/Np +/CH r_i/Np -/CH r_i-1/Np ,/CH nhân/N thêm/V \\mathcalO(logN)/Np để/E đếm/V và/Cc tìm/V phần_tử/N lớn/A nhất/A của/E mảng/N đếm/V ./CH\nThuật_toán/N Mo/Np Thuật_toán/N Mo/Np là/V một_cách/N sắp_xếp/V lại/R các/L truy_vấn/Np ,/CH sao_cho/Np tổng/N l_i/Np -/CH l_i-1/Np +/CH r_i/Np -/CH r_i-1/Np không/R quá/R O(N/Np \\sqrtN/Np +/CH Q/Ny \\sqrtN)/Np ./CH\nThứ_tự/N các/L truy_vấn/Np được/V định_nghĩa/N qua/V hàm/Np so_sánh/V dưới_đây/Np ./CH\nS/Y =/CH sqrt/Np (/CH N/Ny );/CH bool/Np cmp/Np (/CH Query_A/Np ,/CH Query_B/Np )/CH //CH so_sánh/V 2/M truy_vấn/Np if/Np (/CH A/Ni ./CH\nl/Ny //CH S/Y !/CH =/CH B/Ni ./CH\nl/Ny //CH S/Y )/CH return/Np A/Ni ./CH\nl/Ny //CH S/Y lt;/Np B/Ni ./CH\nl/Ny //CH S/Y ;/CH return/Np A/Ni ./CH\nr/Np lt;/Np B/Ni ./CH\nr/Np ;/CH Giải_thích/V :/CH Ta/P chia/V dãy/Nc thành/V các/L block/V (nhóm)/Np độ_dài/Np S/Y =/CH \\sqrtN/Np ./CH\nNếu/C đầu/N trái/Nc của/E truy_vấn/Np nằm/V ở/E 2/M block/V khác_nhau/Np ,/CH ta/P sắp_xếp/V theo/V đầu/N trái/Nc ./CH\nNgược_lại/X (đầu/Np trái/Nc của/E truy_vấn/Np nằm/V ở/E cùng/A 1/M block)/Np ,/CH ta/P sắp_xếp/V theo/V đầu/N phải/V ./CH\nChứng_minh/V :/CH Mos/Np algorithm/Np có/V độ/N phức_tạp/A là/V O(N/Np \\sqrtN/Np +/CH Q/Ny \\sqrtN)/Np ./CH\nĐể/E hiểu/V tại_sao/X độ/N phức_tạp/A của/E thuật_toán/N đạt/V được/V như_vậy/X ,/CH chúng_ta/P hãy/R cùng/A xem/V việc/N di_chuyển/V các/L đoạn/Nc l_1/Np ,/CH r_1/Np thành/V l_2/Np ,/CH r_2/Np :/CH Di_chuyển/V l_1/Np \\rightarrow/Np l_2/Np :/CH Nếu/C l_1/Np và/Cc l_2/Np cùng/A block/V :/CH Với/E mỗi/L thao_tác/V ,/CH độ/N phức_tạp/A không/R quá/R \\sqrtN/Np ./CH\nDo_đó/C ,/CH độ/N phức_tạp/A trong/E trường_hợp/N này/P của/E cả/P Q/Ny thao_tác/V là/V O(Q/Np \\sqrtN)/Np ./CH\nNếu/C l_1/Np và/Cc l_2/Np khác/A block/V :/CH Vì/E ta/P ưu_tiên/V sort/Np theo/V block/V chứa/V l/Ny ,/CH nên/C trường_hợp/N này/P xảy_ra/Np không/R quá/R \\sqrtN/Np lần/N ./CH\nỞ/E trường_hợp/N này/P ,/CH ta/P mất/V độ/N phức_tạp/A tối_đa/A là/V O(N)/Np ,/CH nên/C với/E tất_cả/P các/L thao_tác/V ,/CH độ/N phức_tạp/A là/V O(N/Np \\sqrtN)/Np ./CH\nDi_chuyển/V r_1/Np \\rightarrow/Np r_2/Np :/CH Nếu/C l_1/Np và/Cc l_2/Np cùng/A block/V :/CH Vì/E trong/E cùng/A một/M block/V r/Np được/V sắp_xếp/V tăng/V dần/R ,/CH nên/C với/E mỗi/L block/V của/E l/Ny ,/CH ta/P chỉ/R mất/V độ/N phức_tạp/A tổng/N là/V O(N)/Np ./CH\nDo/E có/V \\sqrtN/Np block/V khác_nhau/Np của/E l/Ny ,/CH nên/C tổng_độ/Np phức_tạp/A trong/E trường_hợp/N này/P là/V O(N/Np \\sqrtN)/Np ./CH\nNếu/C l_1/Np và/Cc l_2/Np khác/A block/V :/CH Như_trên/Np đã/R phân_tích/V ,/CH ta/P chỉ_có/Np \\sqrtN/Np lần/N đổi/V block/V ,/CH mỗi/L lần/N đổi/V block/V ta/P mất/V độ/N phức_tạp/A O(N)/Np để/E di_chuyển/V r/Np ./CH\nDo_đó/C tổng_độ/Np phức_tạp/A của/E trường_hợp/N này/P là/V O(N/Np \\sqrtN)/Np ./CH\nVậy/P ,/CH độ/N phức_tạp/A là/V O(N/Np \\sqrtN/Np +/CH Q/Ny \\sqrtN)/Np ./CH\nÁp_dụng/V Sử_dụng/V Mos_Algorithm/Np ,/CH bạn/N đã/R có_thể/R thu/V được/V một/M thuật_toán/N hoàn_chỉnh/V cho/E bài/N này/P với/E độ/N phức_tạp/A O(N/Np \\sqrtN/Np +/CH Q/Ny \\sqrtN)/Np :/CH Sort/Np tất_cả/P các/L truy_vấn/Np theo/V Mos_Algorithm/Np ./CH\nGọi_S(N)/Np là/V một/M mảng/N gồm/V N/Ny set/N (có/Np thể/N cài/V bằng/E hash/Np table/Np (bảng/Np băm))/Np ./CH\nS(i)/Np chứa/V tất_cả/P các/L số/N xuất_hiện/V đúng/A i/M lần/N ./CH\nGọi_A(val)/Np =/CH số/N lần/N xuất_hiện/V của/E val/Np ./CH\nĐặt/V max/Np là/V chỉ_số/N lớn/A nhất/A của/E mảng/N S/Y mà/C S(max)/Np khác/A rỗng/A ./CH\nTa/P sẽ/R thêm/V và/Cc xóa_một/Np số/N trong/E O(1)/Np như_sau/Np :/CH Thêm/V 1/M số/N v/Nu :/CH Xóa/V v/Nu khỏi/V S(A(v))/Np ./CH\nTăng_A(v)/Np thêm/V 1/M ./CH\nThêm/V v/Nu vào/E S(A(v))/Np ./CH\nNếu_A(v)/Np gt;/Np max/Np ,/CH cập_nhật/V max/Np ./CH\nXóa/V 1/M số/N v/Nu :/CH Xóa/V v/Nu khỏi/V S(A(v))/Np ./CH\nGiảm_A(v)/Np đi/V 1/M ./CH\nThêm/V v/Nu vào/E S(A(v))/Np ./CH\nNếu_S(max)/Np rỗng/A ,/CH giảm/V max/Np đi/V 1/M ./CH\nVì/E tổng_các/Np thao_tác/V thêm/V và/Cc xóa/V khi/N áp_dụng/V Mos_Algorithm/Np không/R quá/R O(N/Np \\sqrtN/Np +/CH Q/Ny \\sqrtN)/Np ,/CH ta/P thu/V được/V một/M thuật_toán/N với/E độ/N phức_tạp/A này/P ./CH\nMở_rộng/V Với/E mục_đích/N làm_bài/Np toán/N khó/A hơn/A ,/CH ta/P xét/V trường_hợp/N mà/C CTDL/Np của/E ta/P chỉ/R cho_phép/V thực_hiện/V đúng/A 2/M thao_tác/V :/CH Insert/Np :/CH Thêm/V 1/M phần_tử/N vào/E CTDL/Np ,/CH thao_tác/V này/P có/V độ/N phức_tạp/A là/V O(logN)/Np hoặc/Cc O(1)/Np ./CH\nSnapshot/Np :/CH Lưu/V lại/R trạng_thái/N hiện_tại/N của/E CTDL/Np ./CH\nThao_tác/V này/P có/V độ/N phức_tạp/A O(N)/Np ./CH\nRollback/Np :/CH Hồi_phục/V lại/R trạng_thái/N của/E CTDL/Np ở/E lần/N Snapshot/Np cuối/N ./CH\nThao_tác/V này/P cũng/R có/V độ/N phức_tạp/A là/V O(N)/Np ./CH\nMột/M ví_dụ/C của/E CTDL/Np loại/N này/P là/V Disjoint/Np set/N ,/CH và/Cc việc/N xử_lý/V truy_vấn/Np xuất_hiện/V trong/E bài_toán/N Codechef/Np -/CH GERALD07/Np ./CH\nCách/N làm/V vẫn/R là/V áp_dụng/V Mos/Np algorithm/Np ,/CH tuy_nhiên/C vì/E không_thể/R xóa/V phần_tử/N ,/CH nên/C ta/P không_thể/R di_chuyển/V từ/E l_1/Np sang/V l_2/Np một_cách/N dễ_dàng/A được/V ./CH\nĐể/E đơn_giản/A ,/CH chúng_ta/P chỉ/R xét/V những/L truy_vấn/Np l/Ny ,/CH r/Np mà/C l/Ny và/Cc r/Np rơi/V vào/E 2/M block/V khác_nhau/Np ./CH\nĐể/E giải_quyết/V việc/N không/R di_chuyển/V ngược/A được/V ,/CH sau/E khi/N trả_lời/V truy_vấn/Np l/Ny ,/CH r/Np ,/CH chúng_ta/P cần_dùng/Np Rollback/Np để/E đưa/V l/Ny về/E cuối/N block/V chứa/V l/Ny ./CH\nSau_đó/Np ,/CH khi/N trả_lời/V truy_vấn/Np l_2/Np ,/CH r_2/Np ,/CH chúng_ta/P chỉ_cần/Np thực_hiện/V Insert/Np từ/E r+1/Np đến/E r_2/Np và/Cc từ/E l_2/Np đến/E cuối/N block/V chứa/V l_2/Np ./CH\nChi_tiết/N cài_đặt/V :/CH rt/Np =/CH sqrt/Np (/CH n/Ny );/CH init/Np ();/Np //CH this/Np initializes/Np our/Np data/Np structure/Np (clears/Np it)/Np snapshot/Np ();/Np for/Np all/Np queries/Np q/Ny if/Np q/Ny ./CH\nr/Np -/CH q/Ny ./CH\nl/Ny +/CH 1/M lt;=/Np rt/Np +/CH 1/M //CH we/Np process/Np light/Np queries/Np for/Np j/Np :/CH =/CH q/Ny ./CH\nl/Ny to/A q/Ny ./CH\nr/Np insert/Np (/CH j/Np );/CH store/Np answer/Np for/Np query/Np q/Ny ;/CH rollback/Np ();/Np last_bucket/Np =/CH -/CH 1/M ;/CH for/Np all/Np queries/Np q/Ny if/Np q/Ny ./CH\nr/Np -/CH q/Ny ./CH\nl/Ny +/CH 1/M lt;=/Np rt/Np +/CH 1/M :/CH continue/Np ;/CH bucket/Np =/CH q/Ny ./CH\nl/Ny //CH rt/Np ;/CH if/Np bucket/Np !/CH =/CH last_bucket/Np init/Np ();/Np l/Ny =/CH (/CH bucket/Np +/CH 1/M )/CH rt/Np ;/CH //CH right/Np border/Np of/E the_bucket/Np r/Np =/CH q/Ny ./CH\nr/Np ;/CH for/Np j/Np :/CH =/CH l/Ny to/A r/Np insert/Np (/CH j/Np );/CH last_bucket/Np =/CH bucket/Np ;/CH while/Np r/Np lt;/Np q/Ny ./CH\nr/Np insert/Np (/CH ++/Np r/Np );/CH snapshot/Np ();/Np for/Np j/Np :/CH =/CH q/Ny ./CH\nl/Ny to/A l/Ny -/CH 1/M insert/Np (/CH j/Np );/CH store/Np answer/Np for/Np query/Np q/Ny ;/CH rollback/Np ();/Np Bài_tập/Np áp_dụng/V Codeforces_Yandex/Np 2011/M Round/Np 2/M -/CH D_Codechef/Np -/CH GERALD07/Np\n", "title": "Mo algorithm\n", "link": "http://vnoi.info/wiki/algo/data-structures/mo-algorithm\n"}