{"content": "Biên_soạn : Đỗ_Việt_Anh (lion_it) Email : dovietanh . 95gmail . com Nguồn : wcipeg . com/wiki Table of_Contents 0 .\nKiến_thức cần biết trước 1 .\nGiới_thiệu chung 1 . 0 . Tính_chất 1 . 1 . Ứng_dụng 1 . 2 . Cài_đặt 2 .\nCác thao_tác trên Binary_Heap 2 . 0 . Các thao_tác thường_dùng với Binary_Heap là 2 . 1 . Tìm phần_tử lớn nhất 2 . 2 . Thêm một nút (node) trên cây 2 . 3 . Xóa nút gốc khỏi cây 2 . 4 . Tăng , giảm nhãn của một nút 2 . 5 . Xây đựng Binary_Heap từ tập N phần_tử 3 .\nCâu_hỏi thêm cho bạn_đọc 0 .\nKiến_thức cần biết trước Để đọc và hiểu được bài viết các bạn cần có kiến_thức về cấu_trúc cây ( tree ) và cây nhị_phân đầy_đủ ( complete binary tree ) 1 .\nGiới_thiệu chung 1 . 0 . Tính_chất Một cấu_trúc Binary_Heap thỏa_mãn 2 điều_kiện sau : Tính_chất 1 - Binary ( TC1 ) : Là một cây nhị_phân đầy_đủ ( complete binary tree ) Tính_chất 2 - Heap ( TC2 ) Mỗi nút (node) trên cây đều chứa một nhãn lớn hơn hoặc bằng các con của nó (nếu có) và nhỏ hơn hoặc bằng nút cha (trừ nút gốc là và nó là nút lớn nhất) .\nMột cấu_trúc như_trên được gọi_là max binary heap vì nhãn ở gốc (root) , tương_tự ta có_thể thay_đổi TC 2 để có được min binary heap với nhãn ở gốc là nhỏ nhất trong cây .\n1 . 1 . Ứng_dụng Binary_Heap được dùng để cài_đặt priority_queue (trong C++ , java . . . ) hay dùng để tăng_tốc các thuật_toán như Dijkstra , Prim . .\n1 . 2 . Cài_đặt Trong_C++ , bạn có_thể sử_dụng CTDL priority_queue hoặc set , vì_vậy việc tự cài_đặt lại là không cần_thiết .\nVới_Pascal , bạn có_thể tìm_hiểu cách cài_đặt trong quyển sách của thầy Lê_Minh Hoàng 2 .\nCác thao_tác trên Binary_Heap 2 . 0 . Các thao_tác thường_dùng với Binary_Heap là Tìm nhãn lớn nhất trên Binary_Heap (nút gốc) Thêm một nút vào Binary_Heap Xóa_bỏ nút gốc (root) hay nhãn lớn nhất trên Binary_Heap Xây_dựng một Binary_Heap từ một_tập N phần_tử ( Các bạn có_thể vào visualgo để có_thể hình_dung cụ_thể về các thao_tác trên Heap ) Đặt h là độ_cao của cây .\nNút gốc ở độ sâu 0 , 2 nút con của gốc ở độ sâu 1 , và nút sâu nhất có độ sâu là h .\nỞ độ sâu k , cây có tối_đa 2k nút , do_đó tổng_số nút trên cây N \\le 2h+1 .\n2 . 1 . Tìm phần_tử lớn nhất Rõ_ràng gốc (root) luôn chứa nhãn lớn nhất theo TC2 (các nút con luôn không nhỏ hơn nút cha) Độ phức_tạp thuật_toán : O(1) .\nThông_thường thao_tác này sẽ đi_kèm với thao_tác xóa nút gốc để tìm nhãn tiếp_theo (như khi sort) .\nThao_tác xóa sẽ được miêu_tả ở mục 2 . 3 2 . 2 . Thêm một nút (node) trên cây Chọn vị_trí để thêm nút : Nếu_Binary_Heap là rỗng_ta chỉ_cần cho nút cần thêm làm gốc .\nNếu_Binary_Heap không rỗng thêm nó vào vị_trí phải nhất ở của lớp đáy , nếu lớp đáy đã đủ (số phần_tử đúng bằng 2h) thêm nút này vào lớp mới .\nVun đống từ dưới lên (bottom-up heapify) : Việc thêm như_trên sẽ đảm_bảo được tính_chất TC1 cây nhị_phân đầy_đủ (complete binary tree) nhưng TC2 có_thể không được thỏa_mãn .\nNếu nút mới này nhỏ hơn nút cha của nó ta không cần phải làm_gì thêm nữa .\nNgược_lại nếu phần_tử mới lớn hơn nút cha_ta đổi chỗ 2 nút cho nhau , so_sánh với nút cha mới đổi chỗ nếu nó lớn hơn nút cha cứ thế đến khi nó nhỏ hoặc bằng nút cha hoặc nó là gốc (không còn nút cha nào nữa) .\nĐộ phức_tạp : Quá_trình chọn vị_trí cho nút chỉ mất O(1) Quá_trình vun đống từ dưới lên (bottom-up heapify) : ta có_thể thấy số lần so_sánh và đổi chỗ 2 phần_tử không quá_độ sâu h của cây nhị_phân hay (\\le log(N+1) với N là số nút hiện_có trên cây) .\nĐộ phức_tạp của cả quá_trình này là O(logN) 2 . 3 . Xóa nút gốc khỏi cây_Ta chỉ_có thể xóa phần_tử lớn nhất hay góc của Binary_Heap ra khỏi cây .\nNếu cây chỉ_có nút gốc ta xóa nó khỏi cây , nếu_không Gán nhãn nút góc bằng nhãn của nút phải nhất ở lớp sâu nhất Xóa nút phải nhất ở lớp sâu nhất đi (nút này vừa được chuyển nhãn lên gốc) Khi này tính_chất TC1 vấn được đảm_bảo nhưng TC2 thì_có thể không , do_đó ta cần vun đống từ trên xuống (top-down heapify) : So_sánh nhãn nút gốc với nút lớn hơn trong 2 nút con của nó (nếu chỉ_có 1 nút con , thì nút con đó được coi là nút lớn hơn) Nếu nó nhỏ hơn nút con lớn hơn của nó : đổi chỗ 2 nút này , tiếp_tục xét tiếp với nút con mới cho_đến khi nó lớn hơn hoặc bằng nút con lớn hơn của nó hoặc nó không có_con hay nút lá (leaf) Độ phức_tạp : Nếu cây chỉ_có duy_nhất nút gốc độ phức_tạp là O(1) .\nNếu cây có N nút : Xóa nút phải nhất ở lớp sâu nhất khỏi cây có độ phức_tạp O(1)_Vun đống từ trên xuống (top-down heapify) cũng_như bottom-up heapify không vượt_quá độ sâu h của cây nên có độ phức_tạp là O(logN) 2 . 4 . Tăng , giảm nhãn của một nút Trước_tiên cần xác_định vị_trí của nút ta cần thay_đổi nhãn Thay_đổi nhãn Vun đống heap Nếu nhãn tăng so_với nhãn trước đó cần thực_hiện bottom-up heapify như khi thêm nút Nếu nhãn giảm đi so_với nhãn trước đó cần thưc hiện top-down heapify như khi xóa nút .\nĐộ phức_tạp : độ thức tạp của thao_tác này bằng độ phức_tạp của top-down heapify hoặc bottom-up heapify hay bằng O(logN) 2 . 5 . Xây đựng Binary_Heap từ tập N phần_tử Một_cách đơn_giản ta có_thể thực_hiện N phép thêm nút .\nNhưng có_một kĩ_thuật hiệu_quả hơn để xây_dựng binary heap được gọi_là bottom-up construction .\nBottom-up construction : Kỹ_thuật này yêu_cầu xây_dựng một cây nhị_phân đầy_đủ trước và thực_hiện top-down heapify các nút trên cây theo tứ tự giảm_dần độ_cao của cây (từ các nút lá lên các nút cha và tiếp_tục cho_đến gốc) .\nChứng_minh kết_quả của cách xây_dựng là một Binary_Heap không_phải là khó .\nĐộ phức_tạp : Khi thực_hiện N bước thêm nút ta có_thể thấy độ phức_tạp là O(log1 + log2 + . . .\n+ logN) = O(NlogN) .\nỞ cách xây_dựng thứ 2 ta thấy nếu một nút ở độ xâu k nó sẽ mất không quá h - k lần so_sánh với nút con (nhắc lại h là độ sâu của cây và số nút của cây N lt; 2h+1) và một_nửa số nút trên cây là lá và sẽ không_phải so_sánh với nút con nào cả , ta suy ra được : Ở độ sâu k = h-1 có 2h-1 nút số phép so_sánh là 1 2h-1 = 1/4 N_Ở độ sâu k = h-2 có 2h-2 nút số phép so_sánh là 2 2h-2 = 2/8 N_Ở độ sâu k = h-3 có 2h-3 nút số phép so_sánh là 3 2h-3 = 3/16 N . . .\nỞ độ sâu k = 0 (gốc) có 1 nút số phép so_sánh là h 1 = h/N N Tổng_hợp lại ta có : 1/4 N + 2/8 N + 3/16 N + . . .\n+ h/N N = N phép so_sánh 3 .\nCâu_hỏi thêm cho bạn_đọc Tại_sao Binary_Heap nên là một cây nhị_phân đầy_đủ TC1 ?\nNếu_Heap không_phải là một cây nhị_phân mà là một cây tam_phân , tứ_phân , k-phân thì độ phức_tạp của các thao_tác sẽ thay_đổi thế_nào ?\nTC1 cần thêm điểu kiện tập nhãn phải là một totally ordered set (2 giá_trị bất_kì trong tập đều có_thể so_sánh được và có tính_chất bắc_cầu trong các phép so_sánh , ví_dụ như_tập số_thực \\mathbbR)\n", "tagged": "Biên_soạn/V :/CH Đỗ_Việt_Anh/Np (lion_it)/Np Email/Nb :/CH dovietanh/Np ./CH 95gmail/Np ./CH com/Np Nguồn/N :/CH wcipeg/Np ./CH com/Np Table/Np of_Contents/Np 0/M ./CH\nKiến_thức/N cần/V biết/V trước/E 1/M ./CH\nGiới_thiệu/V chung/A 1/M ./CH 0/M ./CH Tính_chất/N 1/M ./CH 1/M ./CH Ứng_dụng/V 1/M ./CH 2/M ./CH Cài_đặt/V 2/M ./CH\nCác/L thao_tác/V trên/E Binary_Heap/Np 2/M ./CH 0/M ./CH Các/L thao_tác/V thường_dùng/Np với/E Binary_Heap/Np là/V 2/M ./CH 1/M ./CH Tìm/V phần_tử/N lớn/A nhất/A 2/M ./CH 2/M ./CH Thêm/V một/M nút/N (node)/Np trên/E cây/N 2/M ./CH 3/M ./CH Xóa/V nút/N gốc/N khỏi/V cây/N 2/M ./CH 4/M ./CH Tăng/V ,/CH giảm/V nhãn/N của/E một/M nút/N 2/M ./CH 5/M ./CH Xây/V đựng/V Binary_Heap/Np từ/E tập/V N/Ny phần_tử/N 3/M ./CH\nCâu_hỏi/N thêm/V cho/E bạn_đọc/N 0/M ./CH\nKiến_thức/N cần/V biết/V trước/E Để/E đọc/V và/Cc hiểu/V được/V bài/N viết/V các/L bạn/N cần/V có/V kiến_thức/N về/E cấu_trúc/N cây/N (/CH tree/Np )/CH và/Cc cây/N nhị_phân/Np đầy_đủ/A (/CH complete/Np binary/Np tree/Np )/CH 1/M ./CH\nGiới_thiệu/V chung/A 1/M ./CH 0/M ./CH Tính_chất/N Một/M cấu_trúc/N Binary_Heap/Np thỏa_mãn/V 2/M điều_kiện/N sau/E :/CH Tính_chất/N 1/M -/CH Binary/Np (/CH TC1/Np )/CH :/CH Là/V một/M cây/N nhị_phân/Np đầy_đủ/A (/CH complete/Np binary/Np tree/Np )/CH Tính_chất/N 2/M -/CH Heap/Np (/CH TC2/Np )/CH Mỗi/L nút/N (node)/Np trên/E cây/N đều/R chứa/V một/M nhãn/N lớn/A hơn/A hoặc/Cc bằng/E các/L con/Nc của/E nó/P (nếu/Np có)/Np và/Cc nhỏ/A hơn/A hoặc/Cc bằng/E nút/N cha/N (trừ/Np nút/N gốc/N là/V và/Cc nó/P là/V nút/N lớn/A nhất)/Np ./CH\nMột/M cấu_trúc/N như_trên/Np được/V gọi_là/V max/Np binary/Np heap/Np vì/E nhãn/N ở/E gốc/N (root)/Np ,/CH tương_tự/A ta/P có_thể/R thay_đổi/V TC/Np 2/M để/E có/V được/V min/Np binary/Np heap/Np với/E nhãn/N ở/E gốc/N là/V nhỏ/A nhất/A trong/E cây/N ./CH\n1/M ./CH 1/M ./CH Ứng_dụng/V Binary_Heap/Np được/V dùng/V để/E cài_đặt/V priority_queue/Np (trong/Np C++/Np ,/CH java/Np ./CH ./CH ./CH )/CH hay/Cc dùng/V để/E tăng_tốc/Np các/L thuật_toán/N như/C Dijkstra/Np ,/CH Prim/Np ./CH ./CH\n1/M ./CH 2/M ./CH Cài_đặt/V Trong_C++/Np ,/CH bạn/N có_thể/R sử_dụng/V CTDL/Np priority_queue/Np hoặc/Cc set/N ,/CH vì_vậy/C việc/N tự/P cài_đặt/V lại/R là/V không/R cần_thiết/A ./CH\nVới_Pascal/Np ,/CH bạn/N có_thể/R tìm_hiểu/V cách/N cài_đặt/V trong/E quyển/Nc sách/N của/E thầy/N Lê_Minh/Np Hoàng/V 2/M ./CH\nCác/L thao_tác/V trên/E Binary_Heap/Np 2/M ./CH 0/M ./CH Các/L thao_tác/V thường_dùng/Np với/E Binary_Heap/Np là/V Tìm/V nhãn/N lớn/A nhất/A trên/E Binary_Heap/Np (nút/Np gốc)/Np Thêm/V một/M nút/N vào/E Binary_Heap/Np Xóa_bỏ/V nút/N gốc/N (root)/Np hay/Cc nhãn/N lớn/A nhất/A trên/E Binary_Heap/Np Xây_dựng/V một/M Binary_Heap/Np từ/E một_tập/Np N/Ny phần_tử/N (/CH Các/L bạn/N có_thể/R vào/E visualgo/Np để/E có_thể/R hình_dung/V cụ_thể/A về/E các/L thao_tác/V trên/E Heap/Np )/CH Đặt/V h/Ny là/V độ_cao/Np của/E cây/N ./CH\nNút/N gốc/N ở/E độ/N sâu/A 0/M ,/CH 2/M nút/N con/Nc của/E gốc/N ở/E độ/N sâu/A 1/M ,/CH và/Cc nút/N sâu/A nhất/A có/V độ/N sâu/A là/V h/Ny ./CH\nỞ/E độ/N sâu/A k/N ,/CH cây/N có/V tối_đa/A 2k/Np nút/N ,/CH do_đó/C tổng_số/N nút/N trên/E cây/N N/Ny \\le/Np 2h+1/Np ./CH\n2/M ./CH 1/M ./CH Tìm/V phần_tử/N lớn/A nhất/A Rõ_ràng/A gốc/N (root)/Np luôn/R chứa/V nhãn/N lớn/A nhất/A theo/V TC2/Np (các/Np nút/N con/Nc luôn/R không/R nhỏ/A hơn/A nút/N cha)/Np Độ/N phức_tạp/A thuật_toán/N :/CH O(1)/Np ./CH\nThông_thường/A thao_tác/V này/P sẽ/R đi_kèm/Np với/E thao_tác/V xóa/V nút/N gốc/N để/E tìm/V nhãn/N tiếp_theo/V (như/Np khi/N sort)/Np ./CH\nThao_tác/V xóa/V sẽ/R được/V miêu_tả/V ở/E mục/N 2/M ./CH 3/M 2/M ./CH 2/M ./CH Thêm/V một/M nút/N (node)/Np trên/E cây/N Chọn/V vị_trí/N để/E thêm/V nút/N :/CH Nếu_Binary_Heap/Np là/V rỗng_ta/Np chỉ_cần/Np cho/E nút/N cần/V thêm/V làm/V gốc/N ./CH\nNếu_Binary_Heap/Np không/R rỗng/A thêm/V nó/P vào/E vị_trí/N phải/V nhất/A ở/E của/E lớp/N đáy/N ,/CH nếu/C lớp/N đáy/N đã/R đủ/A (số/Np phần_tử/N đúng/A bằng/E 2h)/Np thêm/V nút/N này/P vào/E lớp/N mới/R ./CH\nVun/V đống/N từ/E dưới/E lên/V (bottom-up/Np heapify)/Np :/CH Việc/N thêm/V như_trên/Np sẽ/R đảm_bảo/V được/V tính_chất/N TC1/Np cây/N nhị_phân/Np đầy_đủ/A (complete/Np binary/Np tree)/Np nhưng/C TC2/Np có_thể/R không/R được/V thỏa_mãn/V ./CH\nNếu/C nút/N mới/R này/P nhỏ/A hơn/A nút/N cha/N của/E nó/P ta/P không/R cần/V phải/V làm_gì/X thêm/V nữa/R ./CH\nNgược_lại/X nếu/C phần_tử/N mới/R lớn/A hơn/A nút/N cha_ta/Np đổi/V chỗ/N 2/M nút/N cho/E nhau/N ,/CH so_sánh/V với/E nút/N cha/N mới/R đổi/V chỗ/N nếu/C nó/P lớn/A hơn/A nút/N cha/N cứ/R thế/P đến/E khi/N nó/P nhỏ/A hoặc/Cc bằng/E nút/N cha/N hoặc/Cc nó/P là/V gốc/N (không/Np còn/R nút/N cha/N nào/P nữa)/Np ./CH\nĐộ/N phức_tạp/A :/CH Quá_trình/N chọn/V vị_trí/N cho/E nút/N chỉ/R mất/V O(1)/Np Quá_trình/N vun/V đống/N từ/E dưới/E lên/V (bottom-up/Np heapify)/Np :/CH ta/P có_thể/R thấy/V số/N lần/N so_sánh/V và/Cc đổi/V chỗ/N 2/M phần_tử/N không/R quá_độ/N sâu/A h/Ny của/E cây/N nhị_phân/Np hay/Cc (\\le/Np log(N+1)/Np với/E N/Ny là/V số/N nút/N hiện_có/Np trên/E cây)/Np ./CH\nĐộ/N phức_tạp/A của/E cả/P quá_trình/N này/P là/V O(logN)/Np 2/M ./CH 3/M ./CH Xóa/V nút/N gốc/N khỏi/V cây_Ta/Np chỉ_có/Np thể/N xóa/V phần_tử/N lớn/A nhất/A hay/Cc góc/N của/E Binary_Heap/Np ra/V khỏi/V cây/N ./CH\nNếu/C cây/N chỉ_có/Np nút/N gốc/N ta/P xóa/V nó/P khỏi/V cây/N ,/CH nếu_không/Np Gán/V nhãn/N nút/N góc/N bằng/E nhãn/N của/E nút/N phải/V nhất/A ở/E lớp/N sâu/A nhất/A Xóa/V nút/N phải/V nhất/A ở/E lớp/N sâu/A nhất/A đi/V (nút/Np này/P vừa/R được/V chuyển/V nhãn/N lên/V gốc)/Np Khi/N này/P tính_chất/N TC1/Np vấn/Np được/V đảm_bảo/V nhưng/C TC2/Np thì_có/X thể/N không/R ,/CH do_đó/C ta/P cần/V vun/V đống/N từ/E trên/E xuống/V (top-down/Np heapify)/Np :/CH So_sánh/V nhãn/N nút/N gốc/N với/E nút/N lớn/A hơn/A trong/E 2/M nút/N con/Nc của/E nó/P (nếu/Np chỉ_có/Np 1/M nút/N con/Nc ,/CH thì/C nút/N con/Nc đó/P được/V coi/V là/V nút/N lớn/A hơn)/Np Nếu/C nó/P nhỏ/A hơn/A nút/N con/Nc lớn/A hơn/A của/E nó/P :/CH đổi/V chỗ/N 2/M nút/N này/P ,/CH tiếp_tục/V xét/V tiếp/V với/E nút/N con/Nc mới/R cho_đến/E khi/N nó/P lớn/A hơn/A hoặc/Cc bằng/E nút/N con/Nc lớn/A hơn/A của/E nó/P hoặc/Cc nó/P không/R có_con/Np hay/Cc nút/N lá/N (leaf)/Np Độ/N phức_tạp/A :/CH Nếu/C cây/N chỉ_có/Np duy_nhất/A nút/N gốc/N độ/N phức_tạp/A là/V O(1)/Np ./CH\nNếu/C cây/N có/V N/Ny nút/N :/CH Xóa/V nút/N phải/V nhất/A ở/E lớp/N sâu/A nhất/A khỏi/V cây/N có/V độ/N phức_tạp/A O(1)_Vun/Np đống/N từ/E trên/E xuống/V (top-down/Np heapify)/Np cũng_như/C bottom-up/Np heapify/Np không/R vượt_quá/Np độ/N sâu/A h/Ny của/E cây/N nên/C có/V độ/N phức_tạp/A là/V O(logN)/Np 2/M ./CH 4/M ./CH Tăng/V ,/CH giảm/V nhãn/N của/E một/M nút/N Trước_tiên/N cần/V xác_định/V vị_trí/N của/E nút/N ta/P cần/V thay_đổi/V nhãn/N Thay_đổi/V nhãn/N Vun/V đống/N heap/Np Nếu/C nhãn/N tăng/V so_với/Np nhãn/N trước/E đó/P cần/V thực_hiện/V bottom-up/Np heapify/Np như/C khi/N thêm/V nút/N Nếu/C nhãn/N giảm/V đi/V so_với/Np nhãn/N trước/E đó/P cần/V thưc/Np hiện/N top-down/Np heapify/Np như/C khi/N xóa/V nút/N ./CH\nĐộ/N phức_tạp/A :/CH độ/N thức/V tạp/A của/E thao_tác/V này/P bằng/E độ/N phức_tạp/A của/E top-down/Np heapify/Np hoặc/Cc bottom-up/Np heapify/Np hay/Cc bằng/E O(logN)/Np 2/M ./CH 5/M ./CH Xây/V đựng/V Binary_Heap/Np từ/E tập/V N/Ny phần_tử/N Một_cách/N đơn_giản/A ta/P có_thể/R thực_hiện/V N/Ny phép/N thêm/V nút/N ./CH\nNhưng/C có_một/Np kĩ_thuật/N hiệu_quả/N hơn/A để/E xây_dựng/V binary/Np heap/Np được/V gọi_là/V bottom-up/Np construction/Np ./CH\nBottom-up/Np construction/Np :/CH Kỹ_thuật/N này/P yêu_cầu/V xây_dựng/V một/M cây/N nhị_phân/Np đầy_đủ/A trước/E và/Cc thực_hiện/V top-down/Np heapify/Np các/L nút/N trên/E cây/N theo/V tứ/M tự/P giảm_dần/Np độ_cao/Np của/E cây/N (từ/Np các/L nút/N lá/N lên/V các/L nút/N cha/N và/Cc tiếp_tục/V cho_đến/E gốc)/Np ./CH\nChứng_minh/V kết_quả/N của/E cách/N xây_dựng/V là/V một/M Binary_Heap/Np không_phải/Np là/V khó/A ./CH\nĐộ/N phức_tạp/A :/CH Khi/N thực_hiện/V N/Ny bước/V thêm/V nút/N ta/P có_thể/R thấy/V độ/N phức_tạp/A là/V O(log1/Np +/CH log2/Np +/CH ./CH ./CH ./CH\n+/CH logN)/Np =/CH O(NlogN)/Np ./CH\nỞ/E cách/N xây_dựng/V thứ/N 2/M ta/P thấy/V nếu/C một/M nút/N ở/E độ/N xâu/Np k/N nó/P sẽ/R mất/V không/R quá/R h/Ny -/CH k/N lần/N so_sánh/V với/E nút/N con/Nc (nhắc/Np lại/R h/Ny là/V độ/N sâu/A của/E cây/N và/Cc số/N nút/N của/E cây/N N/Ny lt;/Np 2h+1)/Np và/Cc một_nửa/N số/N nút/N trên/E cây/N là/V lá/N và/Cc sẽ/R không_phải/Np so_sánh/V với/E nút/N con/Nc nào/P cả/P ,/CH ta/P suy/V ra/V được/V :/CH Ở/E độ/N sâu/A k/N =/CH h-1/Np có/V 2h-1/Np nút/N số/N phép/N so_sánh/V là/V 1/M 2h-1/Np =/CH 1/M N_Ở/Np độ/N sâu/A k/N =/CH h-2/Np có/V 2h-2/Np nút/N số/N phép/N so_sánh/V là/V 2/M 2h-2/Np =/CH 2/M N_Ở/Np độ/N sâu/A k/N =/CH h-3/Np có/V 2h-3/Np nút/N số/N phép/N so_sánh/V là/V 3/M 2h-3/Np =/CH 3/M N/Ny ./CH ./CH ./CH\nỞ/E độ/N sâu/A k/N =/CH 0/M (gốc)/Np có/V 1/M nút/N số/N phép/N so_sánh/V là/V h/Ny 1/M =/CH h/Ny N/Ny Tổng_hợp/V lại/R ta/P có/V :/CH 1/M N/Ny +/CH 2/M N/Ny +/CH 3/M N/Ny +/CH ./CH ./CH ./CH\n+/CH h/Ny N/Ny =/CH N/Ny phép/N so_sánh/V 3/M ./CH\nCâu_hỏi/N thêm/V cho/E bạn_đọc/N Tại_sao/X Binary_Heap/Np nên/C là/V một/M cây/N nhị_phân/Np đầy_đủ/A TC1/Np ?/CH\nNếu_Heap/Np không_phải/Np là/V một/M cây/N nhị_phân/Np mà/C là/V một/M cây/N tam_phân/Np ,/CH tứ_phân/Np ,/CH k-phân/Np thì/C độ/N phức_tạp/A của/E các/L thao_tác/V sẽ/R thay_đổi/V thế_nào/P ?/CH\nTC1/Np cần/V thêm/V điểu/Np kiện/V tập/V nhãn/N phải/V là/V một/M totally/Np ordered/Np set/N (2/Np giá_trị/N bất_kì/R trong/E tập/V đều/R có_thể/R so_sánh/V được/V và/Cc có/V tính_chất/N bắc_cầu/V trong/E các/L phép/N so_sánh/V ,/CH ví_dụ/C như_tập/Np số_thực/Np \\mathbbR)/Np\n", "title": "Binary Heap\n", "link": "http://vnoi.info/wiki/translate/wcipeg/Binary-Heap\n"}