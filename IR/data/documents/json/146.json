{"content": "Nguồn : HackerEarth và 1 số bài viết trên Wikipedia_Người dịch : Bùi_Việt Dũng_Table of_Contents Giới_thiệu Đồng dư_thức (Modulo) Ước_chung lớn nhất Thuật_toán \"ngây thơ\" (Naive Approach) Thuật_toán Euclid Thuật_toán Euclid mở_rộng (Extended Euclid_Algorithm) Giới_thiệu Các bài_toán trong lập_trình thi_đấu (competitive programming) mà liên_quan đến Toán_học thường sẽ rơi vào hai mảng là số_học (number theory) và hình_học .\nNếu bạn biết nhiều về số_học , bạn sẽ có khả_năng giải_quyết nhiều bài_toán khó và một nền_tảng tốt để giải_quyết nhiều bài_toán khác .\nCác bài_toán trong lập_trình thi_đấu thường đòi_hỏi bạn một cái nhìn sâu_sắc , vì_vậy chỉ biết một_số vấn_đề về số_học là không đủ .\nMọi bài_toán đều_đều yêu_cầu bạn phải_biết một lượng kiến_thức toán nhất_định .\nVí_dụ , một_số bài_toán yêu_cầu bạn phải giải một hệ nhiều phương_trình hay tính xấp_xỉ nghiệm của nhiều phương_trình khác_nhau .\nĐồng dư_thức (Modulo) Phép đồng dư_thức cho bạn số_dư của phép_chia số này cho số khác .\nDấu của phép đồng dư là \\% .\nVí_dụ : Ta có hai số 5 và 2 , khi đó 5\\%2 bằng 1 do khi chia 5 cho 2 , ta được số_dư là 1 .\nTính_chất : Đồng dư_thức có_một số tính_chất sau : (a+b)\\%c = a\\%c + b\\%c (a . b)\\%c = ((a\\%c) . (b\\%c))\\%c Ví_dụ : Giả_sử a=5 , b=3 , c=2 Khi đó : (5+3)\\%2=8\\%2=0 và cũng bằng (5\\%2+3\\%2)\\%2=(1+1)\\%2=0 .\n(5 . 3)\\%2=15\\%2=1 và cũng bằng ((5\\%2) . (3\\%2))\\%2=(1 . 1)\\%2=1 .\nƯớc_chung lớn nhất Ước_chung lớn nhất (GCD , viết tắt của từ Greatest_Common_Divisor) của hai hay nhiều số_là số_nguyên_dương lớn nhất mà là ước_chung (common divisor) của tất_cả các số đó .\nVí_dụ : GCD của 6 và 10 là 2 vì 2 là số_nguyên_dương lớn nhất mà là ước_chung của 6 và 10 .\nThuật_toán \"ngây thơ\" (Naive Approach)_Ta có_thể duyệt tất_cả các số_từ min(A , B) đến 1 và kiểm_tra xem số đang xét có_phải là ước của của A và B hay_không .\nNếu đúng như_vậy thì số đang xét sẽ là GCD của A và B .\nint gcd ( int A , int B ) for ( int i = min ( A , B ); i gt; 0 ; -- i ) if ( A % i == 0 amp;amp; B % i == 0 ) return i ; // không bao_giờ chạy đến đây vì khi i = 1 thì cả A và B luôn chia_hết_cho i Độ phức_tạp của thuật_toán : O(min(A , B)) .\nThuật_toán Euclid Thuật_toán Euclid dựa trên tính_chất sau của ước_chung lớn nhất GCD(A , B)=GCD(B , A\\%B) .\nThuật_toán sẽ quy_nạp cho_đến khi A\\%B=0 .\nint gcd ( int A , int B ) if ( B == 0 ) return A ; else return gcd ( B , A % B ); Ví_dụ : Giả_sử A=16 , B=10 .\nGCD(16 , 10)=GCD(10 , 16\\%10)=GCD(10 , 6) GCD(10 , 6)=GCD(6 , 10\\%6)=GCD(6 , 4) GCD(6 , 4) = GCD(4 , 6 \\% 4) = GCD(4 , 2) GCD(4 , 2) = GCD(2 , 4 \\% 2) = GCD(2 , 0) Vì_B=0 nên GCD(2 , 0) sẽ trả về giá_trị 2 .\nĐộ phức_tạp của thuật_toán : O(\\logmax(A , B)) .\nThuật_toán Euclid mở_rộng (Extended Euclid_Algorithm)_Đây là một thuật_toán mở_rộng của thuật_toán Euclid ở trên .\nGCD(A , B) có_một tính_chất rất đặc_biệt : Nó luôn có_thể được biểu_diễn dưới dạng phương_trình Ax+By=GCD(A , B) .\nThuật_toán sẽ cho ta biết một cặp giá_trị (x;y) thỏa_mãn phương_trình này và nhờ đó giúp ta tính Modular_Multiplicative_Inverse .\nx và y có_thể có_giá trị bằng_không hoặc âm .\nChương_trình sau đọc hai số A và B và in ra GCD(A , B) cũng_như một cặp số (x;y) thỏa_mãn phương_trình .\nint d , x , y ; void extendedEuclid ( int A , int B ) if ( B == 0 ) d = A ; x = 1 ; y = 0 ; else extendedEuclid ( B , A % B ); int temp = x ; x = y ; y = temp - ( A / B ) y ; int main () extendedEuclid ( 16 , 10 ); cout lt;lt; \"gcd(16 , 10) = \" lt;lt; d lt;lt; endl ; cout lt;lt; \"x , y : \" lt;lt; x lt;lt; \" , \" lt;lt; y lt;lt; endl ; return 0 ; Kết_quả gcd(16 , 10) = 2 x , y : 2 , -3 Ban_đầu , thuật_toán Euclid mở_rộng sẽ chạy như thuật_toán Euclid cho_đến khi ta có GCD(A , B) hoặc cho_đến khi B bằng 0 và khi đó thuật_toán sẽ đặt x=1 và y=0 .\nVì_B=0 và GCD(A , B) là A trong thời_điểm hiện_tại nên phương_trình Ax+By=0 trở_thành A . 1+0 . 0=A .\nGiá_trị của các biến d , x , y trong hàm extendedEuclid() sẽ lần_lượt trở_thành : d=2 , x = 1 , y = 0 .\nd=2 , x = 0 , y = 1 - (4/2) . 0 = 1 .\nd=2 , x = 1 , y = 0 - (6/4) . 1 = -1 .\nd=2 , x = -1 , y = 1 - (10/6) . (-1) = 2 .\nd=2 , x= 2 , y = -1 - (16/10) . 2 = -3 Độ phức_tạp của thuật_toán : Độ phức_tạp của thuật_toán Euclid mở_rộng là O(\\logmax(A , B)) .\n\n", "tagged": "Nguồn/N :/CH HackerEarth/Np và/Cc 1/M số/N bài/N viết/V trên/E Wikipedia_Người/Np dịch/N :/CH Bùi_Việt/Np Dũng_Table/Np of_Contents/Np Giới_thiệu/V Đồng/Nu dư_thức/Np (Modulo)/Np Ước_chung/Np lớn/A nhất/A Thuật_toán/N \"ngây/Np thơ\"/Np (Naive/Np Approach)/Np Thuật_toán/N Euclid/Np Thuật_toán/N Euclid/Np mở_rộng/V (Extended/Np Euclid_Algorithm)/Np Giới_thiệu/V Các/L bài_toán/N trong/E lập_trình/V thi_đấu/V (competitive/Np programming)/Np mà/C liên_quan/V đến/E Toán_học/N thường/R sẽ/R rơi/V vào/E hai/M mảng/N là/V số_học/Np (number/Np theory)/Np và/Cc hình_học/Np ./CH\nNếu/C bạn/N biết/V nhiều/A về/E số_học/Np ,/CH bạn/N sẽ/R có/V khả_năng/N giải_quyết/V nhiều/A bài_toán/N khó/A và/Cc một/M nền_tảng/N tốt/A để/E giải_quyết/V nhiều/A bài_toán/N khác/A ./CH\nCác/L bài_toán/N trong/E lập_trình/V thi_đấu/V thường/R đòi_hỏi/V bạn/N một/M cái/Nc nhìn/V sâu_sắc/A ,/CH vì_vậy/C chỉ/R biết/V một_số/L vấn_đề/N về/E số_học/Np là/V không/R đủ/A ./CH\nMọi/L bài_toán/N đều_đều/Np yêu_cầu/V bạn/N phải_biết/N một/M lượng/N kiến_thức/N toán/N nhất_định/R ./CH\nVí_dụ/C ,/CH một_số/L bài_toán/N yêu_cầu/V bạn/N phải/V giải/N một/M hệ/N nhiều/A phương_trình/Np hay/Cc tính/V xấp_xỉ/A nghiệm/V của/E nhiều/A phương_trình/Np khác_nhau/Np ./CH\nĐồng/Nu dư_thức/Np (Modulo)/Np Phép/N đồng/Nu dư_thức/Np cho/E bạn/N số_dư/Np của/E phép_chia/Np số/N này/P cho/E số/N khác/A ./CH\nDấu/N của/E phép/N đồng/Nu dư/A là/V \\%/Np ./CH\nVí_dụ/C :/CH Ta/P có/V hai/M số/N 5/M và/Cc 2/M ,/CH khi/N đó/P 5\\%2/Np bằng/E 1/M do/E khi/N chia/V 5/M cho/E 2/M ,/CH ta/P được/V số_dư/Np là/V 1/M ./CH\nTính_chất/N :/CH Đồng/Nu dư_thức/Np có_một/Np số/N tính_chất/N sau/E :/CH (a+b)\\%c/Np =/CH a\\%c/Np +/CH b\\%c/Np (a/Np ./CH b)\\%c/Np =/CH ((a\\%c)/Np ./CH (b\\%c))\\%c/Np Ví_dụ/C :/CH Giả_sử/Np a=5/Np ,/CH b=3/Np ,/CH c=2/Np Khi/N đó/P :/CH (5+3)\\%2=8\\%2=0/Np và/Cc cũng/R bằng/E (5\\%2+3\\%2)\\%2=(1+1)\\%2=0/Np ./CH\n(5/Np ./CH 3)\\%2=15\\%2=1/Np và/Cc cũng/R bằng/E ((5\\%2)/Np ./CH (3\\%2))\\%2=(1/Np ./CH 1)\\%2=1/Np ./CH\nƯớc_chung/Np lớn/A nhất/A Ước_chung/Np lớn/A nhất/A (GCD/Np ,/CH viết/V tắt/V của/E từ/E Greatest_Common_Divisor)/Np của/E hai/M hay/Cc nhiều/A số_là/C số_nguyên_dương/Np lớn/A nhất/A mà/C là/V ước_chung/Np (common/Np divisor)/Np của/E tất_cả/P các/L số/N đó/P ./CH\nVí_dụ/C :/CH GCD/Np của/E 6/M và/Cc 10/M là/V 2/M vì/E 2/M là/V số_nguyên_dương/Np lớn/A nhất/A mà/C là/V ước_chung/Np của/E 6/M và/Cc 10/M ./CH\nThuật_toán/N \"ngây/Np thơ\"/Np (Naive/Np Approach)_Ta/Np có_thể/R duyệt/V tất_cả/P các/L số_từ/Np min(A/Np ,/CH B)/Np đến/E 1/M và/Cc kiểm_tra/V xem/V số/N đang/R xét/V có_phải/Np là/V ước/V của/E của/E A/Ni và/Cc B/Ni hay_không/Np ./CH\nNếu/C đúng/A như_vậy/X thì/C số/N đang/R xét/V sẽ/R là/V GCD/Np của/E A/Ni và/Cc B/Ni ./CH\nint/Np gcd/Np (/CH int/Np A/Ni ,/CH int/Np B/Ni )/CH for/Np (/CH int/Np i/M =/CH min/Np (/CH A/Ni ,/CH B/Ni );/CH i/M gt;/Np 0/M ;/CH --/Np i/M )/CH if/Np (/CH A/Ni %/CH i/M ==/Np 0/M amp;amp;/Np B/Ni %/CH i/M ==/Np 0/M )/CH return/Np i/M ;/CH //CH không/R bao_giờ/P chạy/V đến/E đây/P vì/E khi/N i/M =/CH 1/M thì/C cả/P A/Ni và/Cc B/Ni luôn/R chia_hết_cho/Np i/M Độ/N phức_tạp/A của/E thuật_toán/N :/CH O(min(A/Np ,/CH B))/Np ./CH\nThuật_toán/N Euclid/Np Thuật_toán/N Euclid/Np dựa/V trên/E tính_chất/N sau/E của/E ước_chung/Np lớn/A nhất/A GCD(A/Np ,/CH B)=GCD(B/Np ,/CH A\\%B)/Np ./CH\nThuật_toán/N sẽ/R quy_nạp/Np cho_đến/E khi/N A\\%B=0/Np ./CH\nint/Np gcd/Np (/CH int/Np A/Ni ,/CH int/Np B/Ni )/CH if/Np (/CH B/Ni ==/Np 0/M )/CH return/Np A/Ni ;/CH else/Np return/Np gcd/Np (/CH B/Ni ,/CH A/Ni %/CH B/Ni );/CH Ví_dụ/C :/CH Giả_sử/Np A=16/Np ,/CH B=10/Np ./CH\nGCD(16/Np ,/CH 10)=GCD(10/Np ,/CH 16\\%10)=GCD(10/Np ,/CH 6)/Np GCD(10/Np ,/CH 6)=GCD(6/Np ,/CH 10\\%6)=GCD(6/Np ,/CH 4)/Np GCD(6/Np ,/CH 4)/Np =/CH GCD(4/Np ,/CH 6/M \\%/Np 4)/Np =/CH GCD(4/Np ,/CH 2)/Np GCD(4/Np ,/CH 2)/Np =/CH GCD(2/Np ,/CH 4/M \\%/Np 2)/Np =/CH GCD(2/Np ,/CH 0)/Np Vì_B=0/Np nên/C GCD(2/Np ,/CH 0)/Np sẽ/R trả/V về/E giá_trị/N 2/M ./CH\nĐộ/N phức_tạp/A của/E thuật_toán/N :/CH O(\\logmax(A/Np ,/CH B))/Np ./CH\nThuật_toán/N Euclid/Np mở_rộng/V (Extended/Np Euclid_Algorithm)_Đây/Np là/V một/M thuật_toán/N mở_rộng/V của/E thuật_toán/N Euclid/Np ở/E trên/E ./CH\nGCD(A/Np ,/CH B)/Np có_một/Np tính_chất/N rất/R đặc_biệt/A :/CH Nó/P luôn/R có_thể/R được/V biểu_diễn/V dưới/E dạng/N phương_trình/Np Ax+By=GCD(A/Np ,/CH B)/Np ./CH\nThuật_toán/N sẽ/R cho/E ta/P biết/V một/M cặp/N giá_trị/N (x;y)/Np thỏa_mãn/V phương_trình/Np này/P và/Cc nhờ/V đó/P giúp/V ta/P tính/V Modular_Multiplicative_Inverse/Np ./CH\nx/CH và/Cc y/N có_thể/R có_giá/Np trị/V bằng_không/A hoặc/Cc âm/A ./CH\nChương_trình/N sau/E đọc/V hai/M số/N A/Ni và/Cc B/Ni và/Cc in/V ra/V GCD(A/Np ,/CH B)/Np cũng_như/C một/M cặp/N số/N (x;y)/Np thỏa_mãn/V phương_trình/Np ./CH\nint/Np d/Ny ,/CH x/CH ,/CH y/N ;/CH void/Np extendedEuclid/Np (/CH int/Np A/Ni ,/CH int/Np B/Ni )/CH if/Np (/CH B/Ni ==/Np 0/M )/CH d/Ny =/CH A/Ni ;/CH x/CH =/CH 1/M ;/CH y/N =/CH 0/M ;/CH else/Np extendedEuclid/Np (/CH B/Ni ,/CH A/Ni %/CH B/Ni );/CH int/Np temp/Np =/CH x/CH ;/CH x/CH =/CH y/N ;/CH y/N =/CH temp/Np -/CH (/CH A/Ni //CH B/Ni )/CH y/N ;/CH int/Np main/Np ()/Np extendedEuclid/Np (/CH 16/M ,/CH 10/M );/CH cout/Np lt;lt;/Np \"gcd(16/Np ,/CH 10)/Np =/CH \"/CH lt;lt;/Np d/Ny lt;lt;/Np endl/Np ;/CH cout/Np lt;lt;/Np \"x/Np ,/CH y/N :/CH \"/CH lt;lt;/Np x/CH lt;lt;/Np \"/CH ,/CH \"/CH lt;lt;/Np y/N lt;lt;/Np endl/Np ;/CH return/Np 0/M ;/CH Kết_quả/N gcd(16/Np ,/CH 10)/Np =/CH 2/M x/CH ,/CH y/N :/CH 2/M ,/CH -3/Np Ban_đầu/N ,/CH thuật_toán/N Euclid/Np mở_rộng/V sẽ/R chạy/V như/C thuật_toán/N Euclid/Np cho_đến/E khi/N ta/P có/V GCD(A/Np ,/CH B)/Np hoặc/Cc cho_đến/E khi/N B/Ni bằng/E 0/M và/Cc khi/N đó/P thuật_toán/N sẽ/R đặt/V x=1/Np và/Cc y=0/Np ./CH\nVì_B=0/Np và/Cc GCD(A/Np ,/CH B)/Np là/V A/Ni trong/E thời_điểm/N hiện_tại/N nên/C phương_trình/Np Ax+By=0/Np trở_thành/V A/Ni ./CH 1+0/Np ./CH 0=A/Np ./CH\nGiá_trị/N của/E các/L biến/V d/Ny ,/CH x/CH ,/CH y/N trong/E hàm/Np extendedEuclid()/Np sẽ/R lần_lượt/R trở_thành/V :/CH d=2/Np ,/CH x/CH =/CH 1/M ,/CH y/N =/CH 0/M ./CH\nd=2/Np ,/CH x/CH =/CH 0/M ,/CH y/N =/CH 1/M -/CH (4/Np ./CH 0/M =/CH 1/M ./CH\nd=2/Np ,/CH x/CH =/CH 1/M ,/CH y/N =/CH 0/M -/CH (6/Np ./CH 1/M =/CH -1/Np ./CH\nd=2/Np ,/CH x/CH =/CH -1/Np ,/CH y/N =/CH 1/M -/CH (10/Np ./CH (-1)/Np =/CH 2/M ./CH\nd=2/Np ,/CH x=/Np 2/M ,/CH y/N =/CH -1/Np -/CH (16/Np ./CH 2/M =/CH -3/Np Độ/N phức_tạp/A của/E thuật_toán/N :/CH Độ/N phức_tạp/A của/E thuật_toán/N Euclid/Np mở_rộng/V là/V O(\\logmax(A/Np ,/CH B))/Np ./CH\n\n", "title": "Số học 1 - Modulo & gcd\n", "link": "http://vnoi.info/wiki/translate/he/So-hoc-Phan-1-Modulo-gcd\n"}