{"content": "Nguồn : HackerEarth và 1 số bài viết trên Wikipedia_Người dịch : Bùi_Việt Dũng_Table of_Contents Số_nguyên_tố (Prime Numbers) Thuật_toán \"ngây thơ\" Một thuật_toán tốt hơn Sàng_Eratosthenes (Sieve of Eratosthenes) Phân_tích thừa_số nguyên_tố với sàng Eratosthenes_Sàng_Eratosthenes trên đoạn Bài_tập áp_dụng : Bạn có_thể đọc phần 1 về Modulo amp; GCD ở đây .\nSố_nguyên_tố (Prime Numbers) Số_nguyên_tố là số_nguyên lớn hơn 1 và có đúng 2 ước là 1 và chính nó .\nHợp_số (Composite numbers) là số_nguyên lớn hơn 1 và có nhiều hơn 2 ước .\nVí_dụ , 5 là số_nguyên_tố vì 5 chỉ chia_hết_cho 1 và 5 .\nTuy_nhiên , 6 là hợp_số vì 6 chia_hết_cho 1 , 2 , 3 và 6 .\nCó rất nhiều phương_pháp để kiểm_tra một_số nguyên có_phải là số_nguyên_tố hay_không .\nThuật_toán \"ngây thơ\" Ta sẽ duyệt hết tất_cả các số_từ 1 đến N và đếm_số ước của N .\nNếu số ước của N là 2 thì N là số_nguyên_tố , nếu_không thì N không là số_nguyên_tố .\nbool isPrime ( int n ) for ( int i = 2 ; i lt; n ; i ++ ) if ( n % i == 0 ) // n chia_hết_cho số khác 1 và chính nó .\nreturn false ; return n gt; 1 ; Độ phức_tạp của thuật_toán : Độ phức_tạp của thuật_toán là O(N) do ta phải duyệt hết các số_từ 1 đến N .\nMột thuật_toán tốt hơn Xét hai số_nguyên_dương N và D thỏa_mãn N chia_hết_cho D và D nhỏ hơn \\sqrtN .\nKhi đó \\fracND phải lớn hơn \\sqrtN .\nN cũng chia_hết_cho \\fracND .\nVì_thế , nếu N có ước nhỏ hơn \\sqrtN thì N cũng có ước lớn hơn \\sqrtN .\nDo_đó , ta chỉ_cần duyệt đến \\sqrtN .\nbool isPrime ( int n ) for ( int i = 2 ; i i lt;= n ; i ++ ) if ( n % i == 0 ) return false ; return n gt; 1 ; Độ phức_tạp của thuật_toán : Độ phức_tạp của thuật_toán là O(\\sqrtN) do ta phải duyệt từ 1 đến \\sqrtN .\nSàng_Eratosthenes (Sieve of Eratosthenes)_Sàng_Eratosthenes dùng để tìm các số_nguyên_tố nhỏ hơn hoặc bằng số_nguyên N nào_đó .\nNó còn có_thể được sử_dụng để kiểm_tra một_số nguyên nhỏ hơn hoặc bằng N hay_không .\nNguyên_lí hoạt_động của sàng là vào mỗi lần duyệt , ta chọn một_số nguyên_tố và loại ra khỏi sàng tất_cả các bội của số_nguyên_tố đó mà lớn hơn số đó .\nSau khi duyệt xong , các số còn_lại trong sàng đều là số_nguyên_tố .\nMã giả (Pseudo Code) : Đánh_dấu tất_cả các số đều là số_nguyên_tố .\nVới mỗi số_nguyên_tố nhỏ hơn \\sqrtN Đánh_dấu các bội lớn hơn nó là số_nguyên_tố .\nvoid sieve ( int N ) bool isPrime N + 1 ; for ( int i = 0 ; i lt;= N ; ++ i ) isPrime i = true ; isPrime 0 = false ; isPrime 1 = false ; for ( int i = 2 ; i i lt;= N ; ++ i ) if ( isPrime i == true ) // Mark all the multiples of i as composite numbers for ( int j = i i ; j lt;= N ; j += i ) isPrime j = false ; Code trên được dùng để tìm các số_nguyên_tố nhỏ hơn hoặc bằng N .\nĐộ phức_tạp của thuật_toán : Số lần_lặp của vòng_lặp trong là : Khi i=2 , vòng_lặp trong lặp \\fracN2 lần .\nKhi i=3 , vòng_lặp trong lặp \\fracN3 lần .\nKhi i=5 , vòng_lặp trong lặp \\fracN5 lần .\n. . .\nĐộ phức_tạp tổng : N . (\\frac12+\\frac13+\\frac15+ . . . )=O(N\\logN) .\nPhân_tích thừa_số nguyên_tố với sàng Eratosthenes_Cách cài_đặt : Đầu_tiên hãy xem_xét thuật_toán phân_tích ra thừa_số nguyên_tố trong O(\\sqrtN) .\nvector lt; int gt; factorize ( int n ) vector lt; int gt; res ; for ( int i = 2 ; i i lt;= n ; ++ i ) while ( n % i == 0 ) res .\npush_back ( i ); n /= i ; if ( n ! = 1 ) res .\npush_back ( n ); return res ; Tại mỗi bước_ta phải tìm số_nguyên_tố nhỏ nhất mà N chia_hết_cho số đó .\nDo_đó , ta phải biến_đổi sàng Eratosthenes để tìm được số mình mong_muốn trong O(1) .\nint minPrime n + 1 ; for ( int i = 2 ; i i lt;= n ; ++ i ) if ( minPrime i == 0 ) //if i is_prime for ( int j = i i ; j lt;= n ; j += i ) if ( minPrime j == 0 ) minPrime j = i ; for ( int i = 2 ; i lt;= n ; ++ i ) if ( minPrime i == 0 ) minPrime i = i ; Bây_giờ ta có_thể phân_tích một_số ra thừa_số nguyên_tố trong O(\\logN) .\nvector lt; int gt; factorize ( int n ) vector lt; int gt; res ; while ( n ! = 1 ) res .\npush_back ( minPrime n ); n /= minPrime n ; return res ; Điều_kiện sử_dụng phương_pháp này là ta phải tạo được mảng có độ_dài N phần_tử .\nPhương_pháp này rất hữu_ích khi ta phải phân tich nhiều số nhỏ ra thừa_số nguyên_tố .\nTa không cần_thiết phải sử_dụng phương_pháp này trong mọi bài_toán liên_quan đến phân_tích một_số ra thừa_số nguyên_tố .\nNgoài_ra , ta không_thể sử_dụng phương_pháp này nếu N bằng 109 hay 1012 .\nKhi đó , ta chỉ_có thể sử_dụng thuật_toán O(\\sqrtN) .\nTính_chất thú_vị : Nếu N=p_1q_1 . p_2q_2 . . . p_kq_k với p_1 , p_2 , . . . , p_k là các số_nguyên_tố thì N có (q_1+1) . (q_2+1) . . . (q_k+1) ước phân_biệt .\nSàng_Eratosthenes trên đoạn Đôi_khi bạn phải tìm tất_cả các số_không phải trên đoạn 1;N mà là trên đoạn L;R với R lớn .\nĐiều_kiện sử_dụng phương_pháp này là bạn có_thể tạo mảng độ_dài R-L+1 phần_tử .\nCài_đặt : bool isPrime r - l + 1 ; //filled by true for ( long_long i = 2 ; i i lt;= r ; ++ i ) for ( long_long j = max ( i i , ( l + ( i - 1 )) / i i ); j lt;= r ; j += i ) isPrime j - l = false ; for ( long_long i = max ( l , 2 ); i lt;= r ; ++ i ) if ( isPrime i - l ) //then i is_prime Độ phức_tạp của thuật_toán là O(\\sqrtRk) với k là hằng_số .\nLưu_ý : Nếu bạn chỉ_cần kiểm_tra tính nguyên_tố của một hay một_vài số thì ta không nhất_thiết phải xây_dựng sàng .\nTa có_thể sử_dụng hàm sau để kiểm_tra tính nguyên_tố của một_số .\nbool isPrime ( int n ) for ( int i = 2 ; i i lt;= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; Bài_tập áp_dụng : SPOJ - PRIME1_VOJ - NKABD\n", "tagged": "Nguồn/N :/CH HackerEarth/Np và/Cc 1/M số/N bài/N viết/V trên/E Wikipedia_Người/Np dịch/N :/CH Bùi_Việt/Np Dũng_Table/Np of_Contents/Np Số_nguyên_tố/Np (Prime/Np Numbers)/Np Thuật_toán/N \"ngây/Np thơ\"/Np Một/M thuật_toán/N tốt/A hơn/A Sàng_Eratosthenes/Np (Sieve/Np of/E Eratosthenes)/Np Phân_tích/V thừa_số/Np nguyên_tố/N với/E sàng/Np Eratosthenes_Sàng_Eratosthenes/Np trên/E đoạn/Nc Bài_tập/Np áp_dụng/V :/CH Bạn/N có_thể/R đọc/V phần/N 1/M về/E Modulo/Np amp;/Np GCD/Np ở/E đây/P ./CH\nSố_nguyên_tố/Np (Prime/Np Numbers)/Np Số_nguyên_tố/Np là/V số_nguyên/Np lớn/A hơn/A 1/M và/Cc có/V đúng/A 2/M ước/V là/V 1/M và/Cc chính/T nó/P ./CH\nHợp_số/Np (Composite/Np numbers)/Np là/V số_nguyên/Np lớn/A hơn/A 1/M và/Cc có/V nhiều/A hơn/A 2/M ước/V ./CH\nVí_dụ/C ,/CH 5/M là/V số_nguyên_tố/Np vì/E 5/M chỉ/R chia_hết_cho/Np 1/M và/Cc 5/M ./CH\nTuy_nhiên/C ,/CH 6/M là/V hợp_số/Np vì/E 6/M chia_hết_cho/Np 1/M ,/CH 2/M ,/CH 3/M và/Cc 6/M ./CH\nCó/V rất/R nhiều/A phương_pháp/N để/E kiểm_tra/V một_số/L nguyên/A có_phải/Np là/V số_nguyên_tố/Np hay_không/Np ./CH\nThuật_toán/N \"ngây/Np thơ\"/Np Ta/P sẽ/R duyệt/V hết/V tất_cả/P các/L số_từ/Np 1/M đến/E N/Ny và/Cc đếm_số/Np ước/V của/E N/Ny ./CH\nNếu/C số/N ước/V của/E N/Ny là/V 2/M thì/C N/Ny là/V số_nguyên_tố/Np ,/CH nếu_không/Np thì/C N/Ny không/R là/V số_nguyên_tố/Np ./CH\nbool/Np isPrime/Np (/CH int/Np n/Ny )/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M lt;/Np n/Ny ;/CH i/M ++/Np )/CH if/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH //CH n/Ny chia_hết_cho/Np số/N khác/A 1/M và/Cc chính/T nó/P ./CH\nreturn/Np false/Np ;/CH return/Np n/Ny gt;/Np 1/M ;/CH Độ/N phức_tạp/A của/E thuật_toán/N :/CH Độ/N phức_tạp/A của/E thuật_toán/N là/V O(N)/Np do/E ta/P phải/V duyệt/V hết/V các/L số_từ/Np 1/M đến/E N/Ny ./CH\nMột/M thuật_toán/N tốt/A hơn/A Xét/V hai/M số_nguyên_dương/Np N/Ny và/Cc D/Ny thỏa_mãn/V N/Ny chia_hết_cho/Np D/Ny và/Cc D/Ny nhỏ/A hơn/A \\sqrtN/Np ./CH\nKhi/N đó/P \\fracND/Np phải/V lớn/A hơn/A \\sqrtN/Np ./CH\nN/Ny cũng/R chia_hết_cho/Np \\fracND/Np ./CH\nVì_thế/C ,/CH nếu/C N/Ny có/V ước/V nhỏ/A hơn/A \\sqrtN/Np thì/C N/Ny cũng/R có/V ước/V lớn/A hơn/A \\sqrtN/Np ./CH\nDo_đó/C ,/CH ta/P chỉ_cần/Np duyệt/V đến/E \\sqrtN/Np ./CH\nbool/Np isPrime/Np (/CH int/Np n/Ny )/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np n/Ny ;/CH i/M ++/Np )/CH if/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH return/Np false/Np ;/CH return/Np n/Ny gt;/Np 1/M ;/CH Độ/N phức_tạp/A của/E thuật_toán/N :/CH Độ/N phức_tạp/A của/E thuật_toán/N là/V O(\\sqrtN)/Np do/E ta/P phải/V duyệt/V từ/E 1/M đến/E \\sqrtN/Np ./CH\nSàng_Eratosthenes/Np (Sieve/Np of/E Eratosthenes)_Sàng_Eratosthenes/Np dùng/V để/E tìm/V các/L số_nguyên_tố/Np nhỏ/A hơn/A hoặc/Cc bằng/E số_nguyên/Np N/Ny nào_đó/P ./CH\nNó/P còn/R có_thể/R được/V sử_dụng/V để/E kiểm_tra/V một_số/L nguyên/A nhỏ/A hơn/A hoặc/Cc bằng/E N/Ny hay_không/Np ./CH\nNguyên_lí/N hoạt_động/N của/E sàng/Np là/V vào/E mỗi/L lần/N duyệt/V ,/CH ta/P chọn/V một_số/L nguyên_tố/N và/Cc loại/N ra/V khỏi/V sàng/Np tất_cả/P các/L bội/Np của/E số_nguyên_tố/Np đó/P mà/C lớn/A hơn/A số/N đó/P ./CH\nSau/E khi/N duyệt/V xong/V ,/CH các/L số/N còn_lại/Np trong/E sàng/Np đều/R là/V số_nguyên_tố/Np ./CH\nMã/N giả/A (Pseudo/Np Code)/Np :/CH Đánh_dấu/V tất_cả/P các/L số/N đều/R là/V số_nguyên_tố/Np ./CH\nVới/E mỗi/L số_nguyên_tố/Np nhỏ/A hơn/A \\sqrtN/Np Đánh_dấu/V các/L bội/Np lớn/A hơn/A nó/P là/V số_nguyên_tố/Np ./CH\nvoid/Np sieve/Np (/CH int/Np N/Ny )/CH bool/Np isPrime/Np N/Ny +/CH 1/M ;/CH for/Np (/CH int/Np i/M =/CH 0/M ;/CH i/M lt;=/Np N/Ny ;/CH ++/Np i/M )/CH isPrime/Np i/M =/CH true/Np ;/CH isPrime/Np 0/M =/CH false/Np ;/CH isPrime/Np 1/M =/CH false/Np ;/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np N/Ny ;/CH ++/Np i/M )/CH if/Np (/CH isPrime/Np i/M ==/Np true/Np )/CH //CH Mark/Np all/Np the/B multiples/Np of/E i/M as/Np composite/Np numbers/Np for/Np (/CH int/Np j/Np =/CH i/M i/M ;/CH j/Np lt;=/Np N/Ny ;/CH j/Np +=/Np i/M )/CH isPrime/Np j/Np =/CH false/Np ;/CH Code/Np trên/E được/V dùng/V để/E tìm/V các/L số_nguyên_tố/Np nhỏ/A hơn/A hoặc/Cc bằng/E N/Ny ./CH\nĐộ/N phức_tạp/A của/E thuật_toán/N :/CH Số/N lần_lặp/Np của/E vòng_lặp/Np trong/E là/V :/CH Khi/N i=2/Np ,/CH vòng_lặp/Np trong/E lặp/V \\fracN2/Np lần/N ./CH\nKhi/N i=3/Np ,/CH vòng_lặp/Np trong/E lặp/V \\fracN3/Np lần/N ./CH\nKhi/N i=5/Np ,/CH vòng_lặp/Np trong/E lặp/V \\fracN5/Np lần/N ./CH\n./CH ./CH ./CH\nĐộ/N phức_tạp/A tổng/N :/CH N/Ny ./CH (\\frac12+\\frac13+\\frac15+/Np ./CH ./CH ./CH )=O(N\\logN)/Np ./CH\nPhân_tích/V thừa_số/Np nguyên_tố/N với/E sàng/Np Eratosthenes_Cách/Np cài_đặt/V :/CH Đầu_tiên/A hãy/R xem_xét/V thuật_toán/N phân_tích/V ra/V thừa_số/Np nguyên_tố/N trong/E O(\\sqrtN)/Np ./CH\nvector/Np lt;/Np int/Np gt;/Np factorize/Np (/CH int/Np n/Ny )/CH vector/Np lt;/Np int/Np gt;/Np res/Np ;/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np n/Ny ;/CH ++/Np i/M )/CH while/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH res/Np ./CH\npush_back/Np (/CH i/M );/CH n/Ny /=/Np i/M ;/CH if/Np (/CH n/Ny !/CH =/CH 1/M )/CH res/Np ./CH\npush_back/Np (/CH n/Ny );/CH return/Np res/Np ;/CH Tại/E mỗi/L bước_ta/Np phải/V tìm/V số_nguyên_tố/Np nhỏ/A nhất/A mà/C N/Ny chia_hết_cho/Np số/N đó/P ./CH\nDo_đó/C ,/CH ta/P phải/V biến_đổi/V sàng/Np Eratosthenes/Np để/E tìm/V được/V số/N mình/P mong_muốn/V trong/E O(1)/Np ./CH\nint/Np minPrime/Np n/Ny +/CH 1/M ;/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np n/Ny ;/CH ++/Np i/M )/CH if/Np (/CH minPrime/Np i/M ==/Np 0/M )/CH //CH i/M is_prime/Np for/Np (/CH int/Np j/Np =/CH i/M i/M ;/CH j/Np lt;=/Np n/Ny ;/CH j/Np +=/Np i/M )/CH if/Np (/CH minPrime/Np j/Np ==/Np 0/M )/CH minPrime/Np j/Np =/CH i/M ;/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M lt;=/Np n/Ny ;/CH ++/Np i/M )/CH if/Np (/CH minPrime/Np i/M ==/Np 0/M )/CH minPrime/Np i/M =/CH i/M ;/CH Bây_giờ/P ta/P có_thể/R phân_tích/V một_số/L ra/V thừa_số/Np nguyên_tố/N trong/E O(\\logN)/Np ./CH\nvector/Np lt;/Np int/Np gt;/Np factorize/Np (/CH int/Np n/Ny )/CH vector/Np lt;/Np int/Np gt;/Np res/Np ;/CH while/Np (/CH n/Ny !/CH =/CH 1/M )/CH res/Np ./CH\npush_back/Np (/CH minPrime/Np n/Ny );/CH n/Ny /=/Np minPrime/Np n/Ny ;/CH return/Np res/Np ;/CH Điều_kiện/N sử_dụng/V phương_pháp/N này/P là/V ta/P phải/V tạo/V được/V mảng/N có/V độ_dài/Np N/Ny phần_tử/N ./CH\nPhương_pháp/N này/P rất/R hữu_ích/A khi/N ta/P phải/V phân/V tich/Np nhiều/A số/N nhỏ/A ra/V thừa_số/Np nguyên_tố/N ./CH\nTa/P không/R cần_thiết/A phải/V sử_dụng/V phương_pháp/N này/P trong/E mọi/L bài_toán/N liên_quan/V đến/E phân_tích/V một_số/L ra/V thừa_số/Np nguyên_tố/N ./CH\nNgoài_ra/X ,/CH ta/P không_thể/R sử_dụng/V phương_pháp/N này/P nếu/C N/Ny bằng/E 109/M hay/Cc 1012/Np ./CH\nKhi/N đó/P ,/CH ta/P chỉ_có/Np thể/N sử_dụng/V thuật_toán/N O(\\sqrtN)/Np ./CH\nTính_chất/N thú_vị/A :/CH Nếu/C N=p_1q_1/Np ./CH p_2q_2/Np ./CH ./CH ./CH p_kq_k/Np với/E p_1/Np ,/CH p_2/Np ,/CH ./CH ./CH ./CH ,/CH p_k/Np là/V các/L số_nguyên_tố/Np thì/C N/Ny có/V (q_1+1)/Np ./CH (q_2+1)/Np ./CH ./CH ./CH (q_k+1)/Np ước/V phân_biệt/V ./CH\nSàng_Eratosthenes/Np trên/E đoạn/Nc Đôi_khi/R bạn/N phải/V tìm/V tất_cả/P các/L số_không/Np phải/V trên/E đoạn/Nc 1;N/Np mà/C là/V trên/E đoạn/Nc L;R/Np với/E R/Np lớn/A ./CH\nĐiều_kiện/N sử_dụng/V phương_pháp/N này/P là/V bạn/N có_thể/R tạo/V mảng/N độ_dài/Np R-L+1/Np phần_tử/N ./CH\nCài_đặt/V :/CH bool/Np isPrime/Np r/Np -/CH l/Ny +/CH 1/M ;/CH //CH by/Np true/Np for/Np (/CH long_long/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np r/Np ;/CH ++/Np i/M )/CH for/Np (/CH long_long/Np j/Np =/CH max/Np (/CH i/M i/M ,/CH (/CH l/Ny +/CH (/CH i/M -/CH 1/M ))/Np //CH i/M i/M );/CH j/Np lt;=/Np r/Np ;/CH j/Np +=/Np i/M )/CH isPrime/Np j/Np -/CH l/Ny =/CH false/Np ;/CH for/Np (/CH long_long/Np i/M =/CH max/Np (/CH l/Ny ,/CH 2/M );/CH i/M lt;=/Np r/Np ;/CH ++/Np i/M )/CH if/Np (/CH isPrime/Np i/M -/CH l/Ny )/CH //CH i/M is_prime/Np Độ/N phức_tạp/A của/E thuật_toán/N là/V O(\\sqrtRk)/Np với/E k/N là/V hằng_số/Np ./CH\nLưu_ý/V :/CH Nếu/C bạn/N chỉ_cần/Np kiểm_tra/V tính/V nguyên_tố/N của/E một/M hay/Cc một_vài/L số/N thì/C ta/P không/R nhất_thiết/R phải/V xây_dựng/V sàng/Np ./CH\nTa/P có_thể/R sử_dụng/V hàm/Np sau/E để/E kiểm_tra/V tính/V nguyên_tố/N của/E một_số/L ./CH\nbool/Np isPrime/Np (/CH int/Np n/Ny )/CH for/Np (/CH int/Np i/M =/CH 2/M ;/CH i/M i/M lt;=/Np n/Ny ;/CH ++/Np i/M )/CH if/Np (/CH n/Ny %/CH i/M ==/Np 0/M )/CH return/Np false/Np ;/CH return/Np true/Np ;/CH Bài_tập/Np áp_dụng/V :/CH SPOJ/Np -/CH PRIME1_VOJ/Np -/CH NKABD/Np\n", "title": "Số học 2 - Số nguyên tố, Sàng Eratosthenes\n", "link": "http://vnoi.info/wiki/translate/he/Number-Theory-2\n"}