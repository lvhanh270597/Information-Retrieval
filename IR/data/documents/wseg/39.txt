Bài viết gốc : Seam_Carving_Algorithm - K .
Lykov_Blog Giới_thiệu Seam carving là một thuật_toán dùng để thay_đổi kích_thước hình_ảnh , nó được giới_thiệu trong bài báo_cáo khoa_học của S .
Avidan amp; A .
Shamir .
Trong bài báo , việc thay_đổi kích_thước ảnh được thực_hiện bằng cách loại_bỏ đi các điểm_ảnh ít quan_trọng và giữ_lại các điểm_ảnh quan_trọng .
Bức ảnh dưới_đây là minh_họa điều này (ảnh bên_trên là ảnh gốc với kích_thước 332x480 và ảnh bên_dưới là ảnh sau khi áp_dụng thuật_toán seam carving đẻ thu_nhỏ còn_lại kích_thước là 272x400) .
Thuật_toán này khá phổ_biến nên có_thể dễ_dàng tìm_thấy rất nhiều bài viết nói về nó .
Tuy_nhiên hầu_hết đa_số các tác_giả đã không đọc_bài báo_cáo ban_đầu và chỉ cung_cấp cách cài_đặt thuật_toán khá cơ_bản .
Trong bài viết này tôi sẽ mô_tả thuật_toán đầy_đủ các chi_tiết như trong bài viết của Avidan amp; Shamir , dưới góc nhìn của một lập_trình_viên .
Ở đây ta sẽ sử_dụng matlab để cài_đặt thuật_toán .
Phần chứng_minh cụ_thể các bạn xem ở phần tham_khảo .
Năng_lượng (Energy) Để đơn_giản , bài viết này chỉ tập_trung nói về việc_làm giảm kích_thước hình_ảnh .
Tuy_nhiên việc_làm tăng kích_thước hình_ảnh cũng có_thể làm tương_tự , và sẽ được mô_tả sơ_qua ở phần sau .
Ý_tưởng chính của thuật_toán là việc loại_bỏ các nội_dung có ít ý_nghĩa đối_với người sử_dụng (chứa ít thông tin) .
Ta gọi thông_tin này là Năng_lượng (Energy) .
Vì_vậy ta cần_định_nghĩa hàm năng_lượng để tính_năng lượng điểm_ảnh từ các điểm_ảnh của ảnh gốc .
Ví_dụ , ở đây ta có_thể tính_năng lượng của ảnh thông_qua đạo_hàm của từng điểm_ảnh theo các hướng : e_1=\left \frac\delta I\delta x \right + \left \frac\delta I\delta y \right .
Nếu_như ảnh có 3 kênh màu thì ta lấy tổng_giá trị năng_lượng của 3 kênh này lại với_nhau .
Đoạn code Matlab dưới_đây sẽ mô_tả quá_trình tính .
Hàm imfilter được áp_dụng cho các điểm_ảnh được đánh_dấu , do_đó kết_quả là dI(i , j)/dx = I(i+1)-I(i-1)/dx với dx = 1 .
Tương_tự cho dI(i , j)/dy : dI(i , j)/dy = I(j+1)-I(j-1)/dy với dy = 1 .
function res = energyRGB ( I ) % Input : Ảnh màu (3 kênh màu) % Output : Một mảng 2 chiều thể_hiện năng_lượng của các điểm trong ảnh .
% e = dI/dx + dI/dy % Vì ảnh có 3 kênh màu nên ta trả ra tổng_năng lượng theo 3 kênh màu res = energyGrey ( I ( : , : , 1 )) + energyGrey ( I ( : , : , 2 )) + energyGrey ( I ( : , : , 3 )); function res = energyGrey ( I ) % Input : Ảnh đen trắng % Output : Một mảng 2 chiều thể_hiện năng_lượng của các điểm trong ảnh .
% e = dI/dx + dI/dy res = abs ( imfilter ( I , - 1 , 0 , 1 , replicate )) + abs ( imfilter ( I , - 1 ; 0 ; 1 , replicate )); end Năng_lượng thu được : Seam_Nếu chúng_ta xóa đi các điểm_ảnh có nặng lượng thấp nhất ở các_vị trí ngẫu_nhiên , ta sẽ ra một hình_ảnh méo_mó .
Nếu chúng_ta xóa theo cột hoặc hàng với năng_lượng tối_thiểu , ta sẽ nhận được một bức ảnh hoàn_chỉnh được thu_nhỏ kích_thước lại .
Ở đây cột j nghĩa_là tập_hợp (i , j) với j cố_định và một hàng i nghĩa_là tập_hợp (i , j) với i cố_định .
Thuật_toán Seam_Carving xóa các hàng và cột tổng_quát (được gọi_là đường seam) .
Cụ_thể hơn , gọi I là một bức ảnh có kích_thước n m , một đường seam dọc là (sx)i = (i , x(i))s . t . \forall i , x(i) - x(i - 1) \leq 1 trong đó x1 . . n \to 1 . . m .
Nói một_cách dễ_hiểu hơn , một đường seam dọc ( vertical seam ) là một đường_đi từ biên trên của bức ảnh xuống biên dưới của bức ảnh với độ_dài đường_đi bằng chiều_cao của bức ảnh , và với mỗi phần vị_trí (i , j) của đường seam , ta có_thể đi tiếp đến các phần_tử (i + 1 , j - 1) , (i + 1 , j) , (i + 1 , j + 1) .
Tương_tự ta cũng có_thể định_nghĩa cho đường seam ngang ( horizontal seam ) .
Ví_dụ về các đường màu đen là các đường seam trong hình dưới_đây .
Chúng_ta sẽ tìm_kiếm một đường seam sao_cho có tổng_giá trị năng_lượng là nhỏ nhất (theo chiều chúng_ta chọn) : s= \min \limits_s \sum\limits_i=1n e(I(s_i)) .
Cách để tìm được kết_quả tối_ưu cho bài toàn là sử_dụng phương_pháp quy_hoạch_động .
Tìm đường seam tối_ưu từ biên trên của ảnh đến mỗi điểm_ảnh (i , j) .
Gọi_Mi , j là giá_trị năng_lượng nhỏ nhất đi từ biên trên của ảnh đến điểm_ảnh (i , j) .
M1 , j = e(1 , j) với e(i , j) là năng_lượng điểm_ảnh tại (i , j) .
Mi , j = min(Mi - 1 , j - 1 , Mi - 1 , j , Mi - 1 , j + 1) + e(i , j) .
Ở biên dưới của ảnh , ta tìm điểm đường seam tối_ưu (tổng giá_trị năng_lượng thấp nhất thông_qua bảng phương_án M) và đi ngược về để tìm đường_đi tối_ưu .
Lưu_ý : trong đoạn code dưới_đây trả về một ma_trận n m chỉ gồm 0 và 1 với các điểm_ảnh trên đường_đi seam sẽ có_giá trị là 0 và ngược_lại .
Để tìm đường seam ngang , ta chỉ_cần chuyển_vị ma_trận năng_lượng lại .
function optSeamMask , seamEnergy = findOptSeam ( energy ) % Input : mảng 2 chiều là năng_lượng của các điểm_ảnh % Output : Đường seam dọc tối_ưu amp; năng_lượng % Mảng optSeamMask gồm 0/1 , với 0 thể_hiện điểm đó thuộc đường seam % Để tìm đường seam ngang tối_ưu , cho Input là ma_trận chuyển_vị % Tính mảng quy_hoạch_động M cho các đường seam dọc M = padarray ( energy , 0 1 , realmax ( double )); % M = mảng energy thêm 2 cột có_giá trị cực_đại ở đầu và cuối để tránh xử_lý_biên sz = size ( M ); for i = 2 : sz ( 1 ) for j = 2 : ( sz ( 2 ) - 1 ) neighbors = M ( i - 1 , j - 1 ) M ( i - 1 , j ) M ( i - 1 , j + 1 ); M ( i , j ) = M ( i , j ) + min ( neighbors ); end end % Tìm phần_tử nhỏ nhất hàng cuối val , indJ = min ( M ( sz ( 1 ) , : )); seamEnergy = val ; optSeamMask = zeros ( size ( energy ) , uint8 ); % Đi_ngược_lại và truy vết for i = sz ( 1 ) : - 1 : 2 % optSeam(i) = indJ - 1; optSeamMask ( i , indJ - 1 ) = 1 ; % -1 vì lúc đầu ta thêm một cột 0 vào bên trái neighbors = M ( i - 1 , indJ - 1 ) M ( i - 1 , indJ ) M ( i - 1 , indJ + 1 ); val , indIncr = min ( neighbors ); seamEnergy = seamEnergy + val ; indJ = indJ + ( indIncr - 2 ); % (x - 2) : 1 , 2-gt;-1 , 1 end optSeamMask ( 1 , indJ - 1 ) = 1 ; % -1 vì lúc đầu ta thêm một cột 0 vào bên trái optSeamMask = ~ optSeamMask ; end Tìm phương_án tối_ưu để xóa đường seam Bây_giờ ta có_thể tính_toán ra được đường seam và sử_dụng đoạn code dưới_đây , ta có_thể loại_bỏ đường seam ra khỏi bức ảnh .
function imageReduced = reduceImageByMaskVertical ( image , seamMask ) % Input : Ảnh amp; mask của đường seam % Output : Ảnh sau khi xóa đường seam dọc imageReduced = zeros ( size ( image , 1 ) , size ( image , 2 ) - 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) imageReduced ( i , : , 1 ) = image ( i , seamMask ( i , : ) , 1 ); imageReduced ( i , : , 2 ) = image ( i , seamMask ( i , : ) , 2 ); imageReduced ( i , : , 3 ) = image ( i , seamMask ( i , : ) , 3 ); end end function imageReduced = reduceImageByMaskHorizontal ( image , seamMask ) % Input : Ảnh amp; mask của đường seam % Output : Ảnh sau khi xóa đường seam ngang imageReduced = zeros ( size ( image , 1 ) - 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) imageReduced ( : , j , 1 ) = image ( seamMask ( : , j ) , j , 1 ); imageReduced ( : , j , 2 ) = image ( seamMask ( : , j ) , j , 2 ); imageReduced ( : , j , 3 ) = image ( seamMask ( : , j ) , j , 3 ); end end Đây là một thuật_toán hiệu_quả để làm giám kích_thước ảnh theo một_chiều - chỉ_cần việc tìm và xóa các đường seam nhiều lần như bạn cần .
Nhưng nếu làm giảm kích_thước theo cả hai chiều , ta cần phải làm như_thế nào ?
Làm_sao để quyết_định rằng ở mỗi lần lắp đưa_ra quyết_định là xóa theo dòng hay cột sẽ tốt hơn ?
Vấn_đề này một_lần nữa được giải_quyết bằng quy_hoạch_động .
Ta gọi T(i , j) là giá_trị năng_lượng thấp nhất khi ta loại_bỏ i đường seam theo chiều_dọc và j đường seam theo chiều_ngang .
Cụ_thể : T(i , j) = min(T(i , j-1) + E(seamVertical) , T(i-1 , j) + E(seamHorizontal)) .
Trong đó E(seamVertical) là giá_trị nhỏ nhất (tối ưu) đường seam dọc loại_bỏ đi , E(seamHorizontal) là giá_trị nhỏ nhất (tối ưu) đường seam ngang loại_bỏ đi .
Ta sử_dụng thêm một mảng transBitMask(i , j) lưu truy vết đường_đi cho bản phương_án T(i , j) .
transBitMask(i , j) = 1 bỏ_đi đường seam dọc , transBitMask(i , j) = 0 bỏ_đi đường seam ngang .
Nhìn một đoạn code giả dưới_đây để có_thể dễ hình_dung .
1) T(0 , 0) = 0; 2) Khởi tạo T : for all j T(0 , j) = T(0 , j - 1) + E(seamVertical); for all i T(i , 0) = T(j - 1 , 0) + E(seamHorizontal); 3) Initialize borders of TransBitMask (TBM) : for all j TBM(0 , j) = 1; for all i TBM(0 , i) = 0; 4) Tính_T và TBM : for i = 2 to r imageWithoutRow = image; for j = 2 to c energy = computeEnergy(imageWithoutRow); horizontalSeamEnergy = findHorizontalSeamEnergy(energy); verticalSeamEnergy = findVerticalSeamEnergy(energy); tVertical = T(i - 1 , j) + verticalSeamEnergy; tHorizontal = T(i , j - 1) _ horizontalSeamEnergy; if (tVertical lt; tHorizontal) T(i , j) = tVertical; TBM(i , j) = 1 else T(i , j) = tHorizontal; TBM(i , j) = 0 // Xóa đường seam dọc imageWithoutRow = removeVerticalSeam(energy); energy = computeEnergy(image); image = removeHorizontalSeam(energy); 5) Truy vết theo T và TBM .
Đoạn code_bằng matlab .
Chú_ý ở pseduocode dùng zerobased index , do matlab sử_dụng onebased index nên cần phải đẩy index lên 1 đơn_vị .
function T , transBitMask = findTransportMatrix ( sizeReduction , image ) % Input : Kích_thước cần giảm amp; ảnh gốc % Output : T , TBM định_nghĩa ở trên T = zeros ( sizeReduction ( 1 ) + 1 , sizeReduction ( 2 ) + 1 , double ); transBitMask = ones ( size ( T )) - 1 ; % Khởi tạo T(i , 1) , T(1 , i) , TBM(i , 1) , TBM(1 , i) imageNoRow = image ; for i = 2 : size ( T , 1 ) % Tính_năng lượng energy = energyRGB ( imageNoRow ); % Tìm đường seam ngang tối_ưu optSeamMask , seamEnergyRow = findOptSeam ( energy ); % Xóa đường seam imageNoRow = reduceImageByMask ( imageNoRow , optSeamMask , 0 ); % Tính_T và TBM_T ( i , 1 ) = T ( i - 1 , 1 ) + seamEnergyRow ; transBitMask ( i , 1 ) = 0 ; end ; imageNoColumn = image ; for j = 2 : size ( T , 2 ) % Tính_năng lượng energy = energyRGB ( imageNoColumn ); % Tìm đường seam dọc optSeamMask , seamEnergyColumn = findOptSeam ( energy ); % Xóa đường seam dọc imageNoColumn = reduceImageByMask ( imageNoColumn , optSeamMask , 1 ); % Tính_TBM amp; T transBitMask ( 1 , j ) = 1 ; T ( 1 , j ) = T ( 1 , j - 1 ) + seamEnergyColumn ; end ; % Xóa 1 hàng và 1 cột energy = energyRGB ( image ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 0 ); energy = energyRGB ( image ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 1 ); % fill in internal part for i = 2 : size ( T , 1 ) imageWithoutRow = image ; % Ta sẽ xóa 1 hàng của imageWithoutRow for j = 2 : size ( T , 2 ) energy = energyRGB ( imageWithoutRow ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageWithoutRow , optSeamMaskRow , 0 ); optSeamMaskColumn , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageWithoutRow , optSeamMaskColumn , 1 ); neighbors = ( T ( i - 1 , j ) + seamEnergyRow ) ( T ( i , j - 1 ) + seamEnergyColumn ); val , ind = min ( neighbors ); T ( i , j ) = val ; transBitMask ( i , j ) = ind - 1 ; % Ta xóa lần_lượt từng cột imageWithoutRow = imageNoColumn ; end ; energy = energyRGB ( image ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); % move from top to bottom image = reduceImageByMask ( image , optSeamMaskRow , 0 ); end ; end Phóng to hình_ảnh Để phóng to hình_ảnh , thay_vì ta loại_bỏ đường seam ra khỏi ảnh , thì ta thêm một đường seam mới vào với giá_trị trung_bình của các điểm_ảnh lận cận .
function imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ) % Input : Ảnh và đường seam % Output : Ảnh đã được phóng to thêm 1 cột avg = ( image , i , j , k ) ( image ( i , j - 1 , k ) + image ( i , j + 1 , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) , size ( image , 2 ) + 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) j = find ( seamMask ( i , : ) ~= 1 ); imageEnlarged ( i , : , 1 ) = image ( i , 1 : j , 1 ) , avg ( image , i , j , 1 ) , image ( i , j + 1 : end , 1 ); imageEnlarged ( i , : , 2 ) = image ( i , 1 : j , 2 ) , avg ( image , i , j , 2 ) , image ( i , j + 1 : end , 2 ); imageEnlarged ( i , : , 3 ) = image ( i , 1 : j , 3 ) , avg ( image , i , j , 3 ) , image ( i , j + 1 : end , 3 ); end ; end function imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ) % Input : Ảnh và đường seam % Output : Ảnh đã được phóng to thêm 1 hàng avg = ( image , i , j , k ) ( image ( i - 1 , j , k ) + image ( i + 1 , j , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) + 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) i = find ( seamMask ( : , j ) ~= 1 ); imageEnlarged ( : , j , 1 ) = image ( 1 : i , j , 1 ); avg ( image , i , j , 1 ); image ( i + 1 : end , j , 1 ); imageEnlarged ( : , j , 2 ) = image ( 1 : i , j , 2 ); avg ( image , i , j , 2 ); image ( i + 1 : end , j , 2 ); imageEnlarged ( : , j , 3 ) = image ( 1 : i , j , 3 ); avg ( image , i , j , 3 ); image ( i + 1 : end , j , 3 ); end ; end Source code Dưới_đây là toàn_bộ code của tác_giả (giữ nguyên lại comment gốc bằng tiếng Anh) % (C) Copyright_Kirill_Lykov 2013 .
% % Distributed under the FreeBSD_Software_License (See accompanying file license . txt) function image = seamCarving ( newSize , image ) % apply seam carving to the_image % following paper by Avidan and Shamir 07 sizeReductionX = size ( image , 1 ) - newSize ( 1 ); sizeReductionY = size ( image , 2 ) - newSize ( 2 ); mmax = ( left , right ) max ( left right ); image = seamCarvingReduce ( mmax ( 0 , sizeReductionX ) , mmax ( 0 , sizeReductionY ) , image ); image = seamCarvingEnlarge ( mmax ( 0 , - sizeReductionX ) , mmax ( 0 , - sizeReductionY ) , image ); end function image = seamCarvingReduce ( sizeReduction , image ) if ( sizeReduction == 0 ) return ; end ; T , transBitMask = findTransportMatrix ( sizeReduction , image ); image = addOrDeleteSeams ( transBitMask , sizeReduction , image , reduceImageByMask ); end % TODO_Bug : enlarge gives artifacts althout I chouse different seams as described % in 4 . 3 in the_paper function image = seamCarvingEnlarge ( sizeEnlarge , image ) if ( sizeEnlarge == 0 ) return ; end ; T , transBitMask = findTransportMatrix ( sizeEnlarge , image ); image = addOrDeleteSeams ( transBitMask , sizeEnlarge , image , enlargeImageByMask ); end function T , transBitMask = findTransportMatrix ( sizeReduction , image ) % find optimal order of removing raws and columns T = zeros ( sizeReduction ( 1 ) + 1 , sizeReduction ( 2 ) + 1 , double ); transBitMask = ones ( size ( T )) - 1 ; % fill in borders imageNoRow = image ; for i = 2 : size ( T , 1 ) energy = energyRGB ( imageNoRow ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageNoRow , optSeamMask , 0 ); transBitMask ( i , 1 ) = 0 ; T ( i , 1 ) = T ( i - 1 , 1 ) + seamEnergyRow ; end ; imageNoColumn = image ; for j = 2 : size ( T , 2 ) energy = energyRGB ( imageNoColumn ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageNoColumn , optSeamMask , 1 ); transBitMask ( 1 , j ) = 1 ; T ( 1 , j ) = T ( 1 , j - 1 ) + seamEnergyColumn ; end ; % on the borders , just remove one column and one row before proceeding energy = energyRGB ( image ); optSeamMask , seamEnergyRow = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 0 ); energy = energyRGB ( image ); optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = reduceImageByMask ( image , optSeamMask , 1 ); % fill in internal part for i = 2 : size ( T , 1 ) imageWithoutRow = image ; % copy for deleting columns for j = 2 : size ( T , 2 ) energy = energyRGB ( imageWithoutRow ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); imageNoRow = reduceImageByMask ( imageWithoutRow , optSeamMaskRow , 0 ); optSeamMaskColumn , seamEnergyColumn = findOptSeam ( energy ); imageNoColumn = reduceImageByMask ( imageWithoutRow , optSeamMaskColumn , 1 ); neighbors = ( T ( i - 1 , j ) + seamEnergyRow ) ( T ( i , j - 1 ) + seamEnergyColumn ); val , ind = min ( neighbors ); T ( i , j ) = val ; transBitMask ( i , j ) = ind - 1 ; % move from left to right imageWithoutRow = imageNoColumn ; end ; energy = energyRGB ( image ); optSeamMaskRow , seamEnergyRow = findOptSeam ( energy ); % move from top to bottom image = reduceImageByMask ( image , optSeamMaskRow , 0 ); end ; end function image = addOrDeleteSeams ( transBitMask , sizeReduction , image , operation ) % delete seams following optimal way i = size ( transBitMask , 1 ); j = size ( transBitMask , 2 ); for it = 1 : ( sizeReduction ( 1 ) + sizeReduction ( 2 )) energy = energyRGB ( image ); if ( transBitMask ( i , j ) == 0 ) optSeamMask , seamEnergyRaw = findOptSeam ( energy ); image = operation ( image , optSeamMask , 0 ); i = i - 1 ; else optSeamMask , seamEnergyColumn = findOptSeam ( energy ); image = operation ( image , optSeamMask , 1 ); j = j - 1 ; end ; end ; end function optSeamMask , seamEnergy = findOptSeam ( energy ) % following paper by Avidan and Shamir 07 % finds optimal seam % returns mask with 0 mean a pixel is in the_seam % find M for_vertical seams % for_vertical - use I_M = padarray ( energy , 0 1 , realmax ( double )); % to avoid handling border elements sz = size ( M ); for i = 2 : sz ( 1 ) for j = 2 : ( sz ( 2 ) - 1 ) neighbors = M ( i - 1 , j - 1 ) M ( i - 1 , j ) M ( i - 1 , j + 1 ); M ( i , j ) = M ( i , j ) + min ( neighbors ); end end % find the min element in the last raw val , indJ = min ( M ( sz ( 1 ) , : )); seamEnergy = val ; %optSeam = zeros(sz(1) , 1 , int32); optSeamMask = zeros ( size ( energy ) , uint8 ); %indJ = indJ - 1; % because of padding on 1 element from left %go backward and save (i , j) for i = sz ( 1 ) : - 1 : 2 %optSeam(i) = indJ - 1; optSeamMask ( i , indJ - 1 ) = 1 ; % -1 because of padding on 1 element from left neighbors = M ( i - 1 , indJ - 1 ) M ( i - 1 , indJ ) M ( i - 1 , indJ + 1 ); val , indIncr = min ( neighbors ); seamEnergy = seamEnergy + val ; indJ = indJ + ( indIncr - 2 ); % (x - 2) : 1 , 2-gt;-1 , 1 end %optSeam(1) = indJ; % to avoid if in loop becuase matlab is slow as hell optSeamMask ( 1 , indJ - 1 ) = 1 ; % -1 because of padding on 1 element from left optSeamMask = ~ optSeamMask ; end function imageReduced = reduceImageByMask ( image , seamMask , isVerical ) % removes pixels by input mask % removes vertical line if isVerical == 1 , otherwise horizontal if ( isVerical ) imageReduced = reduceImageByMaskVertical ( image , seamMask ); else imageReduced = reduceImageByMaskHorizontal ( image , seamMask ); end ; end % could not find a more elegant way to do it function imageReduced = reduceImageByMaskVertical ( image , seamMask ) imageReduced = zeros ( size ( image , 1 ) , size ( image , 2 ) - 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) imageReduced ( i , : , 1 ) = image ( i , seamMask ( i , : ) , 1 ); imageReduced ( i , : , 2 ) = image ( i , seamMask ( i , : ) , 2 ); imageReduced ( i , : , 3 ) = image ( i , seamMask ( i , : ) , 3 ); end end function imageReduced = reduceImageByMaskHorizontal ( image , seamMask ) imageReduced = zeros ( size ( image , 1 ) - 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) imageReduced ( : , j , 1 ) = image ( seamMask ( : , j ) , j , 1 ); imageReduced ( : , j , 2 ) = image ( seamMask ( : , j ) , j , 2 ); imageReduced ( : , j , 3 ) = image ( seamMask ( : , j ) , j , 3 ); end end function imageEnlarged = enlargeImageByMask ( image , seamMask , isVerical ) % removes pixels by input mask % removes vertical line if isVerical == 1 , otherwise horizontal if ( isVerical ) imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ); else imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ); end ; end function imageEnlarged = enlargeImageByMaskVertical ( image , seamMask ) avg = ( image , i , j , k ) ( image ( i , j - 1 , k ) + image ( i , j + 1 , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) , size ( image , 2 ) + 1 , size ( image , 3 )); for i = 1 : size ( seamMask , 1 ) j = find ( seamMask ( i , : ) ~= 1 ); imageEnlarged ( i , : , 1 ) = image ( i , 1 : j , 1 ) , avg ( image , i , j , 1 ) , image ( i , j + 1 : end , 1 ); imageEnlarged ( i , : , 2 ) = image ( i , 1 : j , 2 ) , avg ( image , i , j , 2 ) , image ( i , j + 1 : end , 2 ); imageEnlarged ( i , : , 3 ) = image ( i , 1 : j , 3 ) , avg ( image , i , j , 3 ) , image ( i , j + 1 : end , 3 ); end ; end function imageEnlarged = enlargeImageByMaskHorizontal ( image , seamMask ) avg = ( image , i , j , k ) ( image ( i - 1 , j , k ) + image ( i + 1 , j , k ))/ 2 ; imageEnlarged = zeros ( size ( image , 1 ) + 1 , size ( image , 2 ) , size ( image , 3 )); for j = 1 : size ( seamMask , 2 ) i = find ( seamMask ( : , j ) ~= 1 ); imageEnlarged ( : , j , 1 ) = image ( 1 : i , j , 1 ); avg ( image , i , j , 1 ); image ( i + 1 : end , j , 1 ); imageEnlarged ( : , j , 2 ) = image ( 1 : i , j , 2 ); avg ( image , i , j , 2 ); image ( i + 1 : end , j , 2 ); imageEnlarged ( : , j , 3 ) = image ( 1 : i , j , 3 ); avg ( image , i , j , 3 ); image ( i + 1 : end , j , 3 ); end ; end function res = energyRGB ( I ) % returns energy of all pixelels % e = dI/dx + dI/dy res = energyGrey ( I ( : , : , 1 )) + energyGrey ( I ( : , : , 2 )) + energyGrey ( I ( : , : , 3 )); end function res = energyGrey ( I ) % returns energy of all pixelels % e = dI/dx + dI/dy res = abs ( imfilter ( I , - 1 , 0 , 1 , replicate )) + abs ( imfilter ( I , - 1 ; 0 ; 1 , replicate )); end Tham_khảo Wikipedia_Seam_Carving for Content-Aware_Image_Scaling https : //jeremykun . com/2013/03/04/seam-carving-for-content-aware-image-scaling/ http : //kirilllykov . github . io/blog/2013/06/06/seam-carving-algorithm/
